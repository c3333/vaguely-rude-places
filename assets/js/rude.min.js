/*!
 * jQuery JavaScript Library v2.1.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-18T15:11Z
 */
(function(global, factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        // For CommonJS and CommonJS-like environments where a proper `window`
        // is present, execute the factory and get jQuery.
        // For environments that do not have a `window` with a `document`
        // (such as Node.js), expose a factory as module.exports.
        // This accentuates the need for the creation of a real `window`.
        // e.g. var jQuery = require("jquery")(window);
        // See ticket #14549 for more info.
        module.exports = global.document ? factory(global, true) : function(w) {
            if (!w.document) {
                throw new Error("jQuery requires a window with a document");
            }
            return factory(w);
        };
    } else {
        factory(global);
    }
})(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
    // Support: Firefox 18+
    // Can't be in strict mode, several libs including ASP.NET trace
    // the stack via arguments.caller.callee and Firefox dies if
    // you try to trace through "use strict" call chains. (#13335)
    //
    var arr = [];
    var slice = arr.slice;
    var concat = arr.concat;
    var push = arr.push;
    var indexOf = arr.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var support = {};
    var // Use the correct document accordingly with window argument (sandbox)
    document = window.document, version = "2.1.3", // Define a local copy of jQuery
    jQuery = function(selector, context) {
        // The jQuery object is actually just the init constructor 'enhanced'
        // Need init if jQuery is called (just allow error to be thrown if not included)
        return new jQuery.fn.init(selector, context);
    }, // Support: Android<4.1
    // Make sure we trim BOM and NBSP
    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, // Matches dashed string for camelizing
    rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, // Used by jQuery.camelCase as callback to replace()
    fcamelCase = function(all, letter) {
        return letter.toUpperCase();
    };
    jQuery.fn = jQuery.prototype = {
        // The current version of jQuery being used
        jquery: version,
        constructor: jQuery,
        // Start with an empty selector
        selector: "",
        // The default length of a jQuery object is 0
        length: 0,
        toArray: function() {
            return slice.call(this);
        },
        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function(num) {
            // Return just the one element from the set
            // Return all the elements in a clean array
            return num != null ? num < 0 ? this[num + this.length] : this[num] : slice.call(this);
        },
        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function(elems) {
            // Build a new jQuery matched element set
            var ret = jQuery.merge(this.constructor(), elems);
            // Add the old object onto the stack (as a reference)
            ret.prevObject = this;
            ret.context = this.context;
            // Return the newly-formed element set
            return ret;
        },
        // Execute a callback for every element in the matched set.
        // (You can seed the arguments with an array of args, but this is
        // only used internally.)
        each: function(callback, args) {
            return jQuery.each(this, callback, args);
        },
        map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function() {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        eq: function(i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [ this[j] ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor(null);
        },
        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };
    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        // Handle a deep copy situation
        if (typeof target === "boolean") {
            deep = target;
            // Skip the boolean and the target
            target = arguments[i] || {};
            i++;
        }
        // Handle case when target is a string or something (possible in deep copy)
        if (typeof target !== "object" && !jQuery.isFunction(target)) {
            target = {};
        }
        // Extend jQuery itself if only one argument is passed
        if (i === length) {
            target = this;
            i--;
        }
        for (;i < length; i++) {
            // Only deal with non-null/undefined values
            if ((options = arguments[i]) != null) {
                // Extend the base object
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    // Prevent never-ending loop
                    if (target === copy) {
                        continue;
                    }
                    // Recurse if we're merging plain objects or arrays
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }
                        // Never move original objects, clone them
                        target[name] = jQuery.extend(deep, clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        // Return the modified object
        return target;
    };
    jQuery.extend({
        // Unique for each copy of jQuery on the page
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
        // Assume jQuery is ready without the ready module
        isReady: true,
        error: function(msg) {
            throw new Error(msg);
        },
        noop: function() {},
        isFunction: function(obj) {
            return jQuery.type(obj) === "function";
        },
        isArray: Array.isArray,
        isWindow: function(obj) {
            return obj != null && obj === obj.window;
        },
        isNumeric: function(obj) {
            // parseFloat NaNs numeric-cast false positives (null|true|false|"")
            // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
            // subtraction forces infinities to NaN
            // adding 1 corrects loss of precision from parseFloat (#15100)
            return !jQuery.isArray(obj) && obj - parseFloat(obj) + 1 >= 0;
        },
        isPlainObject: function(obj) {
            // Not plain objects:
            // - Any object or value whose internal [[Class]] property is not "[object Object]"
            // - DOM nodes
            // - window
            if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                return false;
            }
            if (obj.constructor && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                return false;
            }
            // If the function hasn't returned already, we're confident that
            // |obj| is a plain object, created by {} or constructed with new Object
            return true;
        },
        isEmptyObject: function(obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },
        type: function(obj) {
            if (obj == null) {
                return obj + "";
            }
            // Support: Android<4.0, iOS<6 (functionish RegExp)
            return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
        },
        // Evaluates a script in a global context
        globalEval: function(code) {
            var script, indirect = eval;
            code = jQuery.trim(code);
            if (code) {
                // If the code includes a valid, prologue position
                // strict mode pragma, execute code by injecting a
                // script tag into the document.
                if (code.indexOf("use strict") === 1) {
                    script = document.createElement("script");
                    script.text = code;
                    document.head.appendChild(script).parentNode.removeChild(script);
                } else {
                    // Otherwise, avoid the DOM node creation, insertion
                    // and removal by using an indirect global eval
                    indirect(code);
                }
            }
        },
        // Convert dashed to camelCase; used by the css and data modules
        // Support: IE9-11+
        // Microsoft forgot to hump their vendor prefix (#9572)
        camelCase: function(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        },
        nodeName: function(elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },
        // args is for internal usage only
        each: function(obj, callback, args) {
            var value, i = 0, length = obj.length, isArray = isArraylike(obj);
            if (args) {
                if (isArray) {
                    for (;i < length; i++) {
                        value = callback.apply(obj[i], args);
                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.apply(obj[i], args);
                        if (value === false) {
                            break;
                        }
                    }
                }
            } else {
                if (isArray) {
                    for (;i < length; i++) {
                        value = callback.call(obj[i], i, obj[i]);
                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.call(obj[i], i, obj[i]);
                        if (value === false) {
                            break;
                        }
                    }
                }
            }
            return obj;
        },
        // Support: Android<4.1
        trim: function(text) {
            return text == null ? "" : (text + "").replace(rtrim, "");
        },
        // results is for internal usage only
        makeArray: function(arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArraylike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === "string" ? [ arr ] : arr);
                } else {
                    push.call(ret, arr);
                }
            }
            return ret;
        },
        inArray: function(elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i);
        },
        merge: function(first, second) {
            var len = +second.length, j = 0, i = first.length;
            for (;j < len; j++) {
                first[i++] = second[j];
            }
            first.length = i;
            return first;
        },
        grep: function(elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
            // Go through the array, only saving the items
            // that pass the validator function
            for (;i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }
            return matches;
        },
        // arg is for internal usage only
        map: function(elems, callback, arg) {
            var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
            // Go through the array, translating each of the items to their new values
            if (isArray) {
                for (;i < length; i++) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            }
            // Flatten any nested arrays
            return concat.apply([], ret);
        },
        // A global GUID counter for objects
        guid: 1,
        // Bind a function to a context, optionally partially applying any
        // arguments.
        proxy: function(fn, context) {
            var tmp, args, proxy;
            if (typeof context === "string") {
                tmp = fn[context];
                context = fn;
                fn = tmp;
            }
            // Quick check to determine if target is callable, in the spec
            // this throws a TypeError, but we will just return undefined.
            if (!jQuery.isFunction(fn)) {
                return undefined;
            }
            // Simulated bind
            args = slice.call(arguments, 2);
            proxy = function() {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            };
            // Set the guid of unique handler to the same of original handler, so it can be removed
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;
            return proxy;
        },
        now: Date.now,
        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support: support
    });
    // Populate the class2type map
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });
    function isArraylike(obj) {
        var length = obj.length, type = jQuery.type(obj);
        if (type === "function" || jQuery.isWindow(obj)) {
            return false;
        }
        if (obj.nodeType === 1 && length) {
            return true;
        }
        return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    var Sizzle = /*!
 * Sizzle CSS Selector Engine v2.2.0-pre
 * http://sizzlejs.com/
 *
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-16
 */
    function(window) {
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, // Local document vars
        setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, // Instance-specific data
        expando = "sizzle" + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
            if (a === b) {
                hasDuplicate = true;
            }
            return 0;
        }, // General-purpose constants
        MAX_NEGATIVE = 1 << 31, // Instance methods
        hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, // Use a stripped-down indexOf as it's faster than native
        // http://jsperf.com/thor-indexof-vs-for/5
        indexOf = function(list, elem) {
            var i = 0, len = list.length;
            for (;i < len; i++) {
                if (list[i] === elem) {
                    return i;
                }
            }
            return -1;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", // Regular expressions
        // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
        whitespace = "[\\x20\\t\\r\\n\\f]", // http://www.w3.org/TR/css3-syntax/#characters
        characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", // Loosely modeled on CSS identifier characters
        // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
        // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
        identifier = characterEncoding.replace("w", "w#"), // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
        attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace + // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
        "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + characterEncoding + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
        // 1. quoted (capture 3; capture 4 or capture 5)
        "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
        "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + // 3. anything else (capture 2)
        ".*" + ")\\)|)", // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
        rwhitespace = new RegExp(whitespace + "+", "g"), rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            ID: new RegExp("^#(" + characterEncoding + ")"),
            CLASS: new RegExp("^\\.(" + characterEncoding + ")"),
            TAG: new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
            ATTR: new RegExp("^" + attributes),
            PSEUDO: new RegExp("^" + pseudos),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + booleans + ")$", "i"),
            // For use in libraries implementing .is()
            // We use this for POS matching in `select`
            needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, // Easily-parseable/retrievable ID or TAG or CLASS selectors
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_, escaped, escapedWhitespace) {
            var high = "0x" + escaped - 65536;
            // NaN means non-codepoint
            // Support: Firefox<24
            // Workaround erroneous numeric interpretation of +"0x"
            // BMP codepoint
            // Supplemental Plane codepoint (surrogate pair)
            return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
        }, // Used for iframes
        // See setDocument()
        // Removing the function wrapper causes a "Permission Denied"
        // error in IE
        unloadHandler = function() {
            setDocument();
        };
        // Optimize for push.apply( _, NodeList )
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
            // Support: Android<4.0
            // Detect silently failing push.apply
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ? // Leverage slice if possible
                function(target, els) {
                    push_native.apply(target, slice.call(els));
                } : // Support: IE<9
                // Otherwise append directly
                function(target, els) {
                    var j = target.length, i = 0;
                    // Can't trust NodeList.length
                    while (target[j++] = els[i++]) {}
                    target.length = j - 1;
                }
            };
        }
        function Sizzle(selector, context, results, seed) {
            var match, elem, m, nodeType, // QSA vars
            i, groups, old, nid, newContext, newSelector;
            if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                setDocument(context);
            }
            context = context || document;
            results = results || [];
            nodeType = context.nodeType;
            if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
                return results;
            }
            if (!seed && documentIsHTML) {
                // Try to shortcut find operations when possible (e.g., not under DocumentFragment)
                if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                    // Speed-up: Sizzle("#ID")
                    if (m = match[1]) {
                        if (nodeType === 9) {
                            elem = context.getElementById(m);
                            // Check parentNode to catch when Blackberry 4.6 returns
                            // nodes that are no longer in the document (jQuery #6963)
                            if (elem && elem.parentNode) {
                                // Handle the case where IE, Opera, and Webkit return items
                                // by name instead of ID
                                if (elem.id === m) {
                                    results.push(elem);
                                    return results;
                                }
                            } else {
                                return results;
                            }
                        } else {
                            // Context is not a document
                            if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                results.push(elem);
                                return results;
                            }
                        }
                    } else if (match[2]) {
                        push.apply(results, context.getElementsByTagName(selector));
                        return results;
                    } else if ((m = match[3]) && support.getElementsByClassName) {
                        push.apply(results, context.getElementsByClassName(m));
                        return results;
                    }
                }
                // QSA path
                if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                    nid = old = expando;
                    newContext = context;
                    newSelector = nodeType !== 1 && selector;
                    // qSA works strangely on Element-rooted queries
                    // We can work around this by specifying an extra ID on the root
                    // and working up from there (Thanks to Andrew Dupont for the technique)
                    // IE 8 doesn't work on object elements
                    if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                        groups = tokenize(selector);
                        if (old = context.getAttribute("id")) {
                            nid = old.replace(rescape, "\\$&");
                        } else {
                            context.setAttribute("id", nid);
                        }
                        nid = "[id='" + nid + "'] ";
                        i = groups.length;
                        while (i--) {
                            groups[i] = nid + toSelector(groups[i]);
                        }
                        newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                        newSelector = groups.join(",");
                    }
                    if (newSelector) {
                        try {
                            push.apply(results, newContext.querySelectorAll(newSelector));
                            return results;
                        } catch (qsaError) {} finally {
                            if (!old) {
                                context.removeAttribute("id");
                            }
                        }
                    }
                }
            }
            // All others
            return select(selector.replace(rtrim, "$1"), context, results, seed);
        }
        /**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
        function createCache() {
            var keys = [];
            function cache(key, value) {
                // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                if (keys.push(key + " ") > Expr.cacheLength) {
                    // Only keep the most recent entries
                    delete cache[keys.shift()];
                }
                return cache[key + " "] = value;
            }
            return cache;
        }
        /**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
        function markFunction(fn) {
            fn[expando] = true;
            return fn;
        }
        /**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
        function assert(fn) {
            var div = document.createElement("div");
            try {
                return !!fn(div);
            } catch (e) {
                return false;
            } finally {
                // Remove from its parent by default
                if (div.parentNode) {
                    div.parentNode.removeChild(div);
                }
                // release memory in IE
                div = null;
            }
        }
        /**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
        function addHandle(attrs, handler) {
            var arr = attrs.split("|"), i = attrs.length;
            while (i--) {
                Expr.attrHandle[arr[i]] = handler;
            }
        }
        /**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
        function siblingCheck(a, b) {
            var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
            // Use IE sourceIndex if available on both nodes
            if (diff) {
                return diff;
            }
            // Check if b follows a
            if (cur) {
                while (cur = cur.nextSibling) {
                    if (cur === b) {
                        return -1;
                    }
                }
            }
            return a ? 1 : -1;
        }
        /**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
        function createInputPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === type;
            };
        }
        /**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
        function createButtonPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === "input" || name === "button") && elem.type === type;
            };
        }
        /**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
        function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
                argument = +argument;
                return markFunction(function(seed, matches) {
                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                    // Match elements found at the specified indexes
                    while (i--) {
                        if (seed[j = matchIndexes[i]]) {
                            seed[j] = !(matches[j] = seed[j]);
                        }
                    }
                });
            });
        }
        /**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
        function testContext(context) {
            return context && typeof context.getElementsByTagName !== "undefined" && context;
        }
        // Expose support vars for convenience
        support = Sizzle.support = {};
        /**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
        isXML = Sizzle.isXML = function(elem) {
            // documentElement is verified for cases where it doesn't yet exist
            // (such as loading iframes in IE - #4833)
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? documentElement.nodeName !== "HTML" : false;
        };
        /**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
        setDocument = Sizzle.setDocument = function(node) {
            var hasCompare, parent, doc = node ? node.ownerDocument || node : preferredDoc;
            // If no document and documentElement is available, return
            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                return document;
            }
            // Set our document
            document = doc;
            docElem = doc.documentElement;
            parent = doc.defaultView;
            // Support: IE>8
            // If iframe document is assigned to "document" variable and if iframe has been reloaded,
            // IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
            // IE6-8 do not support the defaultView property so parent will be undefined
            if (parent && parent !== parent.top) {
                // IE11 does not have attachEvent, so all must suffer
                if (parent.addEventListener) {
                    parent.addEventListener("unload", unloadHandler, false);
                } else if (parent.attachEvent) {
                    parent.attachEvent("onunload", unloadHandler);
                }
            }
            /* Support tests
	---------------------------------------------------------------------- */
            documentIsHTML = !isXML(doc);
            /* Attributes
	---------------------------------------------------------------------- */
            // Support: IE<8
            // Verify that getAttribute really returns attributes and not properties
            // (excepting IE8 booleans)
            support.attributes = assert(function(div) {
                div.className = "i";
                return !div.getAttribute("className");
            });
            /* getElement(s)By*
	---------------------------------------------------------------------- */
            // Check if getElementsByTagName("*") returns only elements
            support.getElementsByTagName = assert(function(div) {
                div.appendChild(doc.createComment(""));
                return !div.getElementsByTagName("*").length;
            });
            // Support: IE<9
            support.getElementsByClassName = rnative.test(doc.getElementsByClassName);
            // Support: IE<10
            // Check if getElementById returns elements by name
            // The broken getElementById methods don't pick up programatically-set names,
            // so use a roundabout getElementsByName test
            support.getById = assert(function(div) {
                docElem.appendChild(div).id = expando;
                return !doc.getElementsByName || !doc.getElementsByName(expando).length;
            });
            // ID find and filter
            if (support.getById) {
                Expr.find["ID"] = function(id, context) {
                    if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                        var m = context.getElementById(id);
                        // Check parentNode to catch when Blackberry 4.6 returns
                        // nodes that are no longer in the document #6963
                        return m && m.parentNode ? [ m ] : [];
                    }
                };
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        return elem.getAttribute("id") === attrId;
                    };
                };
            } else {
                // Support: IE6/7
                // getElementById is not reliable as a find shortcut
                delete Expr.find["ID"];
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                        return node && node.value === attrId;
                    };
                };
            }
            // Tag
            Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
                if (typeof context.getElementsByTagName !== "undefined") {
                    return context.getElementsByTagName(tag);
                } else if (support.qsa) {
                    return context.querySelectorAll(tag);
                }
            } : function(tag, context) {
                var elem, tmp = [], i = 0, // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                results = context.getElementsByTagName(tag);
                // Filter out possible comments
                if (tag === "*") {
                    while (elem = results[i++]) {
                        if (elem.nodeType === 1) {
                            tmp.push(elem);
                        }
                    }
                    return tmp;
                }
                return results;
            };
            // Class
            Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
                if (documentIsHTML) {
                    return context.getElementsByClassName(className);
                }
            };
            /* QSA/matchesSelector
	---------------------------------------------------------------------- */
            // QSA and matchesSelector support
            // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
            rbuggyMatches = [];
            // qSa(:focus) reports false when true (Chrome 21)
            // We allow this because of a bug in IE8/9 that throws an error
            // whenever `document.activeElement` is accessed on an iframe
            // So, we allow :focus to pass through QSA all the time to avoid the IE error
            // See http://bugs.jquery.com/ticket/13378
            rbuggyQSA = [];
            if (support.qsa = rnative.test(doc.querySelectorAll)) {
                // Build QSA regex
                // Regex strategy adopted from Diego Perini
                assert(function(div) {
                    // Select is set to empty string on purpose
                    // This is to test IE's treatment of not explicitly
                    // setting a boolean content attribute,
                    // since its presence should be enough
                    // http://bugs.jquery.com/ticket/12359
                    docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\f]' msallowcapture=''>" + "<option selected=''></option></select>";
                    // Support: IE8, Opera 11-12.16
                    // Nothing should be selected when empty strings follow ^= or $= or *=
                    // The test attribute must be unknown in Opera but "safe" for WinRT
                    // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                    if (div.querySelectorAll("[msallowcapture^='']").length) {
                        rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                    }
                    // Support: IE8
                    // Boolean attributes and "value" are not treated correctly
                    if (!div.querySelectorAll("[selected]").length) {
                        rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                    }
                    // Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
                    if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
                        rbuggyQSA.push("~=");
                    }
                    // Webkit/Opera - :checked should return selected option elements
                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                    // IE8 throws error here and will not see later tests
                    if (!div.querySelectorAll(":checked").length) {
                        rbuggyQSA.push(":checked");
                    }
                    // Support: Safari 8+, iOS 8+
                    // https://bugs.webkit.org/show_bug.cgi?id=136851
                    // In-page `selector#id sibing-combinator selector` fails
                    if (!div.querySelectorAll("a#" + expando + "+*").length) {
                        rbuggyQSA.push(".#.+[+~]");
                    }
                });
                assert(function(div) {
                    // Support: Windows 8 Native Apps
                    // The type and name attributes are restricted during .innerHTML assignment
                    var input = doc.createElement("input");
                    input.setAttribute("type", "hidden");
                    div.appendChild(input).setAttribute("name", "D");
                    // Support: IE8
                    // Enforce case-sensitivity of name attribute
                    if (div.querySelectorAll("[name=d]").length) {
                        rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                    }
                    // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                    // IE8 throws error here and will not see later tests
                    if (!div.querySelectorAll(":enabled").length) {
                        rbuggyQSA.push(":enabled", ":disabled");
                    }
                    // Opera 10-11 does not throw on post-comma invalid pseudos
                    div.querySelectorAll("*,:x");
                    rbuggyQSA.push(",.*:");
                });
            }
            if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                assert(function(div) {
                    // Check to see if it's possible to do matchesSelector
                    // on a disconnected node (IE 9)
                    support.disconnectedMatch = matches.call(div, "div");
                    // This should fail with an exception
                    // Gecko does not error, returns false instead
                    matches.call(div, "[s!='']:x");
                    rbuggyMatches.push("!=", pseudos);
                });
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
            /* Contains
	---------------------------------------------------------------------- */
            hasCompare = rnative.test(docElem.compareDocumentPosition);
            // Element contains another
            // Purposefully does not implement inclusive descendent
            // As in, an element does not contain itself
            contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function(a, b) {
                if (b) {
                    while (b = b.parentNode) {
                        if (b === a) {
                            return true;
                        }
                    }
                }
                return false;
            };
            /* Sorting
	---------------------------------------------------------------------- */
            // Document order sorting
            sortOrder = hasCompare ? function(a, b) {
                // Flag for duplicate removal
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                // Sort on method existence if only one input has compareDocumentPosition
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) {
                    return compare;
                }
                // Calculate position if both inputs belong to the same document
                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
                1;
                // Disconnected nodes
                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                    // Choose the first element that is related to our preferred document
                    if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                        return -1;
                    }
                    if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                        return 1;
                    }
                    // Maintain original order
                    return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                }
                return compare & 4 ? -1 : 1;
            } : function(a, b) {
                // Exit early if the nodes are identical
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [ a ], bp = [ b ];
                // Parentless nodes are either documents or disconnected
                if (!aup || !bup) {
                    return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                } else if (aup === bup) {
                    return siblingCheck(a, b);
                }
                // Otherwise we need full lists of their ancestors for comparison
                cur = a;
                while (cur = cur.parentNode) {
                    ap.unshift(cur);
                }
                cur = b;
                while (cur = cur.parentNode) {
                    bp.unshift(cur);
                }
                // Walk down the tree looking for a discrepancy
                while (ap[i] === bp[i]) {
                    i++;
                }
                // Do a sibling check if the nodes have a common ancestor
                // Otherwise nodes in our document sort first
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            };
            return doc;
        };
        Sizzle.matches = function(expr, elements) {
            return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function(elem, expr) {
            // Set document vars if needed
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            // Make sure that attribute selectors are quoted
            expr = expr.replace(rattributeQuotes, "='$1']");
            if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                try {
                    var ret = matches.call(elem, expr);
                    // IE 9's matchesSelector returns false on disconnected nodes
                    if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
                    // fragment in IE 9
                    elem.document && elem.document.nodeType !== 11) {
                        return ret;
                    }
                } catch (e) {}
            }
            return Sizzle(expr, document, null, [ elem ]).length > 0;
        };
        Sizzle.contains = function(context, elem) {
            // Set document vars if needed
            if ((context.ownerDocument || context) !== document) {
                setDocument(context);
            }
            return contains(context, elem);
        };
        Sizzle.attr = function(elem, name) {
            // Set document vars if needed
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            var fn = Expr.attrHandle[name.toLowerCase()], // Don't get fooled by Object.prototype properties (jQuery #13807)
            val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        /**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
        Sizzle.uniqueSort = function(results) {
            var elem, duplicates = [], j = 0, i = 0;
            // Unless we *know* we can detect duplicates, assume their presence
            hasDuplicate = !support.detectDuplicates;
            sortInput = !support.sortStable && results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
                while (elem = results[i++]) {
                    if (elem === results[i]) {
                        j = duplicates.push(i);
                    }
                }
                while (j--) {
                    results.splice(duplicates[j], 1);
                }
            }
            // Clear input after sorting to release objects
            // See https://github.com/jquery/sizzle/pull/225
            sortInput = null;
            return results;
        };
        /**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
        getText = Sizzle.getText = function(elem) {
            var node, ret = "", i = 0, nodeType = elem.nodeType;
            if (!nodeType) {
                // If no nodeType, this is expected to be an array
                while (node = elem[i++]) {
                    // Do not traverse comment nodes
                    ret += getText(node);
                }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                // Use textContent for elements
                // innerText usage removed for consistency of new lines (jQuery #11153)
                if (typeof elem.textContent === "string") {
                    return elem.textContent;
                } else {
                    // Traverse its children
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        ret += getText(elem);
                    }
                }
            } else if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue;
            }
            // Do not include comment or processing instruction nodes
            return ret;
        };
        Expr = Sizzle.selectors = {
            // Can be adjusted by the user
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: true
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: true
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(match) {
                    match[1] = match[1].replace(runescape, funescape);
                    // Move the given value to match[3] whether quoted or unquoted
                    match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                    if (match[2] === "~=") {
                        match[3] = " " + match[3] + " ";
                    }
                    return match.slice(0, 4);
                },
                CHILD: function(match) {
                    /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
                    match[1] = match[1].toLowerCase();
                    if (match[1].slice(0, 3) === "nth") {
                        // nth-* requires argument
                        if (!match[3]) {
                            Sizzle.error(match[0]);
                        }
                        // numeric x and y parameters for Expr.filter.CHILD
                        // remember that false/true cast respectively to 0/1
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                        match[5] = +(match[7] + match[8] || match[3] === "odd");
                    } else if (match[3]) {
                        Sizzle.error(match[0]);
                    }
                    return match;
                },
                PSEUDO: function(match) {
                    var excess, unquoted = !match[6] && match[2];
                    if (matchExpr["CHILD"].test(match[0])) {
                        return null;
                    }
                    // Accept quoted arguments as-is
                    if (match[3]) {
                        match[2] = match[4] || match[5] || "";
                    } else if (unquoted && rpseudo.test(unquoted) && (// Get excess from tokenize (recursively)
                    excess = tokenize(unquoted, true)) && (// advance to the next closing parenthesis
                    excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                        // excess is a negative index
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess);
                    }
                    // Return only captures needed by the pseudo filter method (type and argument)
                    return match.slice(0, 3);
                }
            },
            filter: {
                TAG: function(nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return nodeNameSelector === "*" ? function() {
                        return true;
                    } : function(elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                CLASS: function(className) {
                    var pattern = classCache[className + " "];
                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                        return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
                    });
                },
                ATTR: function(name, operator, check) {
                    return function(elem) {
                        var result = Sizzle.attr(elem, name);
                        if (result == null) {
                            return operator === "!=";
                        }
                        if (!operator) {
                            return true;
                        }
                        result += "";
                        return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
                    };
                },
                CHILD: function(type, what, argument, first, last) {
                    var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                    // Shortcut for :nth-*(n)
                    return first === 1 && last === 0 ? function(elem) {
                        return !!elem.parentNode;
                    } : function(elem, context, xml) {
                        var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
                        if (parent) {
                            // :(first|last|only)-(child|of-type)
                            if (simple) {
                                while (dir) {
                                    node = elem;
                                    while (node = node[dir]) {
                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                            return false;
                                        }
                                    }
                                    // Reverse direction for :only-* (if we haven't yet done so)
                                    start = dir = type === "only" && !start && "nextSibling";
                                }
                                return true;
                            }
                            start = [ forward ? parent.firstChild : parent.lastChild ];
                            // non-xml :nth-child(...) stores cache data on `parent`
                            if (forward && useCache) {
                                // Seek `elem` from a previously-cached index
                                outerCache = parent[expando] || (parent[expando] = {});
                                cache = outerCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = cache[0] === dirruns && cache[2];
                                node = nodeIndex && parent.childNodes[nodeIndex];
                                while (node = ++nodeIndex && node && node[dir] || (// Fallback to seeking `elem` from the start
                                diff = nodeIndex = 0) || start.pop()) {
                                    // When found, cache indexes on `parent` and break
                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                        outerCache[type] = [ dirruns, nodeIndex, diff ];
                                        break;
                                    }
                                }
                            } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                                diff = cache[1];
                            } else {
                                // Use the same loop as above to seek `elem` from the start
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                        // Cache the index of each encountered element
                                        if (useCache) {
                                            (node[expando] || (node[expando] = {}))[type] = [ dirruns, diff ];
                                        }
                                        if (node === elem) {
                                            break;
                                        }
                                    }
                                }
                            }
                            // Incorporate the offset, then check against cycle size
                            diff -= last;
                            return diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },
                PSEUDO: function(pseudo, argument) {
                    // pseudo-class names are case-insensitive
                    // http://www.w3.org/TR/selectors/#pseudo-classes
                    // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                    // Remember that setFilters inherits from pseudos
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                    // The user may use createPseudo to indicate that
                    // arguments are needed to create the filter function
                    // just as Sizzle does
                    if (fn[expando]) {
                        return fn(argument);
                    }
                    // But maintain support for old signatures
                    if (fn.length > 1) {
                        args = [ pseudo, pseudo, "", argument ];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                            var idx, matched = fn(seed, argument), i = matched.length;
                            while (i--) {
                                idx = indexOf(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                            }
                        }) : function(elem) {
                            return fn(elem, 0, args);
                        };
                    }
                    return fn;
                }
            },
            pseudos: {
                // Potentially complex pseudos
                not: markFunction(function(selector) {
                    // Trim the selector passed to compile
                    // to avoid treating leading and trailing
                    // spaces as combinators
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
                    return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                        // Match elements unmatched by `matcher`
                        while (i--) {
                            if (elem = unmatched[i]) {
                                seed[i] = !(matches[i] = elem);
                            }
                        }
                    }) : function(elem, context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        // Don't keep the element (issue #299)
                        input[0] = null;
                        return !results.pop();
                    };
                }),
                has: markFunction(function(selector) {
                    return function(elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                contains: markFunction(function(text) {
                    text = text.replace(runescape, funescape);
                    return function(elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),
                // "Whether an element is represented by a :lang() selector
                // is based solely on the element's language value
                // being equal to the identifier C,
                // or beginning with the identifier C immediately followed by "-".
                // The matching of C against the element's language value is performed case-insensitively.
                // The identifier C does not have to be a valid language name."
                // http://www.w3.org/TR/selectors/#lang-pseudo
                lang: markFunction(function(lang) {
                    // lang value must be a valid identifier
                    if (!ridentifier.test(lang || "")) {
                        Sizzle.error("unsupported lang: " + lang);
                    }
                    lang = lang.replace(runescape, funescape).toLowerCase();
                    return function(elem) {
                        var elemLang;
                        do {
                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                                elemLang = elemLang.toLowerCase();
                                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                            }
                        } while ((elem = elem.parentNode) && elem.nodeType === 1);
                        return false;
                    };
                }),
                // Miscellaneous
                target: function(elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                root: function(elem) {
                    return elem === docElem;
                },
                focus: function(elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                // Boolean properties
                enabled: function(elem) {
                    return elem.disabled === false;
                },
                disabled: function(elem) {
                    return elem.disabled === true;
                },
                checked: function(elem) {
                    // In CSS3, :checked should return both checked and selected elements
                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                    var nodeName = elem.nodeName.toLowerCase();
                    return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
                },
                selected: function(elem) {
                    // Accessing this property makes selected-by-default
                    // options in Safari work properly
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }
                    return elem.selected === true;
                },
                // Contents
                empty: function(elem) {
                    // http://www.w3.org/TR/selectors/#empty-pseudo
                    // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                    //   but not by others (comment: 8; processing instruction: 7; etc.)
                    // nodeType < 6 works because attributes (2) do not appear as children
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        if (elem.nodeType < 6) {
                            return false;
                        }
                    }
                    return true;
                },
                parent: function(elem) {
                    return !Expr.pseudos["empty"](elem);
                },
                // Element/input types
                header: function(elem) {
                    return rheader.test(elem.nodeName);
                },
                input: function(elem) {
                    return rinputs.test(elem.nodeName);
                },
                button: function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === "button" || name === "button";
                },
                text: function(elem) {
                    var attr;
                    // Support: IE<8
                    // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                    return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                },
                // Position-in-collection
                first: createPositionalPseudo(function() {
                    return [ 0 ];
                }),
                last: createPositionalPseudo(function(matchIndexes, length) {
                    return [ length - 1 ];
                }),
                eq: createPositionalPseudo(function(matchIndexes, length, argument) {
                    return [ argument < 0 ? argument + length : argument ];
                }),
                even: createPositionalPseudo(function(matchIndexes, length) {
                    var i = 0;
                    for (;i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                odd: createPositionalPseudo(function(matchIndexes, length) {
                    var i = 1;
                    for (;i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (;--i >= 0; ) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (;++i < length; ) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                })
            }
        };
        Expr.pseudos["nth"] = Expr.pseudos["eq"];
        // Add button/input type pseudos
        for (i in {
            radio: true,
            checkbox: true,
            file: true,
            password: true,
            image: true
        }) {
            Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in {
            submit: true,
            reset: true
        }) {
            Expr.pseudos[i] = createButtonPseudo(i);
        }
        // Easy API for creating new setFilters
        function setFilters() {}
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle.tokenize = function(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) {
                return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
                // Comma and first run
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) {
                        // Don't consume trailing commas as valid
                        soFar = soFar.slice(match[0].length) || soFar;
                    }
                    groups.push(tokens = []);
                }
                matched = false;
                // Combinators
                if (match = rcombinators.exec(soFar)) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        // Cast descendant combinators to space
                        type: match[0].replace(rtrim, " ")
                    });
                    soFar = soFar.slice(matched.length);
                }
                // Filters
                for (type in Expr.filter) {
                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            type: type,
                            matches: match
                        });
                        soFar = soFar.slice(matched.length);
                    }
                }
                if (!matched) {
                    break;
                }
            }
            // Return the length of the invalid excess
            // if we're just parsing
            // Otherwise, throw an error or return tokens
            // Cache the tokens
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        };
        function toSelector(tokens) {
            var i = 0, len = tokens.length, selector = "";
            for (;i < len; i++) {
                selector += tokens[i].value;
            }
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, checkNonElements = base && dir === "parentNode", doneName = done++;
            // Check against closest ancestor/preceding element
            // Check against all ancestor/preceding elements
            return combinator.first ? function(elem, context, xml) {
                while (elem = elem[dir]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                        return matcher(elem, context, xml);
                    }
                }
            } : function(elem, context, xml) {
                var oldCache, outerCache, newCache = [ dirruns, doneName ];
                // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
                if (xml) {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            if (matcher(elem, context, xml)) {
                                return true;
                            }
                        }
                    }
                } else {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            outerCache = elem[expando] || (elem[expando] = {});
                            if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                                // Assign to newCache so results back-propagate to previous elements
                                return newCache[2] = oldCache[2];
                            } else {
                                // Reuse newcache so results back-propagate to previous elements
                                outerCache[dir] = newCache;
                                // A match means we're done; a fail means we have to keep checking
                                if (newCache[2] = matcher(elem, context, xml)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
                var i = matchers.length;
                while (i--) {
                    if (!matchers[i](elem, context, xml)) {
                        return false;
                    }
                }
                return true;
            } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
            var i = 0, len = contexts.length;
            for (;i < len; i++) {
                Sizzle(selector, contexts[i], results);
            }
            return results;
        }
        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
            for (;i < len; i++) {
                if (elem = unmatched[i]) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) {
                            map.push(i);
                        }
                    }
                }
            }
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function(seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, // Get initial elements from seed or context
                elems = seed || multipleContexts(selector || "*", context.nodeType ? [ context ] : context, []), // Prefilter to get matcher input, preserving a map for seed-results synchronization
                matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
                [] : // ...otherwise use results directly
                results : matcherIn;
                // Find primary matches
                if (matcher) {
                    matcher(matcherIn, matcherOut, context, xml);
                }
                // Apply postFilter
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);
                    // Un-match failing elements by moving them back to matcherIn
                    i = temp.length;
                    while (i--) {
                        if (elem = temp[i]) {
                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                        }
                    }
                }
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            // Get the final matcherOut by condensing this intermediate into postFinder contexts
                            temp = [];
                            i = matcherOut.length;
                            while (i--) {
                                if (elem = matcherOut[i]) {
                                    // Restore matcherIn since elem is not yet a final match
                                    temp.push(matcherIn[i] = elem);
                                }
                            }
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        // Move matched elements from seed to results to keep them synchronized
                        i = matcherOut.length;
                        while (i--) {
                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                                seed[temp] = !(results[temp] = elem);
                            }
                        }
                    }
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) {
                        postFinder(null, results, matcherOut, xml);
                    } else {
                        push.apply(results, matcherOut);
                    }
                }
            });
        }
        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, // The foundational matcher ensures that elements are reachable from top-level context(s)
            matchContext = addCombinator(function(elem) {
                return elem === checkContext;
            }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
                return indexOf(checkContext, elem) > -1;
            }, implicitRelative, true), matchers = [ function(elem, context, xml) {
                var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                // Avoid hanging onto element (issue #299)
                checkContext = null;
                return ret;
            } ];
            for (;i < len; i++) {
                if (matcher = Expr.relative[tokens[i].type]) {
                    matchers = [ addCombinator(elementMatcher(matchers), matcher) ];
                } else {
                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                    // Return special upon seeing a positional matcher
                    if (matcher[expando]) {
                        // Find the next relative operator (if any) for proper handling
                        j = ++i;
                        for (;j < len; j++) {
                            if (Expr.relative[tokens[j].type]) {
                                break;
                            }
                        }
                        // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                            value: tokens[i - 2].type === " " ? "*" : ""
                        })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                    }
                    matchers.push(matcher);
                }
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
                var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, // We must always have either seed elements or outermost context
                elems = seed || byElement && Expr.find["TAG"]("*", outermost), // Use integer dirruns iff this is the outermost matcher
                dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || .1, len = elems.length;
                if (outermost) {
                    outermostContext = context !== document && context;
                }
                // Add elements passing elementMatchers directly to results
                // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
                // Support: IE<9, Safari
                // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                for (;i !== len && (elem = elems[i]) != null; i++) {
                    if (byElement && elem) {
                        j = 0;
                        while (matcher = elementMatchers[j++]) {
                            if (matcher(elem, context, xml)) {
                                results.push(elem);
                                break;
                            }
                        }
                        if (outermost) {
                            dirruns = dirrunsUnique;
                        }
                    }
                    // Track unmatched elements for set filters
                    if (bySet) {
                        // They will have gone through all possible matchers
                        if (elem = !matcher && elem) {
                            matchedCount--;
                        }
                        // Lengthen the array for every element, matched or not
                        if (seed) {
                            unmatched.push(elem);
                        }
                    }
                }
                // Apply set filters to unmatched elements
                matchedCount += i;
                if (bySet && i !== matchedCount) {
                    j = 0;
                    while (matcher = setMatchers[j++]) {
                        matcher(unmatched, setMatched, context, xml);
                    }
                    if (seed) {
                        // Reintegrate element matches to eliminate the need for sorting
                        if (matchedCount > 0) {
                            while (i--) {
                                if (!(unmatched[i] || setMatched[i])) {
                                    setMatched[i] = pop.call(results);
                                }
                            }
                        }
                        // Discard index placeholder values to get only actual matches
                        setMatched = condense(setMatched);
                    }
                    // Add matches to results
                    push.apply(results, setMatched);
                    // Seedless set matches succeeding multiple successful matchers stipulate sorting
                    if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                        Sizzle.uniqueSort(results);
                    }
                }
                // Override manipulation of globals by nested matchers
                if (outermost) {
                    dirruns = dirrunsUnique;
                    outermostContext = contextBackup;
                }
                return unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function(selector, match) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
                // Generate a function of recursive functions that can be used to check each element
                if (!match) {
                    match = tokenize(selector);
                }
                i = match.length;
                while (i--) {
                    cached = matcherFromTokens(match[i]);
                    if (cached[expando]) {
                        setMatchers.push(cached);
                    } else {
                        elementMatchers.push(cached);
                    }
                }
                // Cache the compiled function
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                // Save selector and tokenization
                cached.selector = selector;
            }
            return cached;
        };
        /**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
        select = Sizzle.select = function(selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            results = results || [];
            // Try to minimize operations if there is no seed and only one group
            if (match.length === 1) {
                // Take a shortcut and set the context if the root selector is an ID
                tokens = match[0] = match[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                    context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                    if (!context) {
                        return results;
                    } else if (compiled) {
                        context = context.parentNode;
                    }
                    selector = selector.slice(tokens.shift().value.length);
                }
                // Fetch a seed set for right-to-left matching
                i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                while (i--) {
                    token = tokens[i];
                    // Abort if we hit a combinator
                    if (Expr.relative[type = token.type]) {
                        break;
                    }
                    if (find = Expr.find[type]) {
                        // Search, expanding context for leading sibling combinators
                        if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                            // If seed is empty or no tokens remain, we can return early
                            tokens.splice(i, 1);
                            selector = seed.length && toSelector(tokens);
                            if (!selector) {
                                push.apply(results, seed);
                                return results;
                            }
                            break;
                        }
                    }
                }
            }
            // Compile and execute a filtering function if one is not provided
            // Provide `match` to avoid retokenization if we modified the selector above
            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
            return results;
        };
        // One-time assignments
        // Sort stability
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        // Support: Chrome 14-35+
        // Always assume duplicates if they aren't passed to the comparison function
        support.detectDuplicates = !!hasDuplicate;
        // Initialize against the default document
        setDocument();
        // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
        // Detached nodes confoundingly follow *each other*
        support.sortDetached = assert(function(div1) {
            // Should return 1, but returns 4 (following)
            return div1.compareDocumentPosition(document.createElement("div")) & 1;
        });
        // Support: IE<8
        // Prevent attribute/property "interpolation"
        // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
        if (!assert(function(div) {
            div.innerHTML = "<a href='#'></a>";
            return div.firstChild.getAttribute("href") === "#";
        })) {
            addHandle("type|href|height|width", function(elem, name, isXML) {
                if (!isXML) {
                    return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
                }
            });
        }
        // Support: IE<9
        // Use defaultValue in place of getAttribute("value")
        if (!support.attributes || !assert(function(div) {
            div.innerHTML = "<input/>";
            div.firstChild.setAttribute("value", "");
            return div.firstChild.getAttribute("value") === "";
        })) {
            addHandle("value", function(elem, name, isXML) {
                if (!isXML && elem.nodeName.toLowerCase() === "input") {
                    return elem.defaultValue;
                }
            });
        }
        // Support: IE<9
        // Use getAttributeNode to fetch booleans when getAttribute lies
        if (!assert(function(div) {
            return div.getAttribute("disabled") == null;
        })) {
            addHandle(booleans, function(elem, name, isXML) {
                var val;
                if (!isXML) {
                    return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                }
            });
        }
        return Sizzle;
    }(window);
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    var rneedsContext = jQuery.expr.match.needsContext;
    var rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
    var risSimple = /^.[^:#\[\.,]*$/;
    // Implement the identical functionality for filter and not
    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function(elem, i) {
                /* jshint -W018 */
                return !!qualifier.call(elem, i, elem) !== not;
            });
        }
        if (qualifier.nodeType) {
            return jQuery.grep(elements, function(elem) {
                return elem === qualifier !== not;
            });
        }
        if (typeof qualifier === "string") {
            if (risSimple.test(qualifier)) {
                return jQuery.filter(qualifier, elements, not);
            }
            qualifier = jQuery.filter(qualifier, elements);
        }
        return jQuery.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) >= 0 !== not;
        });
    }
    jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];
        if (not) {
            expr = ":not(" + expr + ")";
        }
        return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [ elem ] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
            return elem.nodeType === 1;
        }));
    };
    jQuery.fn.extend({
        find: function(selector) {
            var i, len = this.length, ret = [], self = this;
            if (typeof selector !== "string") {
                return this.pushStack(jQuery(selector).filter(function() {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                }));
            }
            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }
            // Needed because $( selector, context ) becomes $( context ).find( selector )
            ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
            ret.selector = this.selector ? this.selector + " " + selector : selector;
            return ret;
        },
        filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function(selector) {
            // If this is a positional/relative selector, check membership in the returned set
            // so $("p:first").is("p:last") won't return true for a doc with two "p".
            return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
    });
    // Initialize a jQuery object
    // A central reference to the root jQuery(document)
    var rootjQuery, // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
    // Strict HTML recognition (#11290: must start with <)
    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, init = jQuery.fn.init = function(selector, context) {
        var match, elem;
        // HANDLE: $(""), $(null), $(undefined), $(false)
        if (!selector) {
            return this;
        }
        // Handle HTML strings
        if (typeof selector === "string") {
            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
                // Assume that strings that start and end with <> are HTML and skip the regex check
                match = [ null, selector, null ];
            } else {
                match = rquickExpr.exec(selector);
            }
            // Match html or make sure no context is specified for #id
            if (match && (match[1] || !context)) {
                // HANDLE: $(html) -> $(array)
                if (match[1]) {
                    context = context instanceof jQuery ? context[0] : context;
                    // Option to run scripts is true for back-compat
                    // Intentionally let the error be thrown if parseHTML is not present
                    jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                    // HANDLE: $(html, props)
                    if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                        for (match in context) {
                            // Properties of context are called as methods if possible
                            if (jQuery.isFunction(this[match])) {
                                this[match](context[match]);
                            } else {
                                this.attr(match, context[match]);
                            }
                        }
                    }
                    return this;
                } else {
                    elem = document.getElementById(match[2]);
                    // Support: Blackberry 4.6
                    // gEBID returns nodes no longer in the document (#6963)
                    if (elem && elem.parentNode) {
                        // Inject the element directly into the jQuery object
                        this.length = 1;
                        this[0] = elem;
                    }
                    this.context = document;
                    this.selector = selector;
                    return this;
                }
            } else if (!context || context.jquery) {
                return (context || rootjQuery).find(selector);
            } else {
                return this.constructor(context).find(selector);
            }
        } else if (selector.nodeType) {
            this.context = this[0] = selector;
            this.length = 1;
            return this;
        } else if (jQuery.isFunction(selector)) {
            // Execute immediately if ready is not present
            return typeof rootjQuery.ready !== "undefined" ? rootjQuery.ready(selector) : selector(jQuery);
        }
        if (selector.selector !== undefined) {
            this.selector = selector.selector;
            this.context = selector.context;
        }
        return jQuery.makeArray(selector, this);
    };
    // Give the init function the jQuery prototype for later instantiation
    init.prototype = jQuery.fn;
    // Initialize central reference
    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, // Methods guaranteed to produce a unique set when starting from a unique set
    guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
    };
    jQuery.extend({
        dir: function(elem, dir, until) {
            var matched = [], truncate = until !== undefined;
            while ((elem = elem[dir]) && elem.nodeType !== 9) {
                if (elem.nodeType === 1) {
                    if (truncate && jQuery(elem).is(until)) {
                        break;
                    }
                    matched.push(elem);
                }
            }
            return matched;
        },
        sibling: function(n, elem) {
            var matched = [];
            for (;n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    matched.push(n);
                }
            }
            return matched;
        }
    });
    jQuery.fn.extend({
        has: function(target) {
            var targets = jQuery(target, this), l = targets.length;
            return this.filter(function() {
                var i = 0;
                for (;i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },
        closest: function(selectors, context) {
            var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;
            for (;i < l; i++) {
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                    // Always skip document fragments
                    if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : // Don't pass non-elements to Sizzle
                    cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                        matched.push(cur);
                        break;
                    }
                }
            }
            return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
        },
        // Determine the position of an element within the set
        index: function(elem) {
            // No argument, return index in parent
            if (!elem) {
                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            // Index in selector
            if (typeof elem === "string") {
                return indexOf.call(jQuery(elem), this[0]);
            }
            // Locate the position of the desired element
            // If it receives a jQuery object, the first element is used
            return indexOf.call(this, elem.jquery ? elem[0] : elem);
        },
        add: function(selector, context) {
            return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function(selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });
    function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) {}
        return cur;
    }
    jQuery.each({
        parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
            return jQuery.dir(elem, "parentNode");
        },
        parentsUntil: function(elem, i, until) {
            return jQuery.dir(elem, "parentNode", until);
        },
        next: function(elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
            return jQuery.dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
            return jQuery.dir(elem, "previousSibling");
        },
        nextUntil: function(elem, i, until) {
            return jQuery.dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, i, until) {
            return jQuery.dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
            return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
            return jQuery.sibling(elem.firstChild);
        },
        contents: function(elem) {
            return elem.contentDocument || jQuery.merge([], elem.childNodes);
        }
    }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
            var matched = jQuery.map(this, fn, until);
            if (name.slice(-5) !== "Until") {
                selector = until;
            }
            if (selector && typeof selector === "string") {
                matched = jQuery.filter(selector, matched);
            }
            if (this.length > 1) {
                // Remove duplicates
                if (!guaranteedUnique[name]) {
                    jQuery.unique(matched);
                }
                // Reverse order for parents* and prev-derivatives
                if (rparentsprev.test(name)) {
                    matched.reverse();
                }
            }
            return this.pushStack(matched);
        };
    });
    var rnotwhite = /\S+/g;
    // String to Object options format cache
    var optionsCache = {};
    // Convert String-formatted options into Object-formatted ones and store in cache
    function createOptions(options) {
        var object = optionsCache[options] = {};
        jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
            object[flag] = true;
        });
        return object;
    }
    /*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
    jQuery.Callbacks = function(options) {
        // Convert options from String-formatted to Object-formatted if needed
        // (we check in cache first)
        options = typeof options === "string" ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
        var // Last fire value (for non-forgettable lists)
        memory, // Flag to know if list was already fired
        fired, // Flag to know if list is currently firing
        firing, // First callback to fire (used internally by add and fireWith)
        firingStart, // End of the loop when firing
        firingLength, // Index of currently firing callback (modified by remove if needed)
        firingIndex, // Actual callback list
        list = [], // Stack of fire calls for repeatable lists
        stack = !options.once && [], // Fire callbacks
        fire = function(data) {
            memory = options.memory && data;
            fired = true;
            firingIndex = firingStart || 0;
            firingStart = 0;
            firingLength = list.length;
            firing = true;
            for (;list && firingIndex < firingLength; firingIndex++) {
                if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                    memory = false;
                    // To prevent further calls using add
                    break;
                }
            }
            firing = false;
            if (list) {
                if (stack) {
                    if (stack.length) {
                        fire(stack.shift());
                    }
                } else if (memory) {
                    list = [];
                } else {
                    self.disable();
                }
            }
        }, // Actual Callbacks object
        self = {
            // Add a callback or a collection of callbacks to the list
            add: function() {
                if (list) {
                    // First, we save the current length
                    var start = list.length;
                    (function add(args) {
                        jQuery.each(args, function(_, arg) {
                            var type = jQuery.type(arg);
                            if (type === "function") {
                                if (!options.unique || !self.has(arg)) {
                                    list.push(arg);
                                }
                            } else if (arg && arg.length && type !== "string") {
                                // Inspect recursively
                                add(arg);
                            }
                        });
                    })(arguments);
                    // Do we need to add the callbacks to the
                    // current firing batch?
                    if (firing) {
                        firingLength = list.length;
                    } else if (memory) {
                        firingStart = start;
                        fire(memory);
                    }
                }
                return this;
            },
            // Remove a callback from the list
            remove: function() {
                if (list) {
                    jQuery.each(arguments, function(_, arg) {
                        var index;
                        while ((index = jQuery.inArray(arg, list, index)) > -1) {
                            list.splice(index, 1);
                            // Handle firing indexes
                            if (firing) {
                                if (index <= firingLength) {
                                    firingLength--;
                                }
                                if (index <= firingIndex) {
                                    firingIndex--;
                                }
                            }
                        }
                    });
                }
                return this;
            },
            // Check if a given callback is in the list.
            // If no argument is given, return whether or not list has callbacks attached.
            has: function(fn) {
                return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
            },
            // Remove all callbacks from the list
            empty: function() {
                list = [];
                firingLength = 0;
                return this;
            },
            // Have the list do nothing anymore
            disable: function() {
                list = stack = memory = undefined;
                return this;
            },
            // Is it disabled?
            disabled: function() {
                return !list;
            },
            // Lock the list in its current state
            lock: function() {
                stack = undefined;
                if (!memory) {
                    self.disable();
                }
                return this;
            },
            // Is it locked?
            locked: function() {
                return !stack;
            },
            // Call all callbacks with the given context and arguments
            fireWith: function(context, args) {
                if (list && (!fired || stack)) {
                    args = args || [];
                    args = [ context, args.slice ? args.slice() : args ];
                    if (firing) {
                        stack.push(args);
                    } else {
                        fire(args);
                    }
                }
                return this;
            },
            // Call all the callbacks with the given arguments
            fire: function() {
                self.fireWith(this, arguments);
                return this;
            },
            // To know if the callbacks have already been called at least once
            fired: function() {
                return !!fired;
            }
        };
        return self;
    };
    jQuery.extend({
        Deferred: function(func) {
            var tuples = [ // action, add listener, listener list, final state
            [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ], [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ], [ "notify", "progress", jQuery.Callbacks("memory") ] ], state = "pending", promise = {
                state: function() {
                    return state;
                },
                always: function() {
                    deferred.done(arguments).fail(arguments);
                    return this;
                },
                then: function() {
                    var fns = arguments;
                    return jQuery.Deferred(function(newDefer) {
                        jQuery.each(tuples, function(i, tuple) {
                            var fn = jQuery.isFunction(fns[i]) && fns[i];
                            // deferred[ done | fail | progress ] for forwarding actions to newDefer
                            deferred[tuple[1]](function() {
                                var returned = fn && fn.apply(this, arguments);
                                if (returned && jQuery.isFunction(returned.promise)) {
                                    returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                                } else {
                                    newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments);
                                }
                            });
                        });
                        fns = null;
                    }).promise();
                },
                // Get a promise for this deferred
                // If obj is provided, the promise aspect is added to the object
                promise: function(obj) {
                    return obj != null ? jQuery.extend(obj, promise) : promise;
                }
            }, deferred = {};
            // Keep pipe for back-compat
            promise.pipe = promise.then;
            // Add list-specific methods
            jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2], stateString = tuple[3];
                // promise[ done | fail | progress ] = list.add
                promise[tuple[1]] = list.add;
                // Handle state
                if (stateString) {
                    list.add(function() {
                        // state = [ resolved | rejected ]
                        state = stateString;
                    }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                }
                // deferred[ resolve | reject | notify ]
                deferred[tuple[0]] = function() {
                    deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
                    return this;
                };
                deferred[tuple[0] + "With"] = list.fireWith;
            });
            // Make the deferred a promise
            promise.promise(deferred);
            // Call given func if any
            if (func) {
                func.call(deferred, deferred);
            }
            // All done!
            return deferred;
        },
        // Deferred helper
        when: function(subordinate) {
            var i = 0, resolveValues = slice.call(arguments), length = resolveValues.length, // the count of uncompleted subordinates
            remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
            deferred = remaining === 1 ? subordinate : jQuery.Deferred(), // Update function for both resolve and progress values
            updateFunc = function(i, contexts, values) {
                return function(value) {
                    contexts[i] = this;
                    values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                    if (values === progressValues) {
                        deferred.notifyWith(contexts, values);
                    } else if (!--remaining) {
                        deferred.resolveWith(contexts, values);
                    }
                };
            }, progressValues, progressContexts, resolveContexts;
            // Add listeners to Deferred subordinates; treat others as resolved
            if (length > 1) {
                progressValues = new Array(length);
                progressContexts = new Array(length);
                resolveContexts = new Array(length);
                for (;i < length; i++) {
                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                        resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
                    } else {
                        --remaining;
                    }
                }
            }
            // If we're not waiting on anything, resolve the master
            if (!remaining) {
                deferred.resolveWith(resolveContexts, resolveValues);
            }
            return deferred.promise();
        }
    });
    // The deferred used on DOM ready
    var readyList;
    jQuery.fn.ready = function(fn) {
        // Add the callback
        jQuery.ready.promise().done(fn);
        return this;
    };
    jQuery.extend({
        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,
        // A counter to track how many items to wait for before
        // the ready event fires. See #6781
        readyWait: 1,
        // Hold (or release) the ready event
        holdReady: function(hold) {
            if (hold) {
                jQuery.readyWait++;
            } else {
                jQuery.ready(true);
            }
        },
        // Handle when the DOM is ready
        ready: function(wait) {
            // Abort if there are pending holds or we're already ready
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }
            // Remember that the DOM is ready
            jQuery.isReady = true;
            // If a normal DOM Ready event fired, decrement, and wait if need be
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }
            // If there are functions bound, to execute
            readyList.resolveWith(document, [ jQuery ]);
            // Trigger any bound ready events
            if (jQuery.fn.triggerHandler) {
                jQuery(document).triggerHandler("ready");
                jQuery(document).off("ready");
            }
        }
    });
    /**
 * The ready event handler and self cleanup method
 */
    function completed() {
        document.removeEventListener("DOMContentLoaded", completed, false);
        window.removeEventListener("load", completed, false);
        jQuery.ready();
    }
    jQuery.ready.promise = function(obj) {
        if (!readyList) {
            readyList = jQuery.Deferred();
            // Catch cases where $(document).ready() is called after the browser event has already occurred.
            // We once tried to use readyState "interactive" here, but it caused issues like the one
            // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
            if (document.readyState === "complete") {
                // Handle it asynchronously to allow scripts the opportunity to delay ready
                setTimeout(jQuery.ready);
            } else {
                // Use the handy event callback
                document.addEventListener("DOMContentLoaded", completed, false);
                // A fallback to window.onload, that will always work
                window.addEventListener("load", completed, false);
            }
        }
        return readyList.promise(obj);
    };
    // Kick off the DOM ready check even if the user does not
    jQuery.ready.promise();
    // Multifunctional method to get and set values of a collection
    // The value/s can optionally be executed if it's a function
    var access = jQuery.access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = key == null;
        // Sets many values
        if (jQuery.type(key) === "object") {
            chainable = true;
            for (i in key) {
                jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
            }
        } else if (value !== undefined) {
            chainable = true;
            if (!jQuery.isFunction(value)) {
                raw = true;
            }
            if (bulk) {
                // Bulk operations run against the entire set
                if (raw) {
                    fn.call(elems, value);
                    fn = null;
                } else {
                    bulk = fn;
                    fn = function(elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }
            if (fn) {
                for (;i < len; i++) {
                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                }
            }
        }
        // Gets
        return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
    };
    /**
 * Determines whether an object can have data
 */
    jQuery.acceptData = function(owner) {
        // Accepts only:
        //  - Node
        //    - Node.ELEMENT_NODE
        //    - Node.DOCUMENT_NODE
        //  - Object
        //    - Any
        /* jshint -W018 */
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };
    function Data() {
        // Support: Android<4,
        // Old WebKit does not have Object.preventExtensions/freeze method,
        // return new empty object instead with no [[set]] accessor
        Object.defineProperty(this.cache = {}, 0, {
            get: function() {
                return {};
            }
        });
        this.expando = jQuery.expando + Data.uid++;
    }
    Data.uid = 1;
    Data.accepts = jQuery.acceptData;
    Data.prototype = {
        key: function(owner) {
            // We can accept data for non-element nodes in modern browsers,
            // but we should not, see #8335.
            // Always return the key for a frozen object.
            if (!Data.accepts(owner)) {
                return 0;
            }
            var descriptor = {}, // Check if the owner object already has a cache key
            unlock = owner[this.expando];
            // If not, create one
            if (!unlock) {
                unlock = Data.uid++;
                // Secure it in a non-enumerable, non-writable property
                try {
                    descriptor[this.expando] = {
                        value: unlock
                    };
                    Object.defineProperties(owner, descriptor);
                } catch (e) {
                    descriptor[this.expando] = unlock;
                    jQuery.extend(owner, descriptor);
                }
            }
            // Ensure the cache object
            if (!this.cache[unlock]) {
                this.cache[unlock] = {};
            }
            return unlock;
        },
        set: function(owner, data, value) {
            var prop, // There may be an unlock assigned to this node,
            // if there is no entry for this "owner", create one inline
            // and set the unlock as though an owner entry had always existed
            unlock = this.key(owner), cache = this.cache[unlock];
            // Handle: [ owner, key, value ] args
            if (typeof data === "string") {
                cache[data] = value;
            } else {
                // Fresh assignments by object are shallow copied
                if (jQuery.isEmptyObject(cache)) {
                    jQuery.extend(this.cache[unlock], data);
                } else {
                    for (prop in data) {
                        cache[prop] = data[prop];
                    }
                }
            }
            return cache;
        },
        get: function(owner, key) {
            // Either a valid cache is found, or will be created.
            // New caches will be created and the unlock returned,
            // allowing direct access to the newly created
            // empty data object. A valid owner object must be provided.
            var cache = this.cache[this.key(owner)];
            return key === undefined ? cache : cache[key];
        },
        access: function(owner, key, value) {
            var stored;
            // In cases where either:
            //
            //   1. No key was specified
            //   2. A string key was specified, but no value provided
            //
            // Take the "read" path and allow the get method to determine
            // which value to return, respectively either:
            //
            //   1. The entire cache object
            //   2. The data stored at the key
            //
            if (key === undefined || key && typeof key === "string" && value === undefined) {
                stored = this.get(owner, key);
                return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
            }
            // [*]When the key is not a string, or both a key and value
            // are specified, set or extend (existing objects) with either:
            //
            //   1. An object of properties
            //   2. A key and value
            //
            this.set(owner, key, value);
            // Since the "set" path can have two possible entry points
            // return the expected data based on which path was taken[*]
            return value !== undefined ? value : key;
        },
        remove: function(owner, key) {
            var i, name, camel, unlock = this.key(owner), cache = this.cache[unlock];
            if (key === undefined) {
                this.cache[unlock] = {};
            } else {
                // Support array or space separated string of keys
                if (jQuery.isArray(key)) {
                    // If "name" is an array of keys...
                    // When data is initially created, via ("key", "val") signature,
                    // keys will be converted to camelCase.
                    // Since there is no way to tell _how_ a key was added, remove
                    // both plain key and camelCase key. #12786
                    // This will only penalize the array argument path.
                    name = key.concat(key.map(jQuery.camelCase));
                } else {
                    camel = jQuery.camelCase(key);
                    // Try the string as a key before any manipulation
                    if (key in cache) {
                        name = [ key, camel ];
                    } else {
                        // If a key with the spaces exists, use it.
                        // Otherwise, create an array by matching non-whitespace
                        name = camel;
                        name = name in cache ? [ name ] : name.match(rnotwhite) || [];
                    }
                }
                i = name.length;
                while (i--) {
                    delete cache[name[i]];
                }
            }
        },
        hasData: function(owner) {
            return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
        },
        discard: function(owner) {
            if (owner[this.expando]) {
                delete this.cache[owner[this.expando]];
            }
        }
    };
    var data_priv = new Data();
    var data_user = new Data();
    //	Implementation Summary
    //
    //	1. Enforce API surface and semantic compatibility with 1.9.x branch
    //	2. Improve the module's maintainability by reducing the storage
    //		paths to a single mechanism.
    //	3. Use the same single mechanism to support "private" and "user" data.
    //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
    //	5. Avoid exposing implementation details on user objects (eg. expando properties)
    //	6. Provide a clear path for implementation upgrade to WeakMap in 2014
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /([A-Z])/g;
    function dataAttr(elem, key, data) {
        var name;
        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if (data === undefined && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === "string") {
                try {
                    data = data === "true" ? true : data === "false" ? false : data === "null" ? null : // Only convert to a number if it doesn't change the string
                    +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
                } catch (e) {}
                // Make sure we set the data so it isn't changed later
                data_user.set(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }
    jQuery.extend({
        hasData: function(elem) {
            return data_user.hasData(elem) || data_priv.hasData(elem);
        },
        data: function(elem, name, data) {
            return data_user.access(elem, name, data);
        },
        removeData: function(elem, name) {
            data_user.remove(elem, name);
        },
        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to data_priv methods, these can be deprecated.
        _data: function(elem, name, data) {
            return data_priv.access(elem, name, data);
        },
        _removeData: function(elem, name) {
            data_priv.remove(elem, name);
        }
    });
    jQuery.fn.extend({
        data: function(key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            // Gets all values
            if (key === undefined) {
                if (this.length) {
                    data = data_user.get(elem);
                    if (elem.nodeType === 1 && !data_priv.get(elem, "hasDataAttrs")) {
                        i = attrs.length;
                        while (i--) {
                            // Support: IE11+
                            // The attrs elements can be null (#14894)
                            if (attrs[i]) {
                                name = attrs[i].name;
                                if (name.indexOf("data-") === 0) {
                                    name = jQuery.camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name]);
                                }
                            }
                        }
                        data_priv.set(elem, "hasDataAttrs", true);
                    }
                }
                return data;
            }
            // Sets multiple values
            if (typeof key === "object") {
                return this.each(function() {
                    data_user.set(this, key);
                });
            }
            return access(this, function(value) {
                var data, camelKey = jQuery.camelCase(key);
                // The calling jQuery object (element matches) is not empty
                // (and therefore has an element appears at this[ 0 ]) and the
                // `value` parameter was not undefined. An empty jQuery object
                // will result in `undefined` for elem = this[ 0 ] which will
                // throw an exception if an attempt to read a data cache is made.
                if (elem && value === undefined) {
                    // Attempt to get data from the cache
                    // with the key as-is
                    data = data_user.get(elem, key);
                    if (data !== undefined) {
                        return data;
                    }
                    // Attempt to get data from the cache
                    // with the key camelized
                    data = data_user.get(elem, camelKey);
                    if (data !== undefined) {
                        return data;
                    }
                    // Attempt to "discover" the data in
                    // HTML5 custom data-* attrs
                    data = dataAttr(elem, camelKey, undefined);
                    if (data !== undefined) {
                        return data;
                    }
                    // We tried really hard, but the data doesn't exist.
                    return;
                }
                // Set the data...
                this.each(function() {
                    // First, attempt to store a copy or reference of any
                    // data that might've been store with a camelCased key.
                    var data = data_user.get(this, camelKey);
                    // For HTML5 data-* attribute interop, we have to
                    // store property names with dashes in a camelCase form.
                    // This might not apply to all properties...*
                    data_user.set(this, camelKey, value);
                    // *... In the case of properties that might _actually_
                    // have dashes, we need to also store a copy of that
                    // unchanged property.
                    if (key.indexOf("-") !== -1 && data !== undefined) {
                        data_user.set(this, key, value);
                    }
                });
            }, null, value, arguments.length > 1, null, true);
        },
        removeData: function(key) {
            return this.each(function() {
                data_user.remove(this, key);
            });
        }
    });
    jQuery.extend({
        queue: function(elem, type, data) {
            var queue;
            if (elem) {
                type = (type || "fx") + "queue";
                queue = data_priv.get(elem, type);
                // Speed up dequeue by getting out quickly if this is just a lookup
                if (data) {
                    if (!queue || jQuery.isArray(data)) {
                        queue = data_priv.access(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },
        dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
                jQuery.dequeue(elem, type);
            };
            // If the fx queue is dequeued, always remove the progress sentinel
            if (fn === "inprogress") {
                fn = queue.shift();
                startLength--;
            }
            if (fn) {
                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if (type === "fx") {
                    queue.unshift("inprogress");
                }
                // Clear up the last queue stop function
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },
        // Not public - generate a queueHooks object, or return the current one
        _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return data_priv.get(elem, key) || data_priv.access(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                    data_priv.remove(elem, [ type + "queue", key ]);
                })
            });
        }
    });
    jQuery.fn.extend({
        queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--;
            }
            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }
            return data === undefined ? this : this.each(function() {
                var queue = jQuery.queue(this, type, data);
                // Ensure a hooks for this queue
                jQuery._queueHooks(this, type);
                if (type === "fx" && queue[0] !== "inprogress") {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function(type) {
            return this.each(function() {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function(type) {
            return this.queue(type || "fx", []);
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
                if (!--count) {
                    defer.resolveWith(elements, [ elements ]);
                }
            };
            if (typeof type !== "string") {
                obj = type;
                type = undefined;
            }
            type = type || "fx";
            while (i--) {
                tmp = data_priv.get(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
    var isHidden = function(elem, el) {
        // isHidden might be called from jQuery#filter function;
        // in that case, element will be second argument
        elem = el || elem;
        return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
    };
    var rcheckableType = /^(?:checkbox|radio)$/i;
    (function() {
        var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement("div")), input = document.createElement("input");
        // Support: Safari<=5.1
        // Check state lost if the name is set (#11217)
        // Support: Windows Web Apps (WWA)
        // `name` and `type` must use .setAttribute for WWA (#14901)
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input);
        // Support: Safari<=5.1, Android<4.2
        // Older WebKit doesn't clone checked state correctly in fragments
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        // Support: IE<=11+
        // Make sure textarea (and checkbox) defaultValue is properly cloned
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
    })();
    var strundefined = typeof undefined;
    support.focusinBubbles = "onfocusin" in window;
    var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
    function returnTrue() {
        return true;
    }
    function returnFalse() {
        return false;
    }
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {}
    }
    /*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
    jQuery.event = {
        global: {},
        add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.get(elem);
            // Don't attach events to noData or text/comment nodes (but allow plain objects)
            if (!elemData) {
                return;
            }
            // Caller can pass in an object of custom data in lieu of the handler
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }
            // Make sure that the handler has a unique ID, used to find/remove it later
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }
            // Init the element's event structure and main handler, if this is the first
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function(e) {
                    // Discard the second event of a jQuery.event.trigger() and
                    // when an event is called after a page has unloaded
                    return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
                };
            }
            // Handle multiple events separated by a space
            types = (types || "").match(rnotwhite) || [ "" ];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                // There *must* be a type, no attaching namespace-only handlers
                if (!type) {
                    continue;
                }
                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[type] || {};
                // If selector defined, determine special event api type, otherwise given type
                type = (selector ? special.delegateType : special.bindType) || type;
                // Update special based on newly reset type
                special = jQuery.event.special[type] || {};
                // handleObj is passed to all event handlers
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn);
                // Init the event handler queue if we're the first
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;
                    // Only use addEventListener if the special events handler returns false
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle, false);
                        }
                    }
                }
                if (special.add) {
                    special.add.call(elem, handleObj);
                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }
                // Add to the element's handler list, delegates in front
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }
                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[type] = true;
            }
        },
        // Detach an event or set of events from an element
        remove: function(elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.hasData(elem) && data_priv.get(elem);
            if (!elemData || !(events = elemData.events)) {
                return;
            }
            // Once for each type.namespace in types; type may be omitted
            types = (types || "").match(rnotwhite) || [ "" ];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                // Unbind all events (on this namespace, if provided) for the element
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
                // Remove matching events
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                        handlers.splice(j, 1);
                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }
                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }
                    delete events[type];
                }
            }
            // Remove the expando if it's no longer used
            if (jQuery.isEmptyObject(events)) {
                delete elemData.handle;
                data_priv.remove(elem, "events");
            }
        },
        trigger: function(event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [ elem || document ], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            cur = tmp = elem = elem || document;
            // Don't do events on text and comment nodes
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }
            // focus/blur morphs to focusin/out; ensure we're not firing them right now
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }
            if (type.indexOf(".") >= 0) {
                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            // Caller can pass in a jQuery.Event object, Object, or just an event type string
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            // Clean up the event in case it is being reused
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }
            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data == null ? [ event ] : jQuery.makeArray(data, [ event ]);
            // Allow special events to draw outside the lines
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }
            // Determine event propagation path in advance, per W3C events spec (#9951)
            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (;cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }
                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }
            // Fire handlers on the event path
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                event.type = i > 1 ? bubbleType : special.bindType || type;
                // jQuery handler
                handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle");
                if (handle) {
                    handle.apply(cur, data);
                }
                // Native handler
                handle = ontype && cur[ontype];
                if (handle && handle.apply && jQuery.acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;
            // If nobody prevented the default action, do it now
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
                    // Call a native DOM method on the target with the same name name as the event.
                    // Don't do default actions on window, that's where global variables be (#6170)
                    if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
                        // Don't re-trigger an onFOO event when we call its FOO() method
                        tmp = elem[ontype];
                        if (tmp) {
                            elem[ontype] = null;
                        }
                        // Prevent re-triggering of the same event, since we already bubbled it above
                        jQuery.event.triggered = type;
                        elem[type]();
                        jQuery.event.triggered = undefined;
                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }
            return event.result;
        },
        dispatch: function(event) {
            // Make a writable jQuery.Event from the native event object
            event = jQuery.event.fix(event);
            var i, j, ret, matched, handleObj, handlerQueue = [], args = slice.call(arguments), handlers = (data_priv.get(this, "events") || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
            // Use the fix-ed jQuery.Event rather than the (read-only) native event
            args[0] = event;
            event.delegateTarget = this;
            // Call the preDispatch hook for the mapped type, and let it bail if desired
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }
            // Determine handlers
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            // Run delegates first; they may want to stop propagation beneath us
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;
                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                    // Triggered event must either 1) have no namespace, or 2) have namespace(s)
                    // a subset or equal to those in the bound event (both can have no namespace).
                    if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
                        event.handleObj = handleObj;
                        event.data = handleObj.data;
                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }
            // Call the postDispatch hook for the mapped type
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }
            return event.result;
        },
        handlers: function(event, handlers) {
            var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            // Find delegate handlers
            // Black-hole SVG <use> instance trees (#13180)
            // Avoid non-left-click bubbling in Firefox (#3861)
            if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {
                for (;cur !== this; cur = cur.parentNode || this) {
                    // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                    if (cur.disabled !== true || event.type !== "click") {
                        matches = [];
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];
                            // Don't conflict with Object.prototype properties (#13203)
                            sel = handleObj.selector + " ";
                            if (matches[sel] === undefined) {
                                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [ cur ]).length;
                            }
                            if (matches[sel]) {
                                matches.push(handleObj);
                            }
                        }
                        if (matches.length) {
                            handlerQueue.push({
                                elem: cur,
                                handlers: matches
                            });
                        }
                    }
                }
            }
            // Add the remaining (directly-bound) handlers
            if (delegateCount < handlers.length) {
                handlerQueue.push({
                    elem: this,
                    handlers: handlers.slice(delegateCount)
                });
            }
            return handlerQueue;
        },
        // Includes some event props shared by KeyEvent and MouseEvent
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(event, original) {
                // Add which for key events
                if (event.which == null) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }
                return event;
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function(event, original) {
                var eventDoc, doc, body, button = original.button;
                // Calculate pageX/Y if missing and clientX/Y available
                if (event.pageX == null && original.clientX != null) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;
                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                    event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                }
                // Add which for click: 1 === left; 2 === middle; 3 === right
                // Note: button is not normalized, so don't use it
                if (!event.which && button !== undefined) {
                    event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
                }
                return event;
            }
        },
        fix: function(event) {
            if (event[jQuery.expando]) {
                return event;
            }
            // Create a writable copy of the event object and normalize some properties
            var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
            if (!fixHook) {
                this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
            }
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
            event = new jQuery.Event(originalEvent);
            i = copy.length;
            while (i--) {
                prop = copy[i];
                event[prop] = originalEvent[prop];
            }
            // Support: Cordova 2.5 (WebKit) (#13255)
            // All events should have a target; Cordova deviceready doesn't
            if (!event.target) {
                event.target = document;
            }
            // Support: Safari 6.0+, Chrome<28
            // Target should not be a text node (#504, #13143)
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }
            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },
        special: {
            load: {
                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
            },
            focus: {
                // Fire native event if possible so blur/focus sequence is correct
                trigger: function() {
                    if (this !== safeActiveElement() && this.focus) {
                        this.focus();
                        return false;
                    }
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: "focusout"
            },
            click: {
                // For checkbox, fire native event so checked state will be right
                trigger: function() {
                    if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
                        this.click();
                        return false;
                    }
                },
                // For cross-browser consistency, don't fire native .click() on links
                _default: function(event) {
                    return jQuery.nodeName(event.target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(event) {
                    // Support: Firefox 20+
                    // Firefox doesn't alert if the returnValue field is not set.
                    if (event.result !== undefined && event.originalEvent) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        },
        simulate: function(type, elem, event, bubble) {
            // Piggyback on a donor event to simulate a different one.
            // Fake originalEvent to avoid donor's stopPropagation, but if the
            // simulated event prevents default then we do the same on the donor.
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true,
                originalEvent: {}
            });
            if (bubble) {
                jQuery.event.trigger(e, null, elem);
            } else {
                jQuery.event.dispatch.call(elem, e);
            }
            if (e.isDefaultPrevented()) {
                event.preventDefault();
            }
        }
    };
    jQuery.removeEvent = function(elem, type, handle) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle, false);
        }
    };
    jQuery.Event = function(src, props) {
        // Allow instantiation without the 'new' keyword
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }
        // Event object
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android<4.0
            src.returnValue === false ? returnTrue : returnFalse;
        } else {
            this.type = src;
        }
        // Put explicitly provided properties onto the event object
        if (props) {
            jQuery.extend(this, props);
        }
        // Create a timestamp if incoming event doesn't have one
        this.timeStamp = src && src.timeStamp || jQuery.now();
        // Mark it as fixed
        this[jQuery.expando] = true;
    };
    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e && e.preventDefault) {
                e.preventDefault();
            }
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e && e.stopPropagation) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e && e.stopImmediatePropagation) {
                e.stopImmediatePropagation();
            }
            this.stopPropagation();
        }
    };
    // Create mouseenter/leave events using mouseover/out and event-time checks
    // Support: Chrome 15+
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                // For mousenter/leave call the handler if related is outside the target.
                // NB: No relatedTarget if the mouse left/entered the browser window
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });
    // Support: Firefox, Chrome, Safari
    // Create "bubbling" focus and blur events
    if (!support.focusinBubbles) {
        jQuery.each({
            focus: "focusin",
            blur: "focusout"
        }, function(orig, fix) {
            // Attach a single capturing handler on the document while someone wants focusin/focusout
            var handler = function(event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
            };
            jQuery.event.special[fix] = {
                setup: function() {
                    var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix);
                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    data_priv.access(doc, fix, (attaches || 0) + 1);
                },
                teardown: function() {
                    var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix) - 1;
                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        data_priv.remove(doc, fix);
                    } else {
                        data_priv.access(doc, fix, attaches);
                    }
                }
            };
        });
    }
    jQuery.fn.extend({
        on: function(types, selector, data, fn, /*INTERNAL*/ one) {
            var origFn, type;
            // Types can be a map of types/handlers
            if (typeof types === "object") {
                // ( types-Object, selector, data )
                if (typeof selector !== "string") {
                    // ( types-Object, data )
                    data = data || selector;
                    selector = undefined;
                }
                for (type in types) {
                    this.on(type, selector, data, types[type], one);
                }
                return this;
            }
            if (data == null && fn == null) {
                // ( types, fn )
                fn = selector;
                data = selector = undefined;
            } else if (fn == null) {
                if (typeof selector === "string") {
                    // ( types, selector, fn )
                    fn = data;
                    data = undefined;
                } else {
                    // ( types, data, fn )
                    fn = data;
                    data = selector;
                    selector = undefined;
                }
            }
            if (fn === false) {
                fn = returnFalse;
            } else if (!fn) {
                return this;
            }
            if (one === 1) {
                origFn = fn;
                fn = function(event) {
                    // Can use an empty set, since event contains the info
                    jQuery().off(event);
                    return origFn.apply(this, arguments);
                };
                // Use same guid so caller can remove using origFn
                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
            }
            return this.each(function() {
                jQuery.event.add(this, types, fn, data, selector);
            });
        },
        one: function(types, selector, data, fn) {
            return this.on(types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                // ( event )  dispatched jQuery.Event
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if (typeof types === "object") {
                // ( types-object [, selector] )
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === "function") {
                // ( types [, fn] )
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function() {
                jQuery.event.remove(this, types, fn, selector);
            });
        },
        trigger: function(type, data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        }
    });
    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, // checked="checked" or checked
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, // We have to close these tags to support XHTML (#13200)
    wrapMap = {
        // Support: IE9
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    // Support: IE9
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    // Support: 1.x compatibility
    // Manipulating tables requires a tbody
    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
    }
    // Replace/restore the type attribute of script elements for safe DOM manipulation
    function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
    }
    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        if (match) {
            elem.type = match[1];
        } else {
            elem.removeAttribute("type");
        }
        return elem;
    }
    // Mark scripts as having already been evaluated
    function setGlobalEval(elems, refElements) {
        var i = 0, l = elems.length;
        for (;i < l; i++) {
            data_priv.set(elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval"));
        }
    }
    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
        if (dest.nodeType !== 1) {
            return;
        }
        // 1. Copy private data: events, handlers, etc.
        if (data_priv.hasData(src)) {
            pdataOld = data_priv.access(src);
            pdataCur = data_priv.set(dest, pdataOld);
            events = pdataOld.events;
            if (events) {
                delete pdataCur.handle;
                pdataCur.events = {};
                for (type in events) {
                    for (i = 0, l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type, events[type][i]);
                    }
                }
            }
        }
        // 2. Copy user data
        if (data_user.hasData(src)) {
            udataOld = data_user.access(src);
            udataCur = jQuery.extend({}, udataOld);
            data_user.set(dest, udataCur);
        }
    }
    function getAll(context, tag) {
        var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : context.querySelectorAll ? context.querySelectorAll(tag || "*") : [];
        return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([ context ], ret) : ret;
    }
    // Fix IE bugs, see support tests
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        // Fails to persist the checked state of a cloned checkbox or radio button.
        if (nodeName === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
        } else if (nodeName === "input" || nodeName === "textarea") {
            dest.defaultValue = src.defaultValue;
        }
    }
    jQuery.extend({
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
            // Fix IE cloning issues
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
                destElements = getAll(clone);
                srcElements = getAll(elem);
                for (i = 0, l = srcElements.length; i < l; i++) {
                    fixInput(srcElements[i], destElements[i]);
                }
            }
            // Copy the events from the original to the clone
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);
                    for (i = 0, l = srcElements.length; i < l; i++) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }
            // Preserve script evaluation history
            destElements = getAll(clone, "script");
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }
            // Return the cloned set
            return clone;
        },
        buildFragment: function(elems, context, scripts, selection) {
            var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
            for (;i < l; i++) {
                elem = elems[i];
                if (elem || elem === 0) {
                    // Add nodes directly
                    if (jQuery.type(elem) === "object") {
                        // Support: QtWebKit, PhantomJS
                        // push.apply(_, arraylike) throws on ancient WebKit
                        jQuery.merge(nodes, elem.nodeType ? [ elem ] : elem);
                    } else if (!rhtml.test(elem)) {
                        nodes.push(context.createTextNode(elem));
                    } else {
                        tmp = tmp || fragment.appendChild(context.createElement("div"));
                        // Deserialize a standard representation
                        tag = (rtagName.exec(elem) || [ "", "" ])[1].toLowerCase();
                        wrap = wrapMap[tag] || wrapMap._default;
                        tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];
                        // Descend through wrappers to the right content
                        j = wrap[0];
                        while (j--) {
                            tmp = tmp.lastChild;
                        }
                        // Support: QtWebKit, PhantomJS
                        // push.apply(_, arraylike) throws on ancient WebKit
                        jQuery.merge(nodes, tmp.childNodes);
                        // Remember the top-level container
                        tmp = fragment.firstChild;
                        // Ensure the created nodes are orphaned (#12392)
                        tmp.textContent = "";
                    }
                }
            }
            // Remove wrapper from fragment
            fragment.textContent = "";
            i = 0;
            while (elem = nodes[i++]) {
                // #4087 - If origin and destination elements are the same, and this is
                // that element, do not do anything
                if (selection && jQuery.inArray(elem, selection) !== -1) {
                    continue;
                }
                contains = jQuery.contains(elem.ownerDocument, elem);
                // Append to fragment
                tmp = getAll(fragment.appendChild(elem), "script");
                // Preserve script evaluation history
                if (contains) {
                    setGlobalEval(tmp);
                }
                // Capture executables
                if (scripts) {
                    j = 0;
                    while (elem = tmp[j++]) {
                        if (rscriptType.test(elem.type || "")) {
                            scripts.push(elem);
                        }
                    }
                }
            }
            return fragment;
        },
        cleanData: function(elems) {
            var data, elem, type, key, special = jQuery.event.special, i = 0;
            for (;(elem = elems[i]) !== undefined; i++) {
                if (jQuery.acceptData(elem)) {
                    key = elem[data_priv.expando];
                    if (key && (data = data_priv.cache[key])) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }
                        if (data_priv.cache[key]) {
                            // Discard any remaining `private` data
                            delete data_priv.cache[key];
                        }
                    }
                }
                // Discard any remaining `user` data
                delete data_user.cache[elem[data_user.expando]];
            }
        }
    });
    jQuery.fn.extend({
        text: function(value) {
            return access(this, function(value) {
                return value === undefined ? jQuery.text(this) : this.empty().each(function() {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        this.textContent = value;
                    }
                });
            }, null, value, arguments.length);
        },
        append: function() {
            return this.domManip(arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function() {
            return this.domManip(arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function() {
            return this.domManip(arguments, function(elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },
        after: function() {
            return this.domManip(arguments, function(elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },
        remove: function(selector, keepData) {
            var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0;
            for (;(elem = elems[i]) != null; i++) {
                if (!keepData && elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem));
                }
                if (elem.parentNode) {
                    if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
                        setGlobalEval(getAll(elem, "script"));
                    }
                    elem.parentNode.removeChild(elem);
                }
            }
            return this;
        },
        empty: function() {
            var elem, i = 0;
            for (;(elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {
                    // Prevent memory leaks
                    jQuery.cleanData(getAll(elem, false));
                    // Remove any remaining nodes
                    elem.textContent = "";
                }
            }
            return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function(value) {
            return access(this, function(value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (value === undefined && elem.nodeType === 1) {
                    return elem.innerHTML;
                }
                // See if we can take a shortcut and just use innerHTML
                if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [ "", "" ])[1].toLowerCase()]) {
                    value = value.replace(rxhtmlTag, "<$1></$2>");
                    try {
                        for (;i < l; i++) {
                            elem = this[i] || {};
                            // Remove element nodes and prevent memory leaks
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }
                        elem = 0;
                    } catch (e) {}
                }
                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },
        replaceWith: function() {
            var arg = arguments[0];
            // Make the changes, replacing each context element with the new content
            this.domManip(arguments, function(elem) {
                arg = this.parentNode;
                jQuery.cleanData(getAll(this));
                if (arg) {
                    arg.replaceChild(elem, this);
                }
            });
            // Force removal if there was no new content (e.g., from empty arguments)
            return arg && (arg.length || arg.nodeType) ? this : this.remove();
        },
        detach: function(selector) {
            return this.remove(selector, true);
        },
        domManip: function(args, callback) {
            // Flatten any nested arrays
            args = concat.apply([], args);
            var fragment, first, scripts, hasScripts, node, doc, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
            // We can't cloneNode fragments that contain checked, in WebKit
            if (isFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
                return this.each(function(index) {
                    var self = set.eq(index);
                    if (isFunction) {
                        args[0] = value.call(this, index, self.html());
                    }
                    self.domManip(args, callback);
                });
            }
            if (l) {
                fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
                first = fragment.firstChild;
                if (fragment.childNodes.length === 1) {
                    fragment = first;
                }
                if (first) {
                    scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                    hasScripts = scripts.length;
                    // Use the original fragment for the last item instead of the first because it can end up
                    // being emptied incorrectly in certain situations (#8070).
                    for (;i < l; i++) {
                        node = fragment;
                        if (i !== iNoClone) {
                            node = jQuery.clone(node, true, true);
                            // Keep references to cloned scripts for later restoration
                            if (hasScripts) {
                                // Support: QtWebKit
                                // jQuery.merge because push.apply(_, arraylike) throws
                                jQuery.merge(scripts, getAll(node, "script"));
                            }
                        }
                        callback.call(this[i], node, i);
                    }
                    if (hasScripts) {
                        doc = scripts[scripts.length - 1].ownerDocument;
                        // Reenable scripts
                        jQuery.map(scripts, restoreScript);
                        // Evaluate executable scripts on first document insertion
                        for (i = 0; i < hasScripts; i++) {
                            node = scripts[i];
                            if (rscriptType.test(node.type || "") && !data_priv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                                if (node.src) {
                                    // Optional AJAX dependency, but won't run scripts if not present
                                    if (jQuery._evalUrl) {
                                        jQuery._evalUrl(node.src);
                                    }
                                } else {
                                    jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
                                }
                            }
                        }
                    }
                }
            }
            return this;
        }
    });
    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(name, original) {
        jQuery.fn[name] = function(selector) {
            var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
            for (;i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);
                // Support: QtWebKit
                // .get() because push.apply(_, arraylike) throws
                push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
        };
    });
    var iframe, elemdisplay = {};
    /**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
    // Called only from within defaultDisplay
    function actualDisplay(name, doc) {
        var style, elem = jQuery(doc.createElement(name)).appendTo(doc.body), // getDefaultComputedStyle might be reliably used only on attached element
        display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ? // Use of this method is a temporary fix (more like optimization) until something better comes along,
        // since it was removed from specification and supported only in FF
        style.display : jQuery.css(elem[0], "display");
        // We don't have any data stored on the element,
        // so use "detach" method as fast way to get rid of the element
        elem.detach();
        return display;
    }
    /**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
    function defaultDisplay(nodeName) {
        var doc = document, display = elemdisplay[nodeName];
        if (!display) {
            display = actualDisplay(nodeName, doc);
            // If the simple way fails, read from inside an iframe
            if (display === "none" || !display) {
                // Use the already-created iframe if possible
                iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);
                // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
                doc = iframe[0].contentDocument;
                // Support: IE
                doc.write();
                doc.close();
                display = actualDisplay(nodeName, doc);
                iframe.detach();
            }
            // Store the correct default display
            elemdisplay[nodeName] = display;
        }
        return display;
    }
    var rmargin = /^margin/;
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
    var getStyles = function(elem) {
        // Support: IE<=11+, Firefox<=30+ (#15098, #14150)
        // IE throws on elements created in popups
        // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
        if (elem.ownerDocument.defaultView.opener) {
            return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
        }
        return window.getComputedStyle(elem, null);
    };
    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style;
        computed = computed || getStyles(elem);
        // Support: IE9
        // getPropertyValue is only needed for .css('filter') (#12537)
        if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];
        }
        if (computed) {
            if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
                ret = jQuery.style(elem, name);
            }
            // Support: iOS < 6
            // A tribute to the "awesome hack by Dean Edwards"
            // iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
            // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
            if (rnumnonpx.test(ret) && rmargin.test(name)) {
                // Remember the original values
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;
                // Put in the new values to get a computed value out
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;
                // Revert the changed values
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }
        // Support: IE
        // IE returns zIndex value as an integer.
        return ret !== undefined ? ret + "" : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
        // Define the hook, we'll check on the first run if it's really needed.
        return {
            get: function() {
                if (conditionFn()) {
                    // Hook not needed (or it's not possible to use it due
                    // to missing dependency), remove it.
                    delete this.get;
                    return;
                }
                // Hook needed; redefine it so that the support test is not executed again.
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    (function() {
        var pixelPositionVal, boxSizingReliableVal, docElem = document.documentElement, container = document.createElement("div"), div = document.createElement("div");
        if (!div.style) {
            return;
        }
        // Support: IE9-11+
        // Style of cloned element affects source element cloned (#8908)
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";
        container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" + "position:absolute";
        container.appendChild(div);
        // Executing both pixelPosition & boxSizingReliable tests require only one layout
        // so they're executed at the same time to save the second computation.
        function computePixelPositionAndBoxSizingReliable() {
            div.style.cssText = // Support: Firefox<29, Android 2.3
            // Vendor-prefix box-sizing
            "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" + "box-sizing:border-box;display:block;margin-top:1%;top:1%;" + "border:1px;padding:1px;width:4px;position:absolute";
            div.innerHTML = "";
            docElem.appendChild(container);
            var divStyle = window.getComputedStyle(div, null);
            pixelPositionVal = divStyle.top !== "1%";
            boxSizingReliableVal = divStyle.width === "4px";
            docElem.removeChild(container);
        }
        // Support: node.js jsdom
        // Don't assume that getComputedStyle is a property of the global object
        if (window.getComputedStyle) {
            jQuery.extend(support, {
                pixelPosition: function() {
                    // This test is executed only once but we still do memoizing
                    // since we can use the boxSizingReliable pre-computing.
                    // No need to check if the test was already performed, though.
                    computePixelPositionAndBoxSizingReliable();
                    return pixelPositionVal;
                },
                boxSizingReliable: function() {
                    if (boxSizingReliableVal == null) {
                        computePixelPositionAndBoxSizingReliable();
                    }
                    return boxSizingReliableVal;
                },
                reliableMarginRight: function() {
                    // Support: Android 2.3
                    // Check if div with explicit width and no margin-right incorrectly
                    // gets computed margin-right based on width of container. (#3333)
                    // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                    // This support function is only executed once so no memoizing is needed.
                    var ret, marginDiv = div.appendChild(document.createElement("div"));
                    // Reset CSS: box-sizing; display; margin; border; padding
                    marginDiv.style.cssText = div.style.cssText = // Support: Firefox<29, Android 2.3
                    // Vendor-prefix box-sizing
                    "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" + "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
                    marginDiv.style.marginRight = marginDiv.style.width = "0";
                    div.style.width = "1px";
                    docElem.appendChild(container);
                    ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);
                    docElem.removeChild(container);
                    div.removeChild(marginDiv);
                    return ret;
                }
            });
        }
    })();
    // A method for quickly swapping in/out CSS properties to get correct calculations.
    jQuery.swap = function(elem, options, callback, args) {
        var ret, name, old = {};
        // Remember the old values, and insert the new ones
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }
        ret = callback.apply(elem, args || []);
        // Revert the old values
        for (name in options) {
            elem.style[name] = old[name];
        }
        return ret;
    };
    var // Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
    // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    rdisplayswap = /^(none|table(?!-c[ea]).+)/, rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"), rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"), cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
    }, cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];
    // Return a css property mapped to a potentially vendor prefixed property
    function vendorPropName(style, name) {
        // Shortcut for names that are not vendor prefixed
        if (name in style) {
            return name;
        }
        // Check for vendor prefixed names
        var capName = name[0].toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length;
        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in style) {
                return name;
            }
        }
        return origName;
    }
    function setPositiveNumber(elem, value, subtract) {
        var matches = rnumsplit.exec(value);
        // Guard against undefined "subtract", e.g., when used as in cssHooks
        return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value;
    }
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i = extra === (isBorderBox ? "border" : "content") ? // If we already have the right measurement, avoid augmentation
        4 : // Otherwise initialize for horizontal or vertical properties
        name === "width" ? 1 : 0, val = 0;
        for (;i < 4; i += 2) {
            // Both box models exclude margin, so add it if we want it
            if (extra === "margin") {
                val += jQuery.css(elem, extra + cssExpand[i], true, styles);
            }
            if (isBorderBox) {
                // border-box includes padding, so remove it if we want content
                if (extra === "content") {
                    val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                }
                // At this point, extra isn't border nor margin, so remove border
                if (extra !== "margin") {
                    val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            } else {
                // At this point, extra isn't content, so add padding
                val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                // At this point, extra isn't content nor padding, so add border
                if (extra !== "padding") {
                    val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            }
        }
        return val;
    }
    function getWidthOrHeight(elem, name, extra) {
        // Start with offset property, which is equivalent to the border-box value
        var valueIsBorderBox = true, val = name === "width" ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
        // Some non-html elements return undefined for offsetWidth, so check for null/undefined
        // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
        // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
        if (val <= 0 || val == null) {
            // Fall back to computed then uncomputed css if necessary
            val = curCSS(elem, name, styles);
            if (val < 0 || val == null) {
                val = elem.style[name];
            }
            // Computed unit is not pixels. Stop here and return.
            if (rnumnonpx.test(val)) {
                return val;
            }
            // Check for style in case a browser which returns unreliable values
            // for getComputedStyle silently falls back to the reliable elem.style
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
            // Normalize "", auto, and prepare for extra
            val = parseFloat(val) || 0;
        }
        // Use the active box-sizing model to add/subtract irrelevant styles
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
    }
    function showHide(elements, show) {
        var display, elem, hidden, values = [], index = 0, length = elements.length;
        for (;index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            values[index] = data_priv.get(elem, "olddisplay");
            display = elem.style.display;
            if (show) {
                // Reset the inline display of this element to learn if it is
                // being hidden by cascaded rules or not
                if (!values[index] && display === "none") {
                    elem.style.display = "";
                }
                // Set elements which have been overridden with display: none
                // in a stylesheet to whatever the default browser style is
                // for such an element
                if (elem.style.display === "" && isHidden(elem)) {
                    values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
                }
            } else {
                hidden = isHidden(elem);
                if (display !== "none" || !hidden) {
                    data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
                }
            }
        }
        // Set the display of most of the elements in a second loop
        // to avoid the constant reflow
        for (index = 0; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            if (!show || elem.style.display === "none" || elem.style.display === "") {
                elem.style.display = show ? values[index] || "" : "none";
            }
        }
        return elements;
    }
    jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function(elem, computed) {
                    if (computed) {
                        // We should always get a number back from opacity
                        var ret = curCSS(elem, "opacity");
                        return ret === "" ? "1" : ret;
                    }
                }
            }
        },
        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
            columnCount: true,
            fillOpacity: true,
            flexGrow: true,
            flexShrink: true,
            fontWeight: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            widows: true,
            zIndex: true,
            zoom: true
        },
        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {
            "float": "cssFloat"
        },
        // Get and set the style property on a DOM Node
        style: function(elem, name, value, extra) {
            // Don't set styles on text and comment nodes
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }
            // Make sure that we're working with the right name
            var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
            // Gets hook for the prefixed version, then unprefixed version
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            // Check if we're setting a value
            if (value !== undefined) {
                type = typeof value;
                // Convert "+=" or "-=" to relative numbers (#7345)
                if (type === "string" && (ret = rrelNum.exec(value))) {
                    value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
                    // Fixes bug #9237
                    type = "number";
                }
                // Make sure that null and NaN values aren't set (#7116)
                if (value == null || value !== value) {
                    return;
                }
                // If a number, add 'px' to the (except for certain CSS properties)
                if (type === "number" && !jQuery.cssNumber[origName]) {
                    value += "px";
                }
                // Support: IE9-11+
                // background-* props affect original clone's values
                if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                    style[name] = "inherit";
                }
                // If a hook was provided, use that value, otherwise just set the specified value
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    style[name] = value;
                }
            } else {
                // If a hook was provided get the non-computed value from there
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }
                // Otherwise just get the value from the style object
                return style[name];
            }
        },
        css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = jQuery.camelCase(name);
            // Make sure that we're working with the right name
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
            // Try prefixed name followed by the unprefixed name
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            // If a hook was provided get the computed value from there
            if (hooks && "get" in hooks) {
                val = hooks.get(elem, true, extra);
            }
            // Otherwise, if a way to get the computed value exists, use that
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }
            // Convert "normal" to computed value
            if (val === "normal" && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }
            // Make numeric if forced or a qualifier was provided and val looks numeric
            if (extra === "" || extra) {
                num = parseFloat(val);
                return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
            }
            return val;
        }
    });
    jQuery.each([ "height", "width" ], function(i, name) {
        jQuery.cssHooks[name] = {
            get: function(elem, computed, extra) {
                if (computed) {
                    // Certain elements can have dimension info if we invisibly show them
                    // but it must have a current display style that would benefit
                    return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? jQuery.swap(elem, cssShow, function() {
                        return getWidthOrHeight(elem, name, extra);
                    }) : getWidthOrHeight(elem, name, extra);
                }
            },
            set: function(elem, value, extra) {
                var styles = extra && getStyles(elem);
                return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles) : 0);
            }
        };
    });
    // Support: Android 2.3
    jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
        if (computed) {
            return jQuery.swap(elem, {
                display: "inline-block"
            }, curCSS, [ elem, "marginRight" ]);
        }
    });
    // These hooks are used by animate to expand properties
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
                var i = 0, expanded = {}, // Assumes a single number if not a string
                parts = typeof value === "string" ? value.split(" ") : [ value ];
                for (;i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                }
                return expanded;
            }
        };
        if (!rmargin.test(prefix)) {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });
    jQuery.fn.extend({
        css: function(name, value) {
            return access(this, function(elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (jQuery.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;
                    for (;i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    }
                    return map;
                }
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        },
        show: function() {
            return showHide(this, true);
        },
        hide: function() {
            return showHide(this);
        },
        toggle: function(state) {
            if (typeof state === "boolean") {
                return state ? this.show() : this.hide();
            }
            return this.each(function() {
                if (isHidden(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || "swing";
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
        _default: {
            get: function(tween) {
                var result;
                if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
                    return tween.elem[tween.prop];
                }
                // Passing an empty string as a 3rd parameter to .css will automatically
                // attempt a parseFloat and fallback to a string if the parse fails.
                // Simple values such as "10px" are parsed to Float;
                // complex values such as "rotate(1rad)" are returned as-is.
                result = jQuery.css(tween.elem, tween.prop, "");
                // Empty strings, null, undefined and "auto" are converted to 0.
                return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
                // Use step hook for back compat.
                // Use cssHook if its there.
                // Use .style if available and use plain properties where available.
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };
    // Support: IE9
    // Panic based approach to setting things on disconnected nodes
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };
    jQuery.easing = {
        linear: function(p) {
            return p;
        },
        swing: function(p) {
            return .5 - Math.cos(p * Math.PI) / 2;
        }
    };
    jQuery.fx = Tween.prototype.init;
    // Back Compat <1.8 extension point
    jQuery.fx.step = {};
    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"), rrun = /queueHooks$/, animationPrefilters = [ defaultPrefilter ], tweeners = {
        "*": [ function(prop, value) {
            var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"), // Starting value computation is required for potential unit mismatches
            start = (jQuery.cssNumber[prop] || unit !== "px" && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
            if (start && start[3] !== unit) {
                // Trust units reported by jQuery.css
                unit = unit || start[3];
                // Make sure we update the tween properties later on
                parts = parts || [];
                // Iteratively approximate from a nonzero starting point
                start = +target || 1;
                do {
                    // If previous iteration zeroed out, double until we get *something*.
                    // Use string for doubling so we don't accidentally see scale as unchanged below
                    scale = scale || ".5";
                    // Adjust and apply
                    start = start / scale;
                    jQuery.style(tween.elem, prop, start + unit);
                } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
            }
            // Update tween properties
            if (parts) {
                start = tween.start = +start || +target || 0;
                tween.unit = unit;
                // If a +=/-= token was provided, we're doing a relative animation
                tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
            }
            return tween;
        } ]
    };
    // Animations created synchronously will run synchronously
    function createFxNow() {
        setTimeout(function() {
            fxNow = undefined;
        });
        return fxNow = jQuery.now();
    }
    // Generate parameters to create a standard animation
    function genFx(type, includeWidth) {
        var which, i = 0, attrs = {
            height: type
        };
        // If we include width, step value is 1 to do all cssExpand values,
        // otherwise step value is 2 to skip over Left and Right
        includeWidth = includeWidth ? 1 : 0;
        for (;i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
        }
        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }
        return attrs;
    }
    function createTween(value, prop, animation) {
        var tween, collection = (tweeners[prop] || []).concat(tweeners["*"]), index = 0, length = collection.length;
        for (;index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
                // We're done with this property
                return tween;
            }
        }
    }
    function defaultPrefilter(elem, props, opts) {
        /* jshint validthis: true */
        var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = data_priv.get(elem, "fxshow");
        // Handle queue: false promises
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;
            anim.always(function() {
                // Ensure the complete handler is called before this completes
                anim.always(function() {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, "fx").length) {
                        hooks.empty.fire();
                    }
                });
            });
        }
        // Height/width overflow pass
        if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
            // Make sure that nothing sneaks out
            // Record all 3 overflow attributes because IE9-10 do not
            // change the overflow attribute when overflowX and
            // overflowY are set to the same value
            opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
            // Set display property to inline-block for height/width
            // animations on inline elements that are having width/height animated
            display = jQuery.css(elem, "display");
            // Test default display if display is currently "none"
            checkDisplay = display === "none" ? data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
            if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
                style.display = "inline-block";
            }
        }
        if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
            });
        }
        // show/hide pass
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.exec(value)) {
                delete props[prop];
                toggle = toggle || value === "toggle";
                if (value === (hidden ? "hide" : "show")) {
                    // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
                    if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            } else {
                display = undefined;
            }
        }
        if (!jQuery.isEmptyObject(orig)) {
            if (dataShow) {
                if ("hidden" in dataShow) {
                    hidden = dataShow.hidden;
                }
            } else {
                dataShow = data_priv.access(elem, "fxshow", {});
            }
            // Store state if its toggle - enables .stop().toggle() to "reverse"
            if (toggle) {
                dataShow.hidden = !hidden;
            }
            if (hidden) {
                jQuery(elem).show();
            } else {
                anim.done(function() {
                    jQuery(elem).hide();
                });
            }
            anim.done(function() {
                var prop;
                data_priv.remove(elem, "fxshow");
                for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop]);
                }
            });
            for (prop in orig) {
                tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
                if (!(prop in dataShow)) {
                    dataShow[prop] = tween.start;
                    if (hidden) {
                        tween.end = tween.start;
                        tween.start = prop === "width" || prop === "height" ? 1 : 0;
                    }
                }
            }
        } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
            style.display = display;
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        // camelCase, specialEasing and expand cssHook pass
        for (index in props) {
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (jQuery.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }
            if (index !== name) {
                props[name] = value;
                delete props[index];
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && "expand" in hooks) {
                value = hooks.expand(value);
                delete props[name];
                // Not quite $.extend, this won't overwrite existing keys.
                // Reusing 'index' because we have the correct "name"
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function() {
            // Don't match elem in the :animated selector
            delete tick.elem;
        }), tick = function() {
            if (stopped) {
                return false;
            }
            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), // Support: Android 2.3
            // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
            temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
            for (;index < length; index++) {
                animation.tweens[index].run(percent);
            }
            deferred.notifyWith(elem, [ animation, percent, remaining ]);
            if (percent < 1 && length) {
                return remaining;
            } else {
                deferred.resolveWith(elem, [ animation ]);
                return false;
            }
        }, animation = deferred.promise({
            elem: elem,
            props: jQuery.extend({}, properties),
            opts: jQuery.extend(true, {
                specialEasing: {}
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end) {
                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                animation.tweens.push(tween);
                return tween;
            },
            stop: function(gotoEnd) {
                var index = 0, // If we are going to the end, we want to run all the tweens
                // otherwise we skip this part
                length = gotoEnd ? animation.tweens.length : 0;
                if (stopped) {
                    return this;
                }
                stopped = true;
                for (;index < length; index++) {
                    animation.tweens[index].run(1);
                }
                // Resolve when we played the last frame; otherwise, reject
                if (gotoEnd) {
                    deferred.resolveWith(elem, [ animation, gotoEnd ]);
                } else {
                    deferred.rejectWith(elem, [ animation, gotoEnd ]);
                }
                return this;
            }
        }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (;index < length; index++) {
            result = animationPrefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                return result;
            }
        }
        jQuery.map(props, createTween, animation);
        if (jQuery.isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));
        // attach callbacks from options
        return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    }
    jQuery.Animation = jQuery.extend(Animation, {
        tweener: function(props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = [ "*" ];
            } else {
                props = props.split(" ");
            }
            var prop, index = 0, length = props.length;
            for (;index < length; index++) {
                prop = props[index];
                tweeners[prop] = tweeners[prop] || [];
                tweeners[prop].unshift(callback);
            }
        },
        prefilter: function(callback, prepend) {
            if (prepend) {
                animationPrefilters.unshift(callback);
            } else {
                animationPrefilters.push(callback);
            }
        }
    });
    jQuery.speed = function(speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
        // Normalize opt.queue - true/undefined/null -> "fx"
        if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
        }
        // Queueing
        opt.old = opt.complete;
        opt.complete = function() {
            if (jQuery.isFunction(opt.old)) {
                opt.old.call(this);
            }
            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };
        return opt;
    };
    jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
            // Show any hidden elements after setting opacity to 0
            return this.filter(isHidden).css("opacity", 0).show().end().animate({
                opacity: to
            }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
                // Operate on a copy of prop so per-property easing won't be lost
                var anim = Animation(this, jQuery.extend({}, prop), optall);
                // Empty animations, or finishing resolves immediately
                if (empty || data_priv.get(this, "finish")) {
                    anim.stop(true);
                }
            };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };
            if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || "fx", []);
            }
            return this.each(function() {
                var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery.timers, data = data_priv.get(this);
                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }
                for (index = timers.length; index--; ) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }
                // Start the next in the queue if the last step wasn't forced.
                // Timers currently will call their complete callbacks, which
                // will dequeue but only if they were gotoEnd.
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function(type) {
            if (type !== false) {
                type = type || "fx";
            }
            return this.each(function() {
                var index, data = data_priv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
                // Enable finishing flag on private data
                data.finish = true;
                // Empty the queue first
                jQuery.queue(this, type, []);
                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }
                // Look for any active animations, and finish them
                for (index = timers.length; index--; ) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }
                // Look for any animations in the old queue and finish them
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }
                // Turn off finishing flag
                delete data.finish;
            });
        }
    });
    jQuery.each([ "toggle", "show", "hide" ], function(i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });
    // Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function() {
        var timer, i = 0, timers = jQuery.timers;
        fxNow = jQuery.now();
        for (;i < timers.length; i++) {
            timer = timers[i];
            // Checks the timer has not already been removed
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }
        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };
    jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer);
        if (timer()) {
            jQuery.fx.start();
        } else {
            jQuery.timers.pop();
        }
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function() {
        if (!timerId) {
            timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
        }
    };
    jQuery.fx.stop = function() {
        clearInterval(timerId);
        timerId = null;
    };
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        // Default speed
        _default: 400
    };
    // Based off of the plugin by Clint Helfers, with permission.
    // http://blindsignals.com/index.php/2009/07/jquery-delay/
    jQuery.fn.delay = function(time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";
        return this.queue(type, function(next, hooks) {
            var timeout = setTimeout(next, time);
            hooks.stop = function() {
                clearTimeout(timeout);
            };
        });
    };
    (function() {
        var input = document.createElement("input"), select = document.createElement("select"), opt = select.appendChild(document.createElement("option"));
        input.type = "checkbox";
        // Support: iOS<=5.1, Android<=4.2+
        // Default value for a checkbox should be "on"
        support.checkOn = input.value !== "";
        // Support: IE<=11+
        // Must access selectedIndex to make default options select
        support.optSelected = opt.selected;
        // Support: Android<=2.3
        // Options inside disabled selects are incorrectly marked as disabled
        select.disabled = true;
        support.optDisabled = !opt.disabled;
        // Support: IE<=11+
        // An input loses its value after becoming a radio
        input = document.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
    })();
    var nodeHook, boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
        attr: function(name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function(name) {
            return this.each(function() {
                jQuery.removeAttr(this, name);
            });
        }
    });
    jQuery.extend({
        attr: function(elem, name, value) {
            var hooks, ret, nType = elem.nodeType;
            // don't get/set attributes on text, comment and attribute nodes
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            // Fallback to prop when attributes are not supported
            if (typeof elem.getAttribute === strundefined) {
                return jQuery.prop(elem, name, value);
            }
            // All attributes are lowercase
            // Grab necessary hook if one is defined
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
            }
            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                } else if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                } else {
                    elem.setAttribute(name, value + "");
                    return value;
                }
            } else if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            } else {
                ret = jQuery.find.attr(elem, name);
                // Non-existent attributes return null, we normalize to undefined
                return ret == null ? undefined : ret;
            }
        },
        removeAttr: function(elem, value) {
            var name, propName, i = 0, attrNames = value && value.match(rnotwhite);
            if (attrNames && elem.nodeType === 1) {
                while (name = attrNames[i++]) {
                    propName = jQuery.propFix[name] || name;
                    // Boolean attributes get special treatment (#10870)
                    if (jQuery.expr.match.bool.test(name)) {
                        // Set corresponding property to false
                        elem[propName] = false;
                    }
                    elem.removeAttribute(name);
                }
            }
        },
        attrHooks: {
            type: {
                set: function(elem, value) {
                    if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        }
    });
    // Hooks for boolean attributes
    boolHook = {
        set: function(elem, value, name) {
            if (value === false) {
                // Remove boolean attributes when set to false
                jQuery.removeAttr(elem, name);
            } else {
                elem.setAttribute(name, name);
            }
            return name;
        }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function(elem, name, isXML) {
            var ret, handle;
            if (!isXML) {
                // Avoid an infinite loop by temporarily removing this function from the getter
                handle = attrHandle[name];
                attrHandle[name] = ret;
                ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
                attrHandle[name] = handle;
            }
            return ret;
        };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i;
    jQuery.fn.extend({
        prop: function(name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function(name) {
            return this.each(function() {
                delete this[jQuery.propFix[name] || name];
            });
        }
    });
    jQuery.extend({
        propFix: {
            "for": "htmlFor",
            "class": "className"
        },
        prop: function(elem, name, value) {
            var ret, hooks, notxml, nType = elem.nodeType;
            // Don't get/set properties on text, comment and attribute nodes
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
            if (notxml) {
                // Fix name and attach hooks
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }
            if (value !== undefined) {
                return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
            } else {
                return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
            }
        },
        propHooks: {
            tabIndex: {
                get: function(elem) {
                    return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;
                }
            }
        }
    });
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function(elem) {
                var parent = elem.parentNode;
                if (parent && parent.parentNode) {
                    parent.parentNode.selectedIndex;
                }
                return null;
            }
        };
    }
    jQuery.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
        jQuery.propFix[this.toLowerCase()] = this;
    });
    var rclass = /[\t\r\n\f]/g;
    jQuery.fn.extend({
        addClass: function(value) {
            var classes, elem, cur, clazz, j, finalValue, proceed = typeof value === "string" && value, i = 0, len = this.length;
            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).addClass(value.call(this, j, this.className));
                });
            }
            if (proceed) {
                // The disjunction here is for better compressibility (see removeClass)
                classes = (value || "").match(rnotwhite) || [];
                for (;i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : " ");
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            if (cur.indexOf(" " + clazz + " ") < 0) {
                                cur += clazz + " ";
                            }
                        }
                        // only assign if different to avoid unneeded rendering.
                        finalValue = jQuery.trim(cur);
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }
            return this;
        },
        removeClass: function(value) {
            var classes, elem, cur, clazz, j, finalValue, proceed = arguments.length === 0 || typeof value === "string" && value, i = 0, len = this.length;
            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).removeClass(value.call(this, j, this.className));
                });
            }
            if (proceed) {
                classes = (value || "").match(rnotwhite) || [];
                for (;i < len; i++) {
                    elem = this[i];
                    // This expression is here for better compressibility (see addClass)
                    cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : "");
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            // Remove *all* instances
                            while (cur.indexOf(" " + clazz + " ") >= 0) {
                                cur = cur.replace(" " + clazz + " ", " ");
                            }
                        }
                        // Only assign if different to avoid unneeded rendering.
                        finalValue = value ? jQuery.trim(cur) : "";
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }
            return this;
        },
        toggleClass: function(value, stateVal) {
            var type = typeof value;
            if (typeof stateVal === "boolean" && type === "string") {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            if (jQuery.isFunction(value)) {
                return this.each(function(i) {
                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                });
            }
            return this.each(function() {
                if (type === "string") {
                    // Toggle individual class names
                    var className, i = 0, self = jQuery(this), classNames = value.match(rnotwhite) || [];
                    while (className = classNames[i++]) {
                        // Check each className given, space separated list
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }
                } else if (type === strundefined || type === "boolean") {
                    if (this.className) {
                        // store className if set
                        data_priv.set(this, "__className__", this.className);
                    }
                    // If the element has a class name or if we're passed `false`,
                    // then remove the whole classname (if there was one, the above saved it).
                    // Otherwise bring back whatever was previously saved (if anything),
                    // falling back to the empty string if nothing was stored.
                    this.className = this.className || value === false ? "" : data_priv.get(this, "__className__") || "";
                }
            });
        },
        hasClass: function(selector) {
            var className = " " + selector + " ", i = 0, l = this.length;
            for (;i < l; i++) {
                if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
                    return true;
                }
            }
            return false;
        }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function(value) {
            var hooks, ret, isFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                        return ret;
                    }
                    ret = elem.value;
                    // Handle most common string cases
                    // Handle cases where value is null/undef or number
                    return typeof ret === "string" ? ret.replace(rreturn, "") : ret == null ? "" : ret;
                }
                return;
            }
            isFunction = jQuery.isFunction(value);
            return this.each(function(i) {
                var val;
                if (this.nodeType !== 1) {
                    return;
                }
                if (isFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }
                // Treat null/undefined as ""; convert numbers to string
                if (val == null) {
                    val = "";
                } else if (typeof val === "number") {
                    val += "";
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function(value) {
                        return value == null ? "" : value + "";
                    });
                }
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                // If set returns undefined, fall back to normal setting
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                    this.value = val;
                }
            });
        }
    });
    jQuery.extend({
        valHooks: {
            option: {
                get: function(elem) {
                    var val = jQuery.find.attr(elem, "value");
                    // Support: IE10-11+
                    // option.text throws exceptions (#14686, #14858)
                    return val != null ? val : jQuery.trim(jQuery.text(elem));
                }
            },
            select: {
                get: function(elem) {
                    var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one" || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
                    // Loop through all the selected options
                    for (;i < max; i++) {
                        option = options[i];
                        // IE6-9 doesn't update selected after form reset (#2551)
                        if ((option.selected || i === index) && (// Don't return options that are disabled or in a disabled optgroup
                        support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
                            // Get the specific value for the option
                            value = jQuery(option).val();
                            // We don't need an array for one selects
                            if (one) {
                                return value;
                            }
                            // Multi-Selects return an array
                            values.push(value);
                        }
                    }
                    return values;
                },
                set: function(elem, value) {
                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                    while (i--) {
                        option = options[i];
                        if (option.selected = jQuery.inArray(option.value, values) >= 0) {
                            optionSet = true;
                        }
                    }
                    // Force browsers to behave consistently when non-matching value is set
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        }
    });
    // Radios and checkboxes getter/setter
    jQuery.each([ "radio", "checkbox" ], function() {
        jQuery.valHooks[this] = {
            set: function(elem, value) {
                if (jQuery.isArray(value)) {
                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
                }
            }
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function(elem) {
                return elem.getAttribute("value") === null ? "on" : elem.value;
            };
        }
    });
    // Return jQuery for attributes-only inclusion
    jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
        // Handle event binding
        jQuery.fn[name] = function(data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    });
    jQuery.fn.extend({
        hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        },
        bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {
            // ( namespace ) or ( selector, types [, fn] )
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        }
    });
    var nonce = jQuery.now();
    var rquery = /\?/;
    // Support: Android 2.3
    // Workaround failure to string-cast null input
    jQuery.parseJSON = function(data) {
        return JSON.parse(data + "");
    };
    // Cross-browser xml parsing
    jQuery.parseXML = function(data) {
        var xml, tmp;
        if (!data || typeof data !== "string") {
            return null;
        }
        // Support: IE9
        try {
            tmp = new DOMParser();
            xml = tmp.parseFromString(data, "text/xml");
        } catch (e) {
            xml = undefined;
        }
        if (!xml || xml.getElementsByTagName("parsererror").length) {
            jQuery.error("Invalid XML: " + data);
        }
        return xml;
    };
    var rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, // #7653, #8125, #8152: local protocol detection
    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, /* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
    prefilters = {}, /* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
    transports = {}, // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
    allTypes = "*/".concat("*"), // Document location
    ajaxLocation = window.location.href, // Segment location into parts
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports(structure) {
        // dataTypeExpression is optional and defaults to "*"
        return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
            if (jQuery.isFunction(func)) {
                // For each dataType in the dataTypeExpression
                while (dataType = dataTypes[i++]) {
                    // Prepend if requested
                    if (dataType[0] === "+") {
                        dataType = dataType.slice(1) || "*";
                        (structure[dataType] = structure[dataType] || []).unshift(func);
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }
    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport);
                }
            });
            return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }
    // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes #9887
    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }
        return target;
    }
    /* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
    function ajaxHandleResponses(s, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
        // Remove auto dataType and get content-type in the process
        while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
        }
        // Check if we're dealing with a known content-type
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }
        // Check to see if we have a response for the expected dataType
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            // Try convertible dataTypes
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }
        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }
    /* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, // Work with a copy of dataTypes in case we need to modify it for conversion
        dataTypes = s.dataTypes.slice();
        // Create converters map with lowercased keys
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }
        current = dataTypes.shift();
        // Convert to each sequential dataType
        while (current) {
            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }
            // Apply the dataFilter if provided
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
                // There's only work to do if current dataType is non-auto
                if (current === "*") {
                    current = prev;
                } else if (prev !== "*" && prev !== current) {
                    // Seek a direct converter
                    conv = converters[prev + " " + current] || converters["* " + current];
                    // If none found, seek a pair
                    if (!conv) {
                        for (conv2 in converters) {
                            // If conv2 outputs current
                            tmp = conv2.split(" ");
                            if (tmp[1] === current) {
                                // If prev can be converted to accepted input
                                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                                if (conv) {
                                    // Condense equivalence converters
                                    if (conv === true) {
                                        conv = converters[conv2];
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    // Apply converter (if not an equivalence)
                    if (conv !== true) {
                        // Unless errors are allowed to bubble, catch and return them
                        if (conv && s["throws"]) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: "parsererror",
                                    error: conv ? e : "No conversion from " + prev + " to " + current
                                };
                            }
                        }
                    }
                }
            }
        }
        return {
            state: "success",
            data: response
        };
    }
    jQuery.extend({
        // Counter for holding the number of active queries
        active: 0,
        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: ajaxLocation,
            type: "GET",
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            /*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/
            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {
                // Convert anything to text
                "* text": String,
                // Text to html (true = no transformation)
                "text html": true,
                // Evaluate text as a json expression
                "text json": jQuery.parseJSON,
                // Parse text as xml
                "text xml": jQuery.parseXML
            },
            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
                url: true,
                context: true
            }
        },
        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function(target, settings) {
            // Building a settings object
            // Extending ajaxSettings
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        // Main method
        ajax: function(url, options) {
            // If url is an object, simulate pre-1.5 signature
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }
            // Force options to be an object
            options = options || {};
            var transport, // URL without anti-cache param
            cacheURL, // Response headers
            responseHeadersString, responseHeaders, // timeout handle
            timeoutTimer, // Cross-domain detection vars
            parts, // To know if global events are to be dispatched
            fireGlobals, // Loop variable
            i, // Create the final options object
            s = jQuery.ajaxSetup({}, options), // Callbacks context
            callbackContext = s.context || s, // Context for global events is callbackContext if it is a DOM node or jQuery collection
            globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, // Deferreds
            deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), // Status-dependent callbacks
            statusCode = s.statusCode || {}, // Headers (they are sent all at once)
            requestHeaders = {}, requestHeadersNames = {}, // The jqXHR state
            state = 0, // Default abort message
            strAbort = "canceled", // Fake xhr
            jqXHR = {
                readyState: 0,
                // Builds headers hashtable if needed
                getResponseHeader: function(key) {
                    var match;
                    if (state === 2) {
                        if (!responseHeaders) {
                            responseHeaders = {};
                            while (match = rheaders.exec(responseHeadersString)) {
                                responseHeaders[match[1].toLowerCase()] = match[2];
                            }
                        }
                        match = responseHeaders[key.toLowerCase()];
                    }
                    return match == null ? null : match;
                },
                // Raw string
                getAllResponseHeaders: function() {
                    return state === 2 ? responseHeadersString : null;
                },
                // Caches the header
                setRequestHeader: function(name, value) {
                    var lname = name.toLowerCase();
                    if (!state) {
                        name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                        requestHeaders[name] = value;
                    }
                    return this;
                },
                // Overrides response content-type header
                overrideMimeType: function(type) {
                    if (!state) {
                        s.mimeType = type;
                    }
                    return this;
                },
                // Status-dependent callbacks
                statusCode: function(map) {
                    var code;
                    if (map) {
                        if (state < 2) {
                            for (code in map) {
                                // Lazy-add the new callback in a way that preserves old ones
                                statusCode[code] = [ statusCode[code], map[code] ];
                            }
                        } else {
                            // Execute the appropriate callbacks
                            jqXHR.always(map[jqXHR.status]);
                        }
                    }
                    return this;
                },
                // Cancel the request
                abort: function(statusText) {
                    var finalText = statusText || strAbort;
                    if (transport) {
                        transport.abort(finalText);
                    }
                    done(0, finalText);
                    return this;
                }
            };
            // Attach deferreds
            deferred.promise(jqXHR).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            // Remove hash character (#7531: and string promotion)
            // Add protocol if not provided (prefilters might expect it)
            // Handle falsy url in the settings object (#10093: consistency with old signature)
            // We also use the url parameter if available
            s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");
            // Alias method option to type as per ticket #12004
            s.type = options.method || options.type || s.method || s.type;
            // Extract dataTypes list
            s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [ "" ];
            // A cross-domain request is in order when we have a protocol:host:port mismatch
            if (s.crossDomain == null) {
                parts = rurl.exec(s.url.toLowerCase());
                s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? "80" : "443")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443"))));
            }
            // Convert data if not already a string
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
            }
            // Apply prefilters
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            // If request was aborted inside a prefilter, stop there
            if (state === 2) {
                return jqXHR;
            }
            // We can fire global events as of now if asked to
            // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
            fireGlobals = jQuery.event && s.global;
            // Watch for a new set of requests
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
            }
            // Uppercase the type
            s.type = s.type.toUpperCase();
            // Determine if request has content
            s.hasContent = !rnoContent.test(s.type);
            // Save the URL in case we're toying with the If-Modified-Since
            // and/or If-None-Match header later on
            cacheURL = s.url;
            // More options handling for requests with no content
            if (!s.hasContent) {
                // If data is available, append data to url
                if (s.data) {
                    cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data;
                    // #9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                }
                // Add anti-cache in url if needed
                if (s.cache === false) {
                    s.url = rts.test(cacheURL) ? // If there is already a '_' parameter, set its value
                    cacheURL.replace(rts, "$1_=" + nonce++) : // Otherwise add one to the end
                    cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
                }
            }
            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
                }
            }
            // Set the correct header, if data is being sent
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType);
            }
            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
            // Check for headers option
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }
            // Allow custom headers/mimetypes and early abort
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                // Abort if not done already and return
                return jqXHR.abort();
            }
            // Aborting is no longer a cancellation
            strAbort = "abort";
            // Install callbacks on deferreds
            for (i in {
                success: 1,
                error: 1,
                complete: 1
            }) {
                jqXHR[i](s[i]);
            }
            // Get transport
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            // If no transport, we auto-abort
            if (!transport) {
                done(-1, "No Transport");
            } else {
                jqXHR.readyState = 1;
                // Send global event
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [ jqXHR, s ]);
                }
                // Timeout
                if (s.async && s.timeout > 0) {
                    timeoutTimer = setTimeout(function() {
                        jqXHR.abort("timeout");
                    }, s.timeout);
                }
                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    // Propagate exception as error if not done
                    if (state < 2) {
                        done(-1, e);
                    } else {
                        throw e;
                    }
                }
            }
            // Callback for when everything is done
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                // Called once
                if (state === 2) {
                    return;
                }
                // State is "done" now
                state = 2;
                // Clear timeout if it exists
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer);
                }
                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;
                // Cache response headers
                responseHeadersString = headers || "";
                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0;
                // Determine if successful
                isSuccess = status >= 200 && status < 300 || status === 304;
                // Get response data
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }
                // Convert no matter what (that way responseXXX fields are always set)
                response = ajaxConvert(s, response, jqXHR, isSuccess);
                // If successful, handle type chaining
                if (isSuccess) {
                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader("etag");
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }
                    // if no content
                    if (status === 204 || s.type === "HEAD") {
                        statusText = "nocontent";
                    } else if (status === 304) {
                        statusText = "notmodified";
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    // Extract error from statusText and normalize for non-aborts
                    error = statusText;
                    if (status || !statusText) {
                        statusText = "error";
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }
                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";
                // Success/Error
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [ success, statusText, jqXHR ]);
                } else {
                    deferred.rejectWith(callbackContext, [ jqXHR, statusText, error ]);
                }
                // Status-dependent callbacks
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [ jqXHR, s, isSuccess ? success : error ]);
                }
                // Complete
                completeDeferred.fireWith(callbackContext, [ jqXHR, statusText ]);
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [ jqXHR, s ]);
                    // Handle the global AJAX counter
                    if (!--jQuery.active) {
                        jQuery.event.trigger("ajaxStop");
                    }
                }
            }
            return jqXHR;
        },
        getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },
        getScript: function(url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        }
    });
    jQuery.each([ "get", "post" ], function(i, method) {
        jQuery[method] = function(url, data, callback, type) {
            // Shift arguments if data argument was omitted
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
            return jQuery.ajax({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            });
        };
    });
    jQuery._evalUrl = function(url) {
        return jQuery.ajax({
            url: url,
            type: "GET",
            dataType: "script",
            async: false,
            global: false,
            "throws": true
        });
    };
    jQuery.fn.extend({
        wrapAll: function(html) {
            var wrap;
            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }
            if (this[0]) {
                // The elements to wrap the target around
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }
                wrap.map(function() {
                    var elem = this;
                    while (elem.firstElementChild) {
                        elem = elem.firstElementChild;
                    }
                    return elem;
                }).append(this);
            }
            return this;
        },
        wrapInner: function(html) {
            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }
            return this.each(function() {
                var self = jQuery(this), contents = self.contents();
                if (contents.length) {
                    contents.wrapAll(html);
                } else {
                    self.append(html);
                }
            });
        },
        wrap: function(html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function(i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function() {
            return this.parent().each(function() {
                if (!jQuery.nodeName(this, "body")) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        }
    });
    jQuery.expr.filters.hidden = function(elem) {
        // Support: Opera <= 12.12
        // Opera reports offsetWidths and offsetHeights less than zero on some elements
        return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
    };
    jQuery.expr.filters.visible = function(elem) {
        return !jQuery.expr.filters.hidden(elem);
    };
    var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (jQuery.isArray(obj)) {
            // Serialize array item.
            jQuery.each(obj, function(i, v) {
                if (traditional || rbracket.test(prefix)) {
                    // Treat each array item as a scalar.
                    add(prefix, v);
                } else {
                    // Item is non-scalar (array or object), encode its numeric index.
                    buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
                }
            });
        } else if (!traditional && jQuery.type(obj) === "object") {
            // Serialize object item.
            for (name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }
        } else {
            // Serialize scalar item.
            add(prefix, obj);
        }
    }
    // Serialize an array of form elements or a set of
    // key/values into a query string
    jQuery.param = function(a, traditional) {
        var prefix, s = [], add = function(key, value) {
            // If value is a function, invoke it and return its value
            value = jQuery.isFunction(value) ? value() : value == null ? "" : value;
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
        };
        // Set traditional to true for jQuery <= 1.3.2 behavior.
        if (traditional === undefined) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }
        // If an array was passed in, assume that it is an array of form elements.
        if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
            // Serialize the form elements
            jQuery.each(a, function() {
                add(this.name, this.value);
            });
        } else {
            // If traditional, encode the "old" way (the way 1.3.2 or older
            // did it), otherwise encode params recursively.
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }
        // Return the resulting serialization
        return s.join("&").replace(r20, "+");
    };
    jQuery.fn.extend({
        serialize: function() {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                // Can add propHook for "elements" to filter or add form elements
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function() {
                var type = this.type;
                // Use .is( ":disabled" ) so that fieldset[disabled] works
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(i, elem) {
                var val = jQuery(this).val();
                return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    };
                }) : {
                    name: elem.name,
                    value: val.replace(rCRLF, "\r\n")
                };
            }).get();
        }
    });
    jQuery.ajaxSettings.xhr = function() {
        try {
            return new XMLHttpRequest();
        } catch (e) {}
    };
    var xhrId = 0, xhrCallbacks = {}, xhrSuccessStatus = {
        // file protocol always yields status code 0, assume 200
        0: 200,
        // Support: IE9
        // #1450: sometimes IE returns 1223 when it should be 204
        1223: 204
    }, xhrSupported = jQuery.ajaxSettings.xhr();
    // Support: IE9
    // Open requests must be manually aborted on unload (#5280)
    // See https://support.microsoft.com/kb/2856746 for more info
    if (window.attachEvent) {
        window.attachEvent("onunload", function() {
            for (var key in xhrCallbacks) {
                xhrCallbacks[key]();
            }
        });
    }
    support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
    support.ajax = xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function(options) {
        var callback;
        // Cross domain only allowed if supported through XMLHttpRequest
        if (support.cors || xhrSupported && !options.crossDomain) {
            return {
                send: function(headers, complete) {
                    var i, xhr = options.xhr(), id = ++xhrId;
                    xhr.open(options.type, options.url, options.async, options.username, options.password);
                    // Apply custom fields if provided
                    if (options.xhrFields) {
                        for (i in options.xhrFields) {
                            xhr[i] = options.xhrFields[i];
                        }
                    }
                    // Override mime type if needed
                    if (options.mimeType && xhr.overrideMimeType) {
                        xhr.overrideMimeType(options.mimeType);
                    }
                    // X-Requested-With header
                    // For cross-domain requests, seeing as conditions for a preflight are
                    // akin to a jigsaw puzzle, we simply never set it to be sure.
                    // (it can always be set on a per-request basis or even using ajaxSetup)
                    // For same-domain requests, won't change header if already provided.
                    if (!options.crossDomain && !headers["X-Requested-With"]) {
                        headers["X-Requested-With"] = "XMLHttpRequest";
                    }
                    // Set headers
                    for (i in headers) {
                        xhr.setRequestHeader(i, headers[i]);
                    }
                    // Callback
                    callback = function(type) {
                        return function() {
                            if (callback) {
                                delete xhrCallbacks[id];
                                callback = xhr.onload = xhr.onerror = null;
                                if (type === "abort") {
                                    xhr.abort();
                                } else if (type === "error") {
                                    complete(// file: protocol always yields status 0; see #8605, #14207
                                    xhr.status, xhr.statusText);
                                } else {
                                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE9
                                    // Accessing binary-data responseText throws an exception
                                    // (#11426)
                                    typeof xhr.responseText === "string" ? {
                                        text: xhr.responseText
                                    } : undefined, xhr.getAllResponseHeaders());
                                }
                            }
                        };
                    };
                    // Listen to events
                    xhr.onload = callback();
                    xhr.onerror = callback("error");
                    // Create the abort callback
                    callback = xhrCallbacks[id] = callback("abort");
                    try {
                        // Do send the request (this may raise an exception)
                        xhr.send(options.hasContent && options.data || null);
                    } catch (e) {
                        // #14683: Only rethrow if this hasn't been notified as an error yet
                        if (callback) {
                            throw e;
                        }
                    }
                },
                abort: function() {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    // Install script dataType
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /(?:java|ecma)script/
        },
        converters: {
            "text script": function(text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });
    // Handle cache's special case and crossDomain
    jQuery.ajaxPrefilter("script", function(s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = "GET";
        }
    });
    // Bind script tag hack transport
    jQuery.ajaxTransport("script", function(s) {
        // This transport only deals with cross domain requests
        if (s.crossDomain) {
            var script, callback;
            return {
                send: function(_, complete) {
                    script = jQuery("<script>").prop({
                        async: true,
                        charset: s.scriptCharset,
                        src: s.url
                    }).on("load error", callback = function(evt) {
                        script.remove();
                        callback = null;
                        if (evt) {
                            complete(evt.type === "error" ? 404 : 200, evt.type);
                        }
                    });
                    document.head.appendChild(script[0]);
                },
                abort: function() {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    // Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
            this[callback] = true;
            return callback;
        }
    });
    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
        // Handle iff the expected data type is "jsonp" or we have a parameter to set
        if (jsonProp || s.dataTypes[0] === "jsonp") {
            // Get callback name, remembering preexisting value associated with it
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            // Insert callback into url or form data
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            }
            // Use data converter to retrieve json after script execution
            s.converters["script json"] = function() {
                if (!responseContainer) {
                    jQuery.error(callbackName + " was not called");
                }
                return responseContainer[0];
            };
            // force json dataType
            s.dataTypes[0] = "json";
            // Install callback
            overwritten = window[callbackName];
            window[callbackName] = function() {
                responseContainer = arguments;
            };
            // Clean-up function (fires after converters)
            jqXHR.always(function() {
                // Restore preexisting value
                window[callbackName] = overwritten;
                // Save back as free
                if (s[callbackName]) {
                    // make sure that re-using the options doesn't screw things around
                    s.jsonpCallback = originalSettings.jsonpCallback;
                    // save the callback name for future use
                    oldCallbacks.push(callbackName);
                }
                // Call if it was a function and we have a response
                if (responseContainer && jQuery.isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }
                responseContainer = overwritten = undefined;
            });
            // Delegate to script
            return "script";
        }
    });
    // data: string of html
    // context (optional): If specified, the fragment will be created in this context, defaults to document
    // keepScripts (optional): If true, will include scripts passed in the html string
    jQuery.parseHTML = function(data, context, keepScripts) {
        if (!data || typeof data !== "string") {
            return null;
        }
        if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
        }
        context = context || document;
        var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
        // Single tag
        if (parsed) {
            return [ context.createElement(parsed[1]) ];
        }
        parsed = jQuery.buildFragment([ data ], context, scripts);
        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }
        return jQuery.merge([], parsed.childNodes);
    };
    // Keep a copy of the old load method
    var _load = jQuery.fn.load;
    /**
 * Load a url into a page
 */
    jQuery.fn.load = function(url, params, callback) {
        if (typeof url !== "string" && _load) {
            return _load.apply(this, arguments);
        }
        var selector, type, response, self = this, off = url.indexOf(" ");
        if (off >= 0) {
            selector = jQuery.trim(url.slice(off));
            url = url.slice(0, off);
        }
        // If it's a function
        if (jQuery.isFunction(params)) {
            // We assume that it's the callback
            callback = params;
            params = undefined;
        } else if (params && typeof params === "object") {
            type = "POST";
        }
        // If we have elements to modify, make the request
        if (self.length > 0) {
            jQuery.ajax({
                url: url,
                // if "type" variable is undefined, then "GET" method will be used
                type: type,
                dataType: "html",
                data: params
            }).done(function(responseText) {
                // Save response for use in complete callback
                response = arguments;
                self.html(selector ? // If a selector was specified, locate the right elements in a dummy div
                // Exclude scripts to avoid IE 'Permission Denied' errors
                jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result
                responseText);
            }).complete(callback && function(jqXHR, status) {
                self.each(callback, response || [ jqXHR.responseText, status, jqXHR ]);
            });
        }
        return this;
    };
    // Attach a bunch of functions for handling common AJAX events
    jQuery.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(i, type) {
        jQuery.fn[type] = function(fn) {
            return this.on(type, fn);
        };
    });
    jQuery.expr.filters.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
            return elem === fn.elem;
        }).length;
    };
    var docElem = window.document.documentElement;
    /**
 * Gets a window from an element
 */
    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
    }
    jQuery.offset = {
        setOffset: function(elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
            // Set position first, in-case top/left are set even on static elem
            if (position === "static") {
                elem.style.position = "relative";
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, "top");
            curCSSLeft = jQuery.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
            // Need to be able to calculate position if either
            // top or left is auto and position is either absolute or fixed
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, curOffset);
            }
            if (options.top != null) {
                props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft;
            }
            if ("using" in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };
    jQuery.fn.extend({
        offset: function(options) {
            if (arguments.length) {
                return options === undefined ? this : this.each(function(i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }
            var docElem, win, elem = this[0], box = {
                top: 0,
                left: 0
            }, doc = elem && elem.ownerDocument;
            if (!doc) {
                return;
            }
            docElem = doc.documentElement;
            // Make sure it's not a disconnected DOM node
            if (!jQuery.contains(docElem, elem)) {
                return box;
            }
            // Support: BlackBerry 5, iOS 3 (original iPhone)
            // If we don't have gBCR, just use 0,0 rather than error
            if (typeof elem.getBoundingClientRect !== strundefined) {
                box = elem.getBoundingClientRect();
            }
            win = getWindow(doc);
            return {
                top: box.top + win.pageYOffset - docElem.clientTop,
                left: box.left + win.pageXOffset - docElem.clientLeft
            };
        },
        position: function() {
            if (!this[0]) {
                return;
            }
            var offsetParent, offset, elem = this[0], parentOffset = {
                top: 0,
                left: 0
            };
            // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
            if (jQuery.css(elem, "position") === "fixed") {
                // Assume getBoundingClientRect is there when computed position is fixed
                offset = elem.getBoundingClientRect();
            } else {
                // Get *real* offsetParent
                offsetParent = this.offsetParent();
                // Get correct offsets
                offset = this.offset();
                if (!jQuery.nodeName(offsetParent[0], "html")) {
                    parentOffset = offsetParent.offset();
                }
                // Add offsetParent borders
                parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
                parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
            }
            // Subtract parent offsets and element margins
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
            };
        },
        offsetParent: function() {
            return this.map(function() {
                var offsetParent = this.offsetParent || docElem;
                while (offsetParent && (!jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static")) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || docElem;
            });
        }
    });
    // Create scrollLeft and scrollTop methods
    jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(method, prop) {
        var top = "pageYOffset" === prop;
        jQuery.fn[method] = function(val) {
            return access(this, function(elem, method, val) {
                var win = getWindow(elem);
                if (val === undefined) {
                    return win ? win[prop] : elem[method];
                }
                if (win) {
                    win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);
                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length, null);
        };
    });
    // Support: Safari<7+, Chrome<37+
    // Add the top/left cssHooks using jQuery.fn.position
    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
    // getComputedStyle returns percent when specified for top/left/bottom/right;
    // rather than make the css module depend on the offset module, just check for it here
    jQuery.each([ "top", "left" ], function(i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);
                // If curCSS returns percentage, fallback to offset
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
            }
        });
    });
    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
    jQuery.each({
        Height: "height",
        Width: "width"
    }, function(name, type) {
        jQuery.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
        }, function(defaultExtra, funcName) {
            // Margin is only for outerHeight, outerWidth
            jQuery.fn[funcName] = function(margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
                return access(this, function(elem, type, value) {
                    var doc;
                    if (jQuery.isWindow(elem)) {
                        // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                        // isn't a whole lot we can do. See pull request at this URL for discussion:
                        // https://github.com/jquery/jquery/pull/764
                        return elem.document.documentElement["client" + name];
                    }
                    // Get document width or height
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;
                        // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                        // whichever is greatest
                        return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
                    }
                    // Get width or height on the element, requesting but not forcing parseFloat
                    // Set width or height on the element
                    return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable, null);
            };
        });
    });
    // The number of elements contained in the matched element set
    jQuery.fn.size = function() {
        return this.length;
    };
    jQuery.fn.andSelf = jQuery.fn.addBack;
    // Register as a named AMD module, since jQuery can be concatenated with other
    // files that may use define, but not via a proper concatenation script that
    // understands anonymous AMD modules. A named AMD is safest and most robust
    // way to register. Lowercase jquery is used because AMD module names are
    // derived from file names, and jQuery is normally delivered in a lowercase
    // file name. Do this after creating the global so that if an AMD module wants
    // to call noConflict to hide this version of jQuery, it will work.
    // Note that for maximum portability, libraries that are not jQuery should
    // declare themselves as anonymous modules, and avoid setting a global if an
    // AMD loader is present. jQuery is a special case. For more information, see
    // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
    if (typeof define === "function" && define.amd) {
        define("jquery", [], function() {
            return jQuery;
        });
    }
    var // Map over jQuery in case of overwrite
    _jQuery = window.jQuery, // Map over the $ in case of overwrite
    _$ = window.$;
    jQuery.noConflict = function(deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }
        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }
        return jQuery;
    };
    // Expose jQuery and $ identifiers, even in AMD
    // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
    // and CommonJS for browser emulators (#13566)
    if (typeof noGlobal === strundefined) {
        window.jQuery = window.$ = jQuery;
    }
    return jQuery;
});

/*!
 * Bootstrap v3.3.2 (http://getbootstrap.com)
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */
if (typeof jQuery === "undefined") {
    throw new Error("Bootstrap's JavaScript requires jQuery");
}

+function($) {
    "use strict";
    var version = $.fn.jquery.split(" ")[0].split(".");
    if (version[0] < 2 && version[1] < 9 || version[0] == 1 && version[1] == 9 && version[2] < 1) {
        throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher");
    }
}(jQuery);

/* ========================================================================
 * Bootstrap: transition.js v3.3.2
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function($) {
    "use strict";
    // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
    // ============================================================
    function transitionEnd() {
        var el = document.createElement("bootstrap");
        var transEndEventNames = {
            WebkitTransition: "webkitTransitionEnd",
            MozTransition: "transitionend",
            OTransition: "oTransitionEnd otransitionend",
            transition: "transitionend"
        };
        for (var name in transEndEventNames) {
            if (el.style[name] !== undefined) {
                return {
                    end: transEndEventNames[name]
                };
            }
        }
        return false;
    }
    // http://blog.alexmaccaw.com/css-transitions
    $.fn.emulateTransitionEnd = function(duration) {
        var called = false;
        var $el = this;
        $(this).one("bsTransitionEnd", function() {
            called = true;
        });
        var callback = function() {
            if (!called) $($el).trigger($.support.transition.end);
        };
        setTimeout(callback, duration);
        return this;
    };
    $(function() {
        $.support.transition = transitionEnd();
        if (!$.support.transition) return;
        $.event.special.bsTransitionEnd = {
            bindType: $.support.transition.end,
            delegateType: $.support.transition.end,
            handle: function(e) {
                if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments);
            }
        };
    });
}(jQuery);

/* ========================================================================
 * Bootstrap: alert.js v3.3.2
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function($) {
    "use strict";
    // ALERT CLASS DEFINITION
    // ======================
    var dismiss = '[data-dismiss="alert"]';
    var Alert = function(el) {
        $(el).on("click", dismiss, this.close);
    };
    Alert.VERSION = "3.3.2";
    Alert.TRANSITION_DURATION = 150;
    Alert.prototype.close = function(e) {
        var $this = $(this);
        var selector = $this.attr("data-target");
        if (!selector) {
            selector = $this.attr("href");
            selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "");
        }
        var $parent = $(selector);
        if (e) e.preventDefault();
        if (!$parent.length) {
            $parent = $this.closest(".alert");
        }
        $parent.trigger(e = $.Event("close.bs.alert"));
        if (e.isDefaultPrevented()) return;
        $parent.removeClass("in");
        function removeElement() {
            // detach from parent, fire event then clean up data
            $parent.detach().trigger("closed.bs.alert").remove();
        }
        $.support.transition && $parent.hasClass("fade") ? $parent.one("bsTransitionEnd", removeElement).emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement();
    };
    // ALERT PLUGIN DEFINITION
    // =======================
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.alert");
            if (!data) $this.data("bs.alert", data = new Alert(this));
            if (typeof option == "string") data[option].call($this);
        });
    }
    var old = $.fn.alert;
    $.fn.alert = Plugin;
    $.fn.alert.Constructor = Alert;
    // ALERT NO CONFLICT
    // =================
    $.fn.alert.noConflict = function() {
        $.fn.alert = old;
        return this;
    };
    // ALERT DATA-API
    // ==============
    $(document).on("click.bs.alert.data-api", dismiss, Alert.prototype.close);
}(jQuery);

/* ========================================================================
 * Bootstrap: button.js v3.3.2
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function($) {
    "use strict";
    // BUTTON PUBLIC CLASS DEFINITION
    // ==============================
    var Button = function(element, options) {
        this.$element = $(element);
        this.options = $.extend({}, Button.DEFAULTS, options);
        this.isLoading = false;
    };
    Button.VERSION = "3.3.2";
    Button.DEFAULTS = {
        loadingText: "loading..."
    };
    Button.prototype.setState = function(state) {
        var d = "disabled";
        var $el = this.$element;
        var val = $el.is("input") ? "val" : "html";
        var data = $el.data();
        state = state + "Text";
        if (data.resetText == null) $el.data("resetText", $el[val]());
        // push to event loop to allow forms to submit
        setTimeout($.proxy(function() {
            $el[val](data[state] == null ? this.options[state] : data[state]);
            if (state == "loadingText") {
                this.isLoading = true;
                $el.addClass(d).attr(d, d);
            } else if (this.isLoading) {
                this.isLoading = false;
                $el.removeClass(d).removeAttr(d);
            }
        }, this), 0);
    };
    Button.prototype.toggle = function() {
        var changed = true;
        var $parent = this.$element.closest('[data-toggle="buttons"]');
        if ($parent.length) {
            var $input = this.$element.find("input");
            if ($input.prop("type") == "radio") {
                if ($input.prop("checked") && this.$element.hasClass("active")) changed = false; else $parent.find(".active").removeClass("active");
            }
            if (changed) $input.prop("checked", !this.$element.hasClass("active")).trigger("change");
        } else {
            this.$element.attr("aria-pressed", !this.$element.hasClass("active"));
        }
        if (changed) this.$element.toggleClass("active");
    };
    // BUTTON PLUGIN DEFINITION
    // ========================
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.button");
            var options = typeof option == "object" && option;
            if (!data) $this.data("bs.button", data = new Button(this, options));
            if (option == "toggle") data.toggle(); else if (option) data.setState(option);
        });
    }
    var old = $.fn.button;
    $.fn.button = Plugin;
    $.fn.button.Constructor = Button;
    // BUTTON NO CONFLICT
    // ==================
    $.fn.button.noConflict = function() {
        $.fn.button = old;
        return this;
    };
    // BUTTON DATA-API
    // ===============
    $(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function(e) {
        var $btn = $(e.target);
        if (!$btn.hasClass("btn")) $btn = $btn.closest(".btn");
        Plugin.call($btn, "toggle");
        e.preventDefault();
    }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function(e) {
        $(e.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(e.type));
    });
}(jQuery);

/* ========================================================================
 * Bootstrap: carousel.js v3.3.2
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function($) {
    "use strict";
    // CAROUSEL CLASS DEFINITION
    // =========================
    var Carousel = function(element, options) {
        this.$element = $(element);
        this.$indicators = this.$element.find(".carousel-indicators");
        this.options = options;
        this.paused = this.sliding = this.interval = this.$active = this.$items = null;
        this.options.keyboard && this.$element.on("keydown.bs.carousel", $.proxy(this.keydown, this));
        this.options.pause == "hover" && !("ontouchstart" in document.documentElement) && this.$element.on("mouseenter.bs.carousel", $.proxy(this.pause, this)).on("mouseleave.bs.carousel", $.proxy(this.cycle, this));
    };
    Carousel.VERSION = "3.3.2";
    Carousel.TRANSITION_DURATION = 600;
    Carousel.DEFAULTS = {
        interval: 5e3,
        pause: "hover",
        wrap: true,
        keyboard: true
    };
    Carousel.prototype.keydown = function(e) {
        if (/input|textarea/i.test(e.target.tagName)) return;
        switch (e.which) {
          case 37:
            this.prev();
            break;

          case 39:
            this.next();
            break;

          default:
            return;
        }
        e.preventDefault();
    };
    Carousel.prototype.cycle = function(e) {
        e || (this.paused = false);
        this.interval && clearInterval(this.interval);
        this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval));
        return this;
    };
    Carousel.prototype.getItemIndex = function(item) {
        this.$items = item.parent().children(".item");
        return this.$items.index(item || this.$active);
    };
    Carousel.prototype.getItemForDirection = function(direction, active) {
        var activeIndex = this.getItemIndex(active);
        var willWrap = direction == "prev" && activeIndex === 0 || direction == "next" && activeIndex == this.$items.length - 1;
        if (willWrap && !this.options.wrap) return active;
        var delta = direction == "prev" ? -1 : 1;
        var itemIndex = (activeIndex + delta) % this.$items.length;
        return this.$items.eq(itemIndex);
    };
    Carousel.prototype.to = function(pos) {
        var that = this;
        var activeIndex = this.getItemIndex(this.$active = this.$element.find(".item.active"));
        if (pos > this.$items.length - 1 || pos < 0) return;
        if (this.sliding) return this.$element.one("slid.bs.carousel", function() {
            that.to(pos);
        });
        // yes, "slid"
        if (activeIndex == pos) return this.pause().cycle();
        return this.slide(pos > activeIndex ? "next" : "prev", this.$items.eq(pos));
    };
    Carousel.prototype.pause = function(e) {
        e || (this.paused = true);
        if (this.$element.find(".next, .prev").length && $.support.transition) {
            this.$element.trigger($.support.transition.end);
            this.cycle(true);
        }
        this.interval = clearInterval(this.interval);
        return this;
    };
    Carousel.prototype.next = function() {
        if (this.sliding) return;
        return this.slide("next");
    };
    Carousel.prototype.prev = function() {
        if (this.sliding) return;
        return this.slide("prev");
    };
    Carousel.prototype.slide = function(type, next) {
        var $active = this.$element.find(".item.active");
        var $next = next || this.getItemForDirection(type, $active);
        var isCycling = this.interval;
        var direction = type == "next" ? "left" : "right";
        var that = this;
        if ($next.hasClass("active")) return this.sliding = false;
        var relatedTarget = $next[0];
        var slideEvent = $.Event("slide.bs.carousel", {
            relatedTarget: relatedTarget,
            direction: direction
        });
        this.$element.trigger(slideEvent);
        if (slideEvent.isDefaultPrevented()) return;
        this.sliding = true;
        isCycling && this.pause();
        if (this.$indicators.length) {
            this.$indicators.find(".active").removeClass("active");
            var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)]);
            $nextIndicator && $nextIndicator.addClass("active");
        }
        var slidEvent = $.Event("slid.bs.carousel", {
            relatedTarget: relatedTarget,
            direction: direction
        });
        // yes, "slid"
        if ($.support.transition && this.$element.hasClass("slide")) {
            $next.addClass(type);
            $next[0].offsetWidth;
            // force reflow
            $active.addClass(direction);
            $next.addClass(direction);
            $active.one("bsTransitionEnd", function() {
                $next.removeClass([ type, direction ].join(" ")).addClass("active");
                $active.removeClass([ "active", direction ].join(" "));
                that.sliding = false;
                setTimeout(function() {
                    that.$element.trigger(slidEvent);
                }, 0);
            }).emulateTransitionEnd(Carousel.TRANSITION_DURATION);
        } else {
            $active.removeClass("active");
            $next.addClass("active");
            this.sliding = false;
            this.$element.trigger(slidEvent);
        }
        isCycling && this.cycle();
        return this;
    };
    // CAROUSEL PLUGIN DEFINITION
    // ==========================
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.carousel");
            var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == "object" && option);
            var action = typeof option == "string" ? option : options.slide;
            if (!data) $this.data("bs.carousel", data = new Carousel(this, options));
            if (typeof option == "number") data.to(option); else if (action) data[action](); else if (options.interval) data.pause().cycle();
        });
    }
    var old = $.fn.carousel;
    $.fn.carousel = Plugin;
    $.fn.carousel.Constructor = Carousel;
    // CAROUSEL NO CONFLICT
    // ====================
    $.fn.carousel.noConflict = function() {
        $.fn.carousel = old;
        return this;
    };
    // CAROUSEL DATA-API
    // =================
    var clickHandler = function(e) {
        var href;
        var $this = $(this);
        var $target = $($this.attr("data-target") || (href = $this.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, ""));
        // strip for ie7
        if (!$target.hasClass("carousel")) return;
        var options = $.extend({}, $target.data(), $this.data());
        var slideIndex = $this.attr("data-slide-to");
        if (slideIndex) options.interval = false;
        Plugin.call($target, options);
        if (slideIndex) {
            $target.data("bs.carousel").to(slideIndex);
        }
        e.preventDefault();
    };
    $(document).on("click.bs.carousel.data-api", "[data-slide]", clickHandler).on("click.bs.carousel.data-api", "[data-slide-to]", clickHandler);
    $(window).on("load", function() {
        $('[data-ride="carousel"]').each(function() {
            var $carousel = $(this);
            Plugin.call($carousel, $carousel.data());
        });
    });
}(jQuery);

/* ========================================================================
 * Bootstrap: collapse.js v3.3.2
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function($) {
    "use strict";
    // COLLAPSE PUBLIC CLASS DEFINITION
    // ================================
    var Collapse = function(element, options) {
        this.$element = $(element);
        this.options = $.extend({}, Collapse.DEFAULTS, options);
        this.$trigger = $(this.options.trigger).filter('[href="#' + element.id + '"], [data-target="#' + element.id + '"]');
        this.transitioning = null;
        if (this.options.parent) {
            this.$parent = this.getParent();
        } else {
            this.addAriaAndCollapsedClass(this.$element, this.$trigger);
        }
        if (this.options.toggle) this.toggle();
    };
    Collapse.VERSION = "3.3.2";
    Collapse.TRANSITION_DURATION = 350;
    Collapse.DEFAULTS = {
        toggle: true,
        trigger: '[data-toggle="collapse"]'
    };
    Collapse.prototype.dimension = function() {
        var hasWidth = this.$element.hasClass("width");
        return hasWidth ? "width" : "height";
    };
    Collapse.prototype.show = function() {
        if (this.transitioning || this.$element.hasClass("in")) return;
        var activesData;
        var actives = this.$parent && this.$parent.children(".panel").children(".in, .collapsing");
        if (actives && actives.length) {
            activesData = actives.data("bs.collapse");
            if (activesData && activesData.transitioning) return;
        }
        var startEvent = $.Event("show.bs.collapse");
        this.$element.trigger(startEvent);
        if (startEvent.isDefaultPrevented()) return;
        if (actives && actives.length) {
            Plugin.call(actives, "hide");
            activesData || actives.data("bs.collapse", null);
        }
        var dimension = this.dimension();
        this.$element.removeClass("collapse").addClass("collapsing")[dimension](0).attr("aria-expanded", true);
        this.$trigger.removeClass("collapsed").attr("aria-expanded", true);
        this.transitioning = 1;
        var complete = function() {
            this.$element.removeClass("collapsing").addClass("collapse in")[dimension]("");
            this.transitioning = 0;
            this.$element.trigger("shown.bs.collapse");
        };
        if (!$.support.transition) return complete.call(this);
        var scrollSize = $.camelCase([ "scroll", dimension ].join("-"));
        this.$element.one("bsTransitionEnd", $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize]);
    };
    Collapse.prototype.hide = function() {
        if (this.transitioning || !this.$element.hasClass("in")) return;
        var startEvent = $.Event("hide.bs.collapse");
        this.$element.trigger(startEvent);
        if (startEvent.isDefaultPrevented()) return;
        var dimension = this.dimension();
        this.$element[dimension](this.$element[dimension]())[0].offsetHeight;
        this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded", false);
        this.$trigger.addClass("collapsed").attr("aria-expanded", false);
        this.transitioning = 1;
        var complete = function() {
            this.transitioning = 0;
            this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse");
        };
        if (!$.support.transition) return complete.call(this);
        this.$element[dimension](0).one("bsTransitionEnd", $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION);
    };
    Collapse.prototype.toggle = function() {
        this[this.$element.hasClass("in") ? "hide" : "show"]();
    };
    Collapse.prototype.getParent = function() {
        return $(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each($.proxy(function(i, element) {
            var $element = $(element);
            this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element);
        }, this)).end();
    };
    Collapse.prototype.addAriaAndCollapsedClass = function($element, $trigger) {
        var isOpen = $element.hasClass("in");
        $element.attr("aria-expanded", isOpen);
        $trigger.toggleClass("collapsed", !isOpen).attr("aria-expanded", isOpen);
    };
    function getTargetFromTrigger($trigger) {
        var href;
        var target = $trigger.attr("data-target") || (href = $trigger.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, "");
        // strip for ie7
        return $(target);
    }
    // COLLAPSE PLUGIN DEFINITION
    // ==========================
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.collapse");
            var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == "object" && option);
            if (!data && options.toggle && option == "show") options.toggle = false;
            if (!data) $this.data("bs.collapse", data = new Collapse(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.collapse;
    $.fn.collapse = Plugin;
    $.fn.collapse.Constructor = Collapse;
    // COLLAPSE NO CONFLICT
    // ====================
    $.fn.collapse.noConflict = function() {
        $.fn.collapse = old;
        return this;
    };
    // COLLAPSE DATA-API
    // =================
    $(document).on("click.bs.collapse.data-api", '[data-toggle="collapse"]', function(e) {
        var $this = $(this);
        if (!$this.attr("data-target")) e.preventDefault();
        var $target = getTargetFromTrigger($this);
        var data = $target.data("bs.collapse");
        var option = data ? "toggle" : $.extend({}, $this.data(), {
            trigger: this
        });
        Plugin.call($target, option);
    });
}(jQuery);

/* ========================================================================
 * Bootstrap: dropdown.js v3.3.2
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function($) {
    "use strict";
    // DROPDOWN CLASS DEFINITION
    // =========================
    var backdrop = ".dropdown-backdrop";
    var toggle = '[data-toggle="dropdown"]';
    var Dropdown = function(element) {
        $(element).on("click.bs.dropdown", this.toggle);
    };
    Dropdown.VERSION = "3.3.2";
    Dropdown.prototype.toggle = function(e) {
        var $this = $(this);
        if ($this.is(".disabled, :disabled")) return;
        var $parent = getParent($this);
        var isActive = $parent.hasClass("open");
        clearMenus();
        if (!isActive) {
            if ("ontouchstart" in document.documentElement && !$parent.closest(".navbar-nav").length) {
                // if mobile we use a backdrop because click events don't delegate
                $('<div class="dropdown-backdrop"/>').insertAfter($(this)).on("click", clearMenus);
            }
            var relatedTarget = {
                relatedTarget: this
            };
            $parent.trigger(e = $.Event("show.bs.dropdown", relatedTarget));
            if (e.isDefaultPrevented()) return;
            $this.trigger("focus").attr("aria-expanded", "true");
            $parent.toggleClass("open").trigger("shown.bs.dropdown", relatedTarget);
        }
        return false;
    };
    Dropdown.prototype.keydown = function(e) {
        if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return;
        var $this = $(this);
        e.preventDefault();
        e.stopPropagation();
        if ($this.is(".disabled, :disabled")) return;
        var $parent = getParent($this);
        var isActive = $parent.hasClass("open");
        if (!isActive && e.which != 27 || isActive && e.which == 27) {
            if (e.which == 27) $parent.find(toggle).trigger("focus");
            return $this.trigger("click");
        }
        var desc = " li:not(.divider):visible a";
        var $items = $parent.find('[role="menu"]' + desc + ', [role="listbox"]' + desc);
        if (!$items.length) return;
        var index = $items.index(e.target);
        if (e.which == 38 && index > 0) index--;
        // up
        if (e.which == 40 && index < $items.length - 1) index++;
        // down
        if (!~index) index = 0;
        $items.eq(index).trigger("focus");
    };
    function clearMenus(e) {
        if (e && e.which === 3) return;
        $(backdrop).remove();
        $(toggle).each(function() {
            var $this = $(this);
            var $parent = getParent($this);
            var relatedTarget = {
                relatedTarget: this
            };
            if (!$parent.hasClass("open")) return;
            $parent.trigger(e = $.Event("hide.bs.dropdown", relatedTarget));
            if (e.isDefaultPrevented()) return;
            $this.attr("aria-expanded", "false");
            $parent.removeClass("open").trigger("hidden.bs.dropdown", relatedTarget);
        });
    }
    function getParent($this) {
        var selector = $this.attr("data-target");
        if (!selector) {
            selector = $this.attr("href");
            selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, "");
        }
        var $parent = selector && $(selector);
        return $parent && $parent.length ? $parent : $this.parent();
    }
    // DROPDOWN PLUGIN DEFINITION
    // ==========================
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.dropdown");
            if (!data) $this.data("bs.dropdown", data = new Dropdown(this));
            if (typeof option == "string") data[option].call($this);
        });
    }
    var old = $.fn.dropdown;
    $.fn.dropdown = Plugin;
    $.fn.dropdown.Constructor = Dropdown;
    // DROPDOWN NO CONFLICT
    // ====================
    $.fn.dropdown.noConflict = function() {
        $.fn.dropdown = old;
        return this;
    };
    // APPLY TO STANDARD DROPDOWN ELEMENTS
    // ===================================
    $(document).on("click.bs.dropdown.data-api", clearMenus).on("click.bs.dropdown.data-api", ".dropdown form", function(e) {
        e.stopPropagation();
    }).on("click.bs.dropdown.data-api", toggle, Dropdown.prototype.toggle).on("keydown.bs.dropdown.data-api", toggle, Dropdown.prototype.keydown).on("keydown.bs.dropdown.data-api", '[role="menu"]', Dropdown.prototype.keydown).on("keydown.bs.dropdown.data-api", '[role="listbox"]', Dropdown.prototype.keydown);
}(jQuery);

/* ========================================================================
 * Bootstrap: modal.js v3.3.2
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function($) {
    "use strict";
    // MODAL CLASS DEFINITION
    // ======================
    var Modal = function(element, options) {
        this.options = options;
        this.$body = $(document.body);
        this.$element = $(element);
        this.$backdrop = this.isShown = null;
        this.scrollbarWidth = 0;
        if (this.options.remote) {
            this.$element.find(".modal-content").load(this.options.remote, $.proxy(function() {
                this.$element.trigger("loaded.bs.modal");
            }, this));
        }
    };
    Modal.VERSION = "3.3.2";
    Modal.TRANSITION_DURATION = 300;
    Modal.BACKDROP_TRANSITION_DURATION = 150;
    Modal.DEFAULTS = {
        backdrop: true,
        keyboard: true,
        show: true
    };
    Modal.prototype.toggle = function(_relatedTarget) {
        return this.isShown ? this.hide() : this.show(_relatedTarget);
    };
    Modal.prototype.show = function(_relatedTarget) {
        var that = this;
        var e = $.Event("show.bs.modal", {
            relatedTarget: _relatedTarget
        });
        this.$element.trigger(e);
        if (this.isShown || e.isDefaultPrevented()) return;
        this.isShown = true;
        this.checkScrollbar();
        this.setScrollbar();
        this.$body.addClass("modal-open");
        this.escape();
        this.resize();
        this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', $.proxy(this.hide, this));
        this.backdrop(function() {
            var transition = $.support.transition && that.$element.hasClass("fade");
            if (!that.$element.parent().length) {
                that.$element.appendTo(that.$body);
            }
            that.$element.show().scrollTop(0);
            if (that.options.backdrop) that.adjustBackdrop();
            that.adjustDialog();
            if (transition) {
                that.$element[0].offsetWidth;
            }
            that.$element.addClass("in").attr("aria-hidden", false);
            that.enforceFocus();
            var e = $.Event("shown.bs.modal", {
                relatedTarget: _relatedTarget
            });
            transition ? that.$element.find(".modal-dialog").one("bsTransitionEnd", function() {
                that.$element.trigger("focus").trigger(e);
            }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger("focus").trigger(e);
        });
    };
    Modal.prototype.hide = function(e) {
        if (e) e.preventDefault();
        e = $.Event("hide.bs.modal");
        this.$element.trigger(e);
        if (!this.isShown || e.isDefaultPrevented()) return;
        this.isShown = false;
        this.escape();
        this.resize();
        $(document).off("focusin.bs.modal");
        this.$element.removeClass("in").attr("aria-hidden", true).off("click.dismiss.bs.modal");
        $.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal();
    };
    Modal.prototype.enforceFocus = function() {
        $(document).off("focusin.bs.modal").on("focusin.bs.modal", $.proxy(function(e) {
            if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
                this.$element.trigger("focus");
            }
        }, this));
    };
    Modal.prototype.escape = function() {
        if (this.isShown && this.options.keyboard) {
            this.$element.on("keydown.dismiss.bs.modal", $.proxy(function(e) {
                e.which == 27 && this.hide();
            }, this));
        } else if (!this.isShown) {
            this.$element.off("keydown.dismiss.bs.modal");
        }
    };
    Modal.prototype.resize = function() {
        if (this.isShown) {
            $(window).on("resize.bs.modal", $.proxy(this.handleUpdate, this));
        } else {
            $(window).off("resize.bs.modal");
        }
    };
    Modal.prototype.hideModal = function() {
        var that = this;
        this.$element.hide();
        this.backdrop(function() {
            that.$body.removeClass("modal-open");
            that.resetAdjustments();
            that.resetScrollbar();
            that.$element.trigger("hidden.bs.modal");
        });
    };
    Modal.prototype.removeBackdrop = function() {
        this.$backdrop && this.$backdrop.remove();
        this.$backdrop = null;
    };
    Modal.prototype.backdrop = function(callback) {
        var that = this;
        var animate = this.$element.hasClass("fade") ? "fade" : "";
        if (this.isShown && this.options.backdrop) {
            var doAnimate = $.support.transition && animate;
            this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />').prependTo(this.$element).on("click.dismiss.bs.modal", $.proxy(function(e) {
                if (e.target !== e.currentTarget) return;
                this.options.backdrop == "static" ? this.$element[0].focus.call(this.$element[0]) : this.hide.call(this);
            }, this));
            if (doAnimate) this.$backdrop[0].offsetWidth;
            // force reflow
            this.$backdrop.addClass("in");
            if (!callback) return;
            doAnimate ? this.$backdrop.one("bsTransitionEnd", callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback();
        } else if (!this.isShown && this.$backdrop) {
            this.$backdrop.removeClass("in");
            var callbackRemove = function() {
                that.removeBackdrop();
                callback && callback();
            };
            $.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove();
        } else if (callback) {
            callback();
        }
    };
    // these following methods are used to handle overflowing modals
    Modal.prototype.handleUpdate = function() {
        if (this.options.backdrop) this.adjustBackdrop();
        this.adjustDialog();
    };
    Modal.prototype.adjustBackdrop = function() {
        this.$backdrop.css("height", 0).css("height", this.$element[0].scrollHeight);
    };
    Modal.prototype.adjustDialog = function() {
        var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;
        this.$element.css({
            paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : "",
            paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ""
        });
    };
    Modal.prototype.resetAdjustments = function() {
        this.$element.css({
            paddingLeft: "",
            paddingRight: ""
        });
    };
    Modal.prototype.checkScrollbar = function() {
        this.bodyIsOverflowing = document.body.scrollHeight > document.documentElement.clientHeight;
        this.scrollbarWidth = this.measureScrollbar();
    };
    Modal.prototype.setScrollbar = function() {
        var bodyPad = parseInt(this.$body.css("padding-right") || 0, 10);
        if (this.bodyIsOverflowing) this.$body.css("padding-right", bodyPad + this.scrollbarWidth);
    };
    Modal.prototype.resetScrollbar = function() {
        this.$body.css("padding-right", "");
    };
    Modal.prototype.measureScrollbar = function() {
        // thx walsh
        var scrollDiv = document.createElement("div");
        scrollDiv.className = "modal-scrollbar-measure";
        this.$body.append(scrollDiv);
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        this.$body[0].removeChild(scrollDiv);
        return scrollbarWidth;
    };
    // MODAL PLUGIN DEFINITION
    // =======================
    function Plugin(option, _relatedTarget) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.modal");
            var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == "object" && option);
            if (!data) $this.data("bs.modal", data = new Modal(this, options));
            if (typeof option == "string") data[option](_relatedTarget); else if (options.show) data.show(_relatedTarget);
        });
    }
    var old = $.fn.modal;
    $.fn.modal = Plugin;
    $.fn.modal.Constructor = Modal;
    // MODAL NO CONFLICT
    // =================
    $.fn.modal.noConflict = function() {
        $.fn.modal = old;
        return this;
    };
    // MODAL DATA-API
    // ==============
    $(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function(e) {
        var $this = $(this);
        var href = $this.attr("href");
        var $target = $($this.attr("data-target") || href && href.replace(/.*(?=#[^\s]+$)/, ""));
        // strip for ie7
        var option = $target.data("bs.modal") ? "toggle" : $.extend({
            remote: !/#/.test(href) && href
        }, $target.data(), $this.data());
        if ($this.is("a")) e.preventDefault();
        $target.one("show.bs.modal", function(showEvent) {
            if (showEvent.isDefaultPrevented()) return;
            // only register focus restorer if modal will actually get shown
            $target.one("hidden.bs.modal", function() {
                $this.is(":visible") && $this.trigger("focus");
            });
        });
        Plugin.call($target, option, this);
    });
}(jQuery);

/* ========================================================================
 * Bootstrap: tooltip.js v3.3.2
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function($) {
    "use strict";
    // TOOLTIP PUBLIC CLASS DEFINITION
    // ===============================
    var Tooltip = function(element, options) {
        this.type = this.options = this.enabled = this.timeout = this.hoverState = this.$element = null;
        this.init("tooltip", element, options);
    };
    Tooltip.VERSION = "3.3.2";
    Tooltip.TRANSITION_DURATION = 150;
    Tooltip.DEFAULTS = {
        animation: true,
        placement: "top",
        selector: false,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: false,
        container: false,
        viewport: {
            selector: "body",
            padding: 0
        }
    };
    Tooltip.prototype.init = function(type, element, options) {
        this.enabled = true;
        this.type = type;
        this.$element = $(element);
        this.options = this.getOptions(options);
        this.$viewport = this.options.viewport && $(this.options.viewport.selector || this.options.viewport);
        var triggers = this.options.trigger.split(" ");
        for (var i = triggers.length; i--; ) {
            var trigger = triggers[i];
            if (trigger == "click") {
                this.$element.on("click." + this.type, this.options.selector, $.proxy(this.toggle, this));
            } else if (trigger != "manual") {
                var eventIn = trigger == "hover" ? "mouseenter" : "focusin";
                var eventOut = trigger == "hover" ? "mouseleave" : "focusout";
                this.$element.on(eventIn + "." + this.type, this.options.selector, $.proxy(this.enter, this));
                this.$element.on(eventOut + "." + this.type, this.options.selector, $.proxy(this.leave, this));
            }
        }
        this.options.selector ? this._options = $.extend({}, this.options, {
            trigger: "manual",
            selector: ""
        }) : this.fixTitle();
    };
    Tooltip.prototype.getDefaults = function() {
        return Tooltip.DEFAULTS;
    };
    Tooltip.prototype.getOptions = function(options) {
        options = $.extend({}, this.getDefaults(), this.$element.data(), options);
        if (options.delay && typeof options.delay == "number") {
            options.delay = {
                show: options.delay,
                hide: options.delay
            };
        }
        return options;
    };
    Tooltip.prototype.getDelegateOptions = function() {
        var options = {};
        var defaults = this.getDefaults();
        this._options && $.each(this._options, function(key, value) {
            if (defaults[key] != value) options[key] = value;
        });
        return options;
    };
    Tooltip.prototype.enter = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data("bs." + this.type);
        if (self && self.$tip && self.$tip.is(":visible")) {
            self.hoverState = "in";
            return;
        }
        if (!self) {
            self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
            $(obj.currentTarget).data("bs." + this.type, self);
        }
        clearTimeout(self.timeout);
        self.hoverState = "in";
        if (!self.options.delay || !self.options.delay.show) return self.show();
        self.timeout = setTimeout(function() {
            if (self.hoverState == "in") self.show();
        }, self.options.delay.show);
    };
    Tooltip.prototype.leave = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data("bs." + this.type);
        if (!self) {
            self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
            $(obj.currentTarget).data("bs." + this.type, self);
        }
        clearTimeout(self.timeout);
        self.hoverState = "out";
        if (!self.options.delay || !self.options.delay.hide) return self.hide();
        self.timeout = setTimeout(function() {
            if (self.hoverState == "out") self.hide();
        }, self.options.delay.hide);
    };
    Tooltip.prototype.show = function() {
        var e = $.Event("show.bs." + this.type);
        if (this.hasContent() && this.enabled) {
            this.$element.trigger(e);
            var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
            if (e.isDefaultPrevented() || !inDom) return;
            var that = this;
            var $tip = this.tip();
            var tipId = this.getUID(this.type);
            this.setContent();
            $tip.attr("id", tipId);
            this.$element.attr("aria-describedby", tipId);
            if (this.options.animation) $tip.addClass("fade");
            var placement = typeof this.options.placement == "function" ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;
            var autoToken = /\s?auto?\s?/i;
            var autoPlace = autoToken.test(placement);
            if (autoPlace) placement = placement.replace(autoToken, "") || "top";
            $tip.detach().css({
                top: 0,
                left: 0,
                display: "block"
            }).addClass(placement).data("bs." + this.type, this);
            this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element);
            var pos = this.getPosition();
            var actualWidth = $tip[0].offsetWidth;
            var actualHeight = $tip[0].offsetHeight;
            if (autoPlace) {
                var orgPlacement = placement;
                var $container = this.options.container ? $(this.options.container) : this.$element.parent();
                var containerDim = this.getPosition($container);
                placement = placement == "bottom" && pos.bottom + actualHeight > containerDim.bottom ? "top" : placement == "top" && pos.top - actualHeight < containerDim.top ? "bottom" : placement == "right" && pos.right + actualWidth > containerDim.width ? "left" : placement == "left" && pos.left - actualWidth < containerDim.left ? "right" : placement;
                $tip.removeClass(orgPlacement).addClass(placement);
            }
            var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);
            this.applyPlacement(calculatedOffset, placement);
            var complete = function() {
                var prevHoverState = that.hoverState;
                that.$element.trigger("shown.bs." + that.type);
                that.hoverState = null;
                if (prevHoverState == "out") that.leave(that);
            };
            $.support.transition && this.$tip.hasClass("fade") ? $tip.one("bsTransitionEnd", complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
        }
    };
    Tooltip.prototype.applyPlacement = function(offset, placement) {
        var $tip = this.tip();
        var width = $tip[0].offsetWidth;
        var height = $tip[0].offsetHeight;
        // manually read margins because getBoundingClientRect includes difference
        var marginTop = parseInt($tip.css("margin-top"), 10);
        var marginLeft = parseInt($tip.css("margin-left"), 10);
        // we must check for NaN for ie 8/9
        if (isNaN(marginTop)) marginTop = 0;
        if (isNaN(marginLeft)) marginLeft = 0;
        offset.top = offset.top + marginTop;
        offset.left = offset.left + marginLeft;
        // $.fn.offset doesn't round pixel values
        // so we use setOffset directly with our own function B-0
        $.offset.setOffset($tip[0], $.extend({
            using: function(props) {
                $tip.css({
                    top: Math.round(props.top),
                    left: Math.round(props.left)
                });
            }
        }, offset), 0);
        $tip.addClass("in");
        // check to see if placing tip in new offset caused the tip to resize itself
        var actualWidth = $tip[0].offsetWidth;
        var actualHeight = $tip[0].offsetHeight;
        if (placement == "top" && actualHeight != height) {
            offset.top = offset.top + height - actualHeight;
        }
        var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);
        if (delta.left) offset.left += delta.left; else offset.top += delta.top;
        var isVertical = /top|bottom/.test(placement);
        var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;
        var arrowOffsetPosition = isVertical ? "offsetWidth" : "offsetHeight";
        $tip.offset(offset);
        this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical);
    };
    Tooltip.prototype.replaceArrow = function(delta, dimension, isHorizontal) {
        this.arrow().css(isHorizontal ? "left" : "top", 50 * (1 - delta / dimension) + "%").css(isHorizontal ? "top" : "left", "");
    };
    Tooltip.prototype.setContent = function() {
        var $tip = this.tip();
        var title = this.getTitle();
        $tip.find(".tooltip-inner")[this.options.html ? "html" : "text"](title);
        $tip.removeClass("fade in top bottom left right");
    };
    Tooltip.prototype.hide = function(callback) {
        var that = this;
        var $tip = this.tip();
        var e = $.Event("hide.bs." + this.type);
        function complete() {
            if (that.hoverState != "in") $tip.detach();
            that.$element.removeAttr("aria-describedby").trigger("hidden.bs." + that.type);
            callback && callback();
        }
        this.$element.trigger(e);
        if (e.isDefaultPrevented()) return;
        $tip.removeClass("in");
        $.support.transition && this.$tip.hasClass("fade") ? $tip.one("bsTransitionEnd", complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
        this.hoverState = null;
        return this;
    };
    Tooltip.prototype.fixTitle = function() {
        var $e = this.$element;
        if ($e.attr("title") || typeof $e.attr("data-original-title") != "string") {
            $e.attr("data-original-title", $e.attr("title") || "").attr("title", "");
        }
    };
    Tooltip.prototype.hasContent = function() {
        return this.getTitle();
    };
    Tooltip.prototype.getPosition = function($element) {
        $element = $element || this.$element;
        var el = $element[0];
        var isBody = el.tagName == "BODY";
        var elRect = el.getBoundingClientRect();
        if (elRect.width == null) {
            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
            elRect = $.extend({}, elRect, {
                width: elRect.right - elRect.left,
                height: elRect.bottom - elRect.top
            });
        }
        var elOffset = isBody ? {
            top: 0,
            left: 0
        } : $element.offset();
        var scroll = {
            scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop()
        };
        var outerDims = isBody ? {
            width: $(window).width(),
            height: $(window).height()
        } : null;
        return $.extend({}, elRect, scroll, outerDims, elOffset);
    };
    Tooltip.prototype.getCalculatedOffset = function(placement, pos, actualWidth, actualHeight) {
        /* placement == 'right' */
        return placement == "bottom" ? {
            top: pos.top + pos.height,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } : placement == "top" ? {
            top: pos.top - actualHeight,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } : placement == "left" ? {
            top: pos.top + pos.height / 2 - actualHeight / 2,
            left: pos.left - actualWidth
        } : {
            top: pos.top + pos.height / 2 - actualHeight / 2,
            left: pos.left + pos.width
        };
    };
    Tooltip.prototype.getViewportAdjustedDelta = function(placement, pos, actualWidth, actualHeight) {
        var delta = {
            top: 0,
            left: 0
        };
        if (!this.$viewport) return delta;
        var viewportPadding = this.options.viewport && this.options.viewport.padding || 0;
        var viewportDimensions = this.getPosition(this.$viewport);
        if (/right|left/.test(placement)) {
            var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll;
            var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;
            if (topEdgeOffset < viewportDimensions.top) {
                // top overflow
                delta.top = viewportDimensions.top - topEdgeOffset;
            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) {
                // bottom overflow
                delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;
            }
        } else {
            var leftEdgeOffset = pos.left - viewportPadding;
            var rightEdgeOffset = pos.left + viewportPadding + actualWidth;
            if (leftEdgeOffset < viewportDimensions.left) {
                // left overflow
                delta.left = viewportDimensions.left - leftEdgeOffset;
            } else if (rightEdgeOffset > viewportDimensions.width) {
                // right overflow
                delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;
            }
        }
        return delta;
    };
    Tooltip.prototype.getTitle = function() {
        var title;
        var $e = this.$element;
        var o = this.options;
        title = $e.attr("data-original-title") || (typeof o.title == "function" ? o.title.call($e[0]) : o.title);
        return title;
    };
    Tooltip.prototype.getUID = function(prefix) {
        do prefix += ~~(Math.random() * 1e6); while (document.getElementById(prefix));
        return prefix;
    };
    Tooltip.prototype.tip = function() {
        return this.$tip = this.$tip || $(this.options.template);
    };
    Tooltip.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow");
    };
    Tooltip.prototype.enable = function() {
        this.enabled = true;
    };
    Tooltip.prototype.disable = function() {
        this.enabled = false;
    };
    Tooltip.prototype.toggleEnabled = function() {
        this.enabled = !this.enabled;
    };
    Tooltip.prototype.toggle = function(e) {
        var self = this;
        if (e) {
            self = $(e.currentTarget).data("bs." + this.type);
            if (!self) {
                self = new this.constructor(e.currentTarget, this.getDelegateOptions());
                $(e.currentTarget).data("bs." + this.type, self);
            }
        }
        self.tip().hasClass("in") ? self.leave(self) : self.enter(self);
    };
    Tooltip.prototype.destroy = function() {
        var that = this;
        clearTimeout(this.timeout);
        this.hide(function() {
            that.$element.off("." + that.type).removeData("bs." + that.type);
        });
    };
    // TOOLTIP PLUGIN DEFINITION
    // =========================
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.tooltip");
            var options = typeof option == "object" && option;
            if (!data && option == "destroy") return;
            if (!data) $this.data("bs.tooltip", data = new Tooltip(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.tooltip;
    $.fn.tooltip = Plugin;
    $.fn.tooltip.Constructor = Tooltip;
    // TOOLTIP NO CONFLICT
    // ===================
    $.fn.tooltip.noConflict = function() {
        $.fn.tooltip = old;
        return this;
    };
}(jQuery);

/* ========================================================================
 * Bootstrap: popover.js v3.3.2
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function($) {
    "use strict";
    // POPOVER PUBLIC CLASS DEFINITION
    // ===============================
    var Popover = function(element, options) {
        this.init("popover", element, options);
    };
    if (!$.fn.tooltip) throw new Error("Popover requires tooltip.js");
    Popover.VERSION = "3.3.2";
    Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
        placement: "right",
        trigger: "click",
        content: "",
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    });
    // NOTE: POPOVER EXTENDS tooltip.js
    // ================================
    Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype);
    Popover.prototype.constructor = Popover;
    Popover.prototype.getDefaults = function() {
        return Popover.DEFAULTS;
    };
    Popover.prototype.setContent = function() {
        var $tip = this.tip();
        var title = this.getTitle();
        var content = this.getContent();
        $tip.find(".popover-title")[this.options.html ? "html" : "text"](title);
        $tip.find(".popover-content").children().detach().end()[// we use append for html objects to maintain js events
        this.options.html ? typeof content == "string" ? "html" : "append" : "text"](content);
        $tip.removeClass("fade top bottom left right in");
        // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
        // this manually by checking the contents.
        if (!$tip.find(".popover-title").html()) $tip.find(".popover-title").hide();
    };
    Popover.prototype.hasContent = function() {
        return this.getTitle() || this.getContent();
    };
    Popover.prototype.getContent = function() {
        var $e = this.$element;
        var o = this.options;
        return $e.attr("data-content") || (typeof o.content == "function" ? o.content.call($e[0]) : o.content);
    };
    Popover.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".arrow");
    };
    Popover.prototype.tip = function() {
        if (!this.$tip) this.$tip = $(this.options.template);
        return this.$tip;
    };
    // POPOVER PLUGIN DEFINITION
    // =========================
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.popover");
            var options = typeof option == "object" && option;
            if (!data && option == "destroy") return;
            if (!data) $this.data("bs.popover", data = new Popover(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.popover;
    $.fn.popover = Plugin;
    $.fn.popover.Constructor = Popover;
    // POPOVER NO CONFLICT
    // ===================
    $.fn.popover.noConflict = function() {
        $.fn.popover = old;
        return this;
    };
}(jQuery);

/* ========================================================================
 * Bootstrap: scrollspy.js v3.3.2
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function($) {
    "use strict";
    // SCROLLSPY CLASS DEFINITION
    // ==========================
    function ScrollSpy(element, options) {
        var process = $.proxy(this.process, this);
        this.$body = $("body");
        this.$scrollElement = $(element).is("body") ? $(window) : $(element);
        this.options = $.extend({}, ScrollSpy.DEFAULTS, options);
        this.selector = (this.options.target || "") + " .nav li > a";
        this.offsets = [];
        this.targets = [];
        this.activeTarget = null;
        this.scrollHeight = 0;
        this.$scrollElement.on("scroll.bs.scrollspy", process);
        this.refresh();
        this.process();
    }
    ScrollSpy.VERSION = "3.3.2";
    ScrollSpy.DEFAULTS = {
        offset: 10
    };
    ScrollSpy.prototype.getScrollHeight = function() {
        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight);
    };
    ScrollSpy.prototype.refresh = function() {
        var offsetMethod = "offset";
        var offsetBase = 0;
        if (!$.isWindow(this.$scrollElement[0])) {
            offsetMethod = "position";
            offsetBase = this.$scrollElement.scrollTop();
        }
        this.offsets = [];
        this.targets = [];
        this.scrollHeight = this.getScrollHeight();
        var self = this;
        this.$body.find(this.selector).map(function() {
            var $el = $(this);
            var href = $el.data("target") || $el.attr("href");
            var $href = /^#./.test(href) && $(href);
            return $href && $href.length && $href.is(":visible") && [ [ $href[offsetMethod]().top + offsetBase, href ] ] || null;
        }).sort(function(a, b) {
            return a[0] - b[0];
        }).each(function() {
            self.offsets.push(this[0]);
            self.targets.push(this[1]);
        });
    };
    ScrollSpy.prototype.process = function() {
        var scrollTop = this.$scrollElement.scrollTop() + this.options.offset;
        var scrollHeight = this.getScrollHeight();
        var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height();
        var offsets = this.offsets;
        var targets = this.targets;
        var activeTarget = this.activeTarget;
        var i;
        if (this.scrollHeight != scrollHeight) {
            this.refresh();
        }
        if (scrollTop >= maxScroll) {
            return activeTarget != (i = targets[targets.length - 1]) && this.activate(i);
        }
        if (activeTarget && scrollTop < offsets[0]) {
            this.activeTarget = null;
            return this.clear();
        }
        for (i = offsets.length; i--; ) {
            activeTarget != targets[i] && scrollTop >= offsets[i] && (!offsets[i + 1] || scrollTop <= offsets[i + 1]) && this.activate(targets[i]);
        }
    };
    ScrollSpy.prototype.activate = function(target) {
        this.activeTarget = target;
        this.clear();
        var selector = this.selector + '[data-target="' + target + '"],' + this.selector + '[href="' + target + '"]';
        var active = $(selector).parents("li").addClass("active");
        if (active.parent(".dropdown-menu").length) {
            active = active.closest("li.dropdown").addClass("active");
        }
        active.trigger("activate.bs.scrollspy");
    };
    ScrollSpy.prototype.clear = function() {
        $(this.selector).parentsUntil(this.options.target, ".active").removeClass("active");
    };
    // SCROLLSPY PLUGIN DEFINITION
    // ===========================
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.scrollspy");
            var options = typeof option == "object" && option;
            if (!data) $this.data("bs.scrollspy", data = new ScrollSpy(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.scrollspy;
    $.fn.scrollspy = Plugin;
    $.fn.scrollspy.Constructor = ScrollSpy;
    // SCROLLSPY NO CONFLICT
    // =====================
    $.fn.scrollspy.noConflict = function() {
        $.fn.scrollspy = old;
        return this;
    };
    // SCROLLSPY DATA-API
    // ==================
    $(window).on("load.bs.scrollspy.data-api", function() {
        $('[data-spy="scroll"]').each(function() {
            var $spy = $(this);
            Plugin.call($spy, $spy.data());
        });
    });
}(jQuery);

/* ========================================================================
 * Bootstrap: tab.js v3.3.2
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function($) {
    "use strict";
    // TAB CLASS DEFINITION
    // ====================
    var Tab = function(element) {
        this.element = $(element);
    };
    Tab.VERSION = "3.3.2";
    Tab.TRANSITION_DURATION = 150;
    Tab.prototype.show = function() {
        var $this = this.element;
        var $ul = $this.closest("ul:not(.dropdown-menu)");
        var selector = $this.data("target");
        if (!selector) {
            selector = $this.attr("href");
            selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "");
        }
        if ($this.parent("li").hasClass("active")) return;
        var $previous = $ul.find(".active:last a");
        var hideEvent = $.Event("hide.bs.tab", {
            relatedTarget: $this[0]
        });
        var showEvent = $.Event("show.bs.tab", {
            relatedTarget: $previous[0]
        });
        $previous.trigger(hideEvent);
        $this.trigger(showEvent);
        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return;
        var $target = $(selector);
        this.activate($this.closest("li"), $ul);
        this.activate($target, $target.parent(), function() {
            $previous.trigger({
                type: "hidden.bs.tab",
                relatedTarget: $this[0]
            });
            $this.trigger({
                type: "shown.bs.tab",
                relatedTarget: $previous[0]
            });
        });
    };
    Tab.prototype.activate = function(element, container, callback) {
        var $active = container.find("> .active");
        var transition = callback && $.support.transition && ($active.length && $active.hasClass("fade") || !!container.find("> .fade").length);
        function next() {
            $active.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", false);
            element.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", true);
            if (transition) {
                element[0].offsetWidth;
                // reflow for transition
                element.addClass("in");
            } else {
                element.removeClass("fade");
            }
            if (element.parent(".dropdown-menu")) {
                element.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", true);
            }
            callback && callback();
        }
        $active.length && transition ? $active.one("bsTransitionEnd", next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next();
        $active.removeClass("in");
    };
    // TAB PLUGIN DEFINITION
    // =====================
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.tab");
            if (!data) $this.data("bs.tab", data = new Tab(this));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.tab;
    $.fn.tab = Plugin;
    $.fn.tab.Constructor = Tab;
    // TAB NO CONFLICT
    // ===============
    $.fn.tab.noConflict = function() {
        $.fn.tab = old;
        return this;
    };
    // TAB DATA-API
    // ============
    var clickHandler = function(e) {
        e.preventDefault();
        Plugin.call($(this), "show");
    };
    $(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', clickHandler).on("click.bs.tab.data-api", '[data-toggle="pill"]', clickHandler);
}(jQuery);

/* ========================================================================
 * Bootstrap: affix.js v3.3.2
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function($) {
    "use strict";
    // AFFIX CLASS DEFINITION
    // ======================
    var Affix = function(element, options) {
        this.options = $.extend({}, Affix.DEFAULTS, options);
        this.$target = $(this.options.target).on("scroll.bs.affix.data-api", $.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", $.proxy(this.checkPositionWithEventLoop, this));
        this.$element = $(element);
        this.affixed = this.unpin = this.pinnedOffset = null;
        this.checkPosition();
    };
    Affix.VERSION = "3.3.2";
    Affix.RESET = "affix affix-top affix-bottom";
    Affix.DEFAULTS = {
        offset: 0,
        target: window
    };
    Affix.prototype.getState = function(scrollHeight, height, offsetTop, offsetBottom) {
        var scrollTop = this.$target.scrollTop();
        var position = this.$element.offset();
        var targetHeight = this.$target.height();
        if (offsetTop != null && this.affixed == "top") return scrollTop < offsetTop ? "top" : false;
        if (this.affixed == "bottom") {
            if (offsetTop != null) return scrollTop + this.unpin <= position.top ? false : "bottom";
            return scrollTop + targetHeight <= scrollHeight - offsetBottom ? false : "bottom";
        }
        var initializing = this.affixed == null;
        var colliderTop = initializing ? scrollTop : position.top;
        var colliderHeight = initializing ? targetHeight : height;
        if (offsetTop != null && scrollTop <= offsetTop) return "top";
        if (offsetBottom != null && colliderTop + colliderHeight >= scrollHeight - offsetBottom) return "bottom";
        return false;
    };
    Affix.prototype.getPinnedOffset = function() {
        if (this.pinnedOffset) return this.pinnedOffset;
        this.$element.removeClass(Affix.RESET).addClass("affix");
        var scrollTop = this.$target.scrollTop();
        var position = this.$element.offset();
        return this.pinnedOffset = position.top - scrollTop;
    };
    Affix.prototype.checkPositionWithEventLoop = function() {
        setTimeout($.proxy(this.checkPosition, this), 1);
    };
    Affix.prototype.checkPosition = function() {
        if (!this.$element.is(":visible")) return;
        var height = this.$element.height();
        var offset = this.options.offset;
        var offsetTop = offset.top;
        var offsetBottom = offset.bottom;
        var scrollHeight = $("body").height();
        if (typeof offset != "object") offsetBottom = offsetTop = offset;
        if (typeof offsetTop == "function") offsetTop = offset.top(this.$element);
        if (typeof offsetBottom == "function") offsetBottom = offset.bottom(this.$element);
        var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom);
        if (this.affixed != affix) {
            if (this.unpin != null) this.$element.css("top", "");
            var affixType = "affix" + (affix ? "-" + affix : "");
            var e = $.Event(affixType + ".bs.affix");
            this.$element.trigger(e);
            if (e.isDefaultPrevented()) return;
            this.affixed = affix;
            this.unpin = affix == "bottom" ? this.getPinnedOffset() : null;
            this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace("affix", "affixed") + ".bs.affix");
        }
        if (affix == "bottom") {
            this.$element.offset({
                top: scrollHeight - height - offsetBottom
            });
        }
    };
    // AFFIX PLUGIN DEFINITION
    // =======================
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.affix");
            var options = typeof option == "object" && option;
            if (!data) $this.data("bs.affix", data = new Affix(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.affix;
    $.fn.affix = Plugin;
    $.fn.affix.Constructor = Affix;
    // AFFIX NO CONFLICT
    // =================
    $.fn.affix.noConflict = function() {
        $.fn.affix = old;
        return this;
    };
    // AFFIX DATA-API
    // ==============
    $(window).on("load", function() {
        $('[data-spy="affix"]').each(function() {
            var $spy = $(this);
            var data = $spy.data();
            data.offset = data.offset || {};
            if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom;
            if (data.offsetTop != null) data.offset.top = data.offsetTop;
            Plugin.call($spy, data);
        });
    });
}(jQuery);

/*
 Leaflet, a JavaScript library for mobile-friendly interactive maps. http://leafletjs.com
 (c) 2010-2013, Vladimir Agafonkin
 (c) 2010-2011, CloudMade
*/
(function(window, document, undefined) {
    var oldL = window.L, L = {};
    L.version = "0.7.3";
    // define Leaflet for Node module pattern loaders, including Browserify
    if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = L;
    } else if (typeof define === "function" && define.amd) {
        define(L);
    }
    // define Leaflet as a global L variable, saving the original L to restore later if needed
    L.noConflict = function() {
        window.L = oldL;
        return this;
    };
    window.L = L;
    /*
 * L.Util contains various utility functions used throughout Leaflet code.
 */
    L.Util = {
        extend: function(dest) {
            // (Object[, Object, ...]) ->
            var sources = Array.prototype.slice.call(arguments, 1), i, j, len, src;
            for (j = 0, len = sources.length; j < len; j++) {
                src = sources[j] || {};
                for (i in src) {
                    if (src.hasOwnProperty(i)) {
                        dest[i] = src[i];
                    }
                }
            }
            return dest;
        },
        bind: function(fn, obj) {
            // (Function, Object) -> Function
            var args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;
            return function() {
                return fn.apply(obj, args || arguments);
            };
        },
        stamp: function() {
            var lastId = 0, key = "_leaflet_id";
            return function(obj) {
                obj[key] = obj[key] || ++lastId;
                return obj[key];
            };
        }(),
        invokeEach: function(obj, method, context) {
            var i, args;
            if (typeof obj === "object") {
                args = Array.prototype.slice.call(arguments, 3);
                for (i in obj) {
                    method.apply(context, [ i, obj[i] ].concat(args));
                }
                return true;
            }
            return false;
        },
        limitExecByInterval: function(fn, time, context) {
            var lock, execOnUnlock;
            return function wrapperFn() {
                var args = arguments;
                if (lock) {
                    execOnUnlock = true;
                    return;
                }
                lock = true;
                setTimeout(function() {
                    lock = false;
                    if (execOnUnlock) {
                        wrapperFn.apply(context, args);
                        execOnUnlock = false;
                    }
                }, time);
                fn.apply(context, args);
            };
        },
        falseFn: function() {
            return false;
        },
        formatNum: function(num, digits) {
            var pow = Math.pow(10, digits || 5);
            return Math.round(num * pow) / pow;
        },
        trim: function(str) {
            return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
        },
        splitWords: function(str) {
            return L.Util.trim(str).split(/\s+/);
        },
        setOptions: function(obj, options) {
            obj.options = L.extend({}, obj.options, options);
            return obj.options;
        },
        getParamString: function(obj, existingUrl, uppercase) {
            var params = [];
            for (var i in obj) {
                params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + "=" + encodeURIComponent(obj[i]));
            }
            return (!existingUrl || existingUrl.indexOf("?") === -1 ? "?" : "&") + params.join("&");
        },
        template: function(str, data) {
            return str.replace(/\{ *([\w_]+) *\}/g, function(str, key) {
                var value = data[key];
                if (value === undefined) {
                    throw new Error("No value provided for variable " + str);
                } else if (typeof value === "function") {
                    value = value(data);
                }
                return value;
            });
        },
        isArray: Array.isArray || function(obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
        },
        emptyImageUrl: "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="
    };
    (function() {
        // inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/
        function getPrefixed(name) {
            var i, fn, prefixes = [ "webkit", "moz", "o", "ms" ];
            for (i = 0; i < prefixes.length && !fn; i++) {
                fn = window[prefixes[i] + name];
            }
            return fn;
        }
        var lastTime = 0;
        function timeoutDefer(fn) {
            var time = +new Date(), timeToCall = Math.max(0, 16 - (time - lastTime));
            lastTime = time + timeToCall;
            return window.setTimeout(fn, timeToCall);
        }
        var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer;
        var cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id) {
            window.clearTimeout(id);
        };
        L.Util.requestAnimFrame = function(fn, context, immediate, element) {
            fn = L.bind(fn, context);
            if (immediate && requestFn === timeoutDefer) {
                fn();
            } else {
                return requestFn.call(window, fn, element);
            }
        };
        L.Util.cancelAnimFrame = function(id) {
            if (id) {
                cancelFn.call(window, id);
            }
        };
    })();
    // shortcuts for most used utility functions
    L.extend = L.Util.extend;
    L.bind = L.Util.bind;
    L.stamp = L.Util.stamp;
    L.setOptions = L.Util.setOptions;
    /*
 * L.Class powers the OOP facilities of the library.
 * Thanks to John Resig and Dean Edwards for inspiration!
 */
    L.Class = function() {};
    L.Class.extend = function(props) {
        // extended class with the new prototype
        var NewClass = function() {
            // call the constructor
            if (this.initialize) {
                this.initialize.apply(this, arguments);
            }
            // call all constructor hooks
            if (this._initHooks) {
                this.callInitHooks();
            }
        };
        // instantiate class without calling constructor
        var F = function() {};
        F.prototype = this.prototype;
        var proto = new F();
        proto.constructor = NewClass;
        NewClass.prototype = proto;
        //inherit parent's statics
        for (var i in this) {
            if (this.hasOwnProperty(i) && i !== "prototype") {
                NewClass[i] = this[i];
            }
        }
        // mix static properties into the class
        if (props.statics) {
            L.extend(NewClass, props.statics);
            delete props.statics;
        }
        // mix includes into the prototype
        if (props.includes) {
            L.Util.extend.apply(null, [ proto ].concat(props.includes));
            delete props.includes;
        }
        // merge options
        if (props.options && proto.options) {
            props.options = L.extend({}, proto.options, props.options);
        }
        // mix given properties into the prototype
        L.extend(proto, props);
        proto._initHooks = [];
        var parent = this;
        // jshint camelcase: false
        NewClass.__super__ = parent.prototype;
        // add method for calling all hooks
        proto.callInitHooks = function() {
            if (this._initHooksCalled) {
                return;
            }
            if (parent.prototype.callInitHooks) {
                parent.prototype.callInitHooks.call(this);
            }
            this._initHooksCalled = true;
            for (var i = 0, len = proto._initHooks.length; i < len; i++) {
                proto._initHooks[i].call(this);
            }
        };
        return NewClass;
    };
    // method for adding properties to prototype
    L.Class.include = function(props) {
        L.extend(this.prototype, props);
    };
    // merge new default options to the Class
    L.Class.mergeOptions = function(options) {
        L.extend(this.prototype.options, options);
    };
    // add a constructor hook
    L.Class.addInitHook = function(fn) {
        // (Function) || (String, args...)
        var args = Array.prototype.slice.call(arguments, 1);
        var init = typeof fn === "function" ? fn : function() {
            this[fn].apply(this, args);
        };
        this.prototype._initHooks = this.prototype._initHooks || [];
        this.prototype._initHooks.push(init);
    };
    /*
 * L.Mixin.Events is used to add custom events functionality to Leaflet classes.
 */
    var eventsKey = "_leaflet_events";
    L.Mixin = {};
    L.Mixin.Events = {
        addEventListener: function(types, fn, context) {
            // (String, Function[, Object]) or (Object[, Object])
            // types can be a map of types/handlers
            if (L.Util.invokeEach(types, this.addEventListener, this, fn, context)) {
                return this;
            }
            var events = this[eventsKey] = this[eventsKey] || {}, contextId = context && context !== this && L.stamp(context), i, len, event, type, indexKey, indexLenKey, typeIndex;
            // types can be a string of space-separated words
            types = L.Util.splitWords(types);
            for (i = 0, len = types.length; i < len; i++) {
                event = {
                    action: fn,
                    context: context || this
                };
                type = types[i];
                if (contextId) {
                    // store listeners of a particular context in a separate hash (if it has an id)
                    // gives a major performance boost when removing thousands of map layers
                    indexKey = type + "_idx";
                    indexLenKey = indexKey + "_len";
                    typeIndex = events[indexKey] = events[indexKey] || {};
                    if (!typeIndex[contextId]) {
                        typeIndex[contextId] = [];
                        // keep track of the number of keys in the index to quickly check if it's empty
                        events[indexLenKey] = (events[indexLenKey] || 0) + 1;
                    }
                    typeIndex[contextId].push(event);
                } else {
                    events[type] = events[type] || [];
                    events[type].push(event);
                }
            }
            return this;
        },
        hasEventListeners: function(type) {
            // (String) -> Boolean
            var events = this[eventsKey];
            return !!events && (type in events && events[type].length > 0 || type + "_idx" in events && events[type + "_idx_len"] > 0);
        },
        removeEventListener: function(types, fn, context) {
            // ([String, Function, Object]) or (Object[, Object])
            if (!this[eventsKey]) {
                return this;
            }
            if (!types) {
                return this.clearAllEventListeners();
            }
            if (L.Util.invokeEach(types, this.removeEventListener, this, fn, context)) {
                return this;
            }
            var events = this[eventsKey], contextId = context && context !== this && L.stamp(context), i, len, type, listeners, j, indexKey, indexLenKey, typeIndex, removed;
            types = L.Util.splitWords(types);
            for (i = 0, len = types.length; i < len; i++) {
                type = types[i];
                indexKey = type + "_idx";
                indexLenKey = indexKey + "_len";
                typeIndex = events[indexKey];
                if (!fn) {
                    // clear all listeners for a type if function isn't specified
                    delete events[type];
                    delete events[indexKey];
                    delete events[indexLenKey];
                } else {
                    listeners = contextId && typeIndex ? typeIndex[contextId] : events[type];
                    if (listeners) {
                        for (j = listeners.length - 1; j >= 0; j--) {
                            if (listeners[j].action === fn && (!context || listeners[j].context === context)) {
                                removed = listeners.splice(j, 1);
                                // set the old action to a no-op, because it is possible
                                // that the listener is being iterated over as part of a dispatch
                                removed[0].action = L.Util.falseFn;
                            }
                        }
                        if (context && typeIndex && listeners.length === 0) {
                            delete typeIndex[contextId];
                            events[indexLenKey]--;
                        }
                    }
                }
            }
            return this;
        },
        clearAllEventListeners: function() {
            delete this[eventsKey];
            return this;
        },
        fireEvent: function(type, data) {
            // (String[, Object])
            if (!this.hasEventListeners(type)) {
                return this;
            }
            var event = L.Util.extend({}, data, {
                type: type,
                target: this
            });
            var events = this[eventsKey], listeners, i, len, typeIndex, contextId;
            if (events[type]) {
                // make sure adding/removing listeners inside other listeners won't cause infinite loop
                listeners = events[type].slice();
                for (i = 0, len = listeners.length; i < len; i++) {
                    listeners[i].action.call(listeners[i].context, event);
                }
            }
            // fire event for the context-indexed listeners as well
            typeIndex = events[type + "_idx"];
            for (contextId in typeIndex) {
                listeners = typeIndex[contextId].slice();
                if (listeners) {
                    for (i = 0, len = listeners.length; i < len; i++) {
                        listeners[i].action.call(listeners[i].context, event);
                    }
                }
            }
            return this;
        },
        addOneTimeEventListener: function(types, fn, context) {
            if (L.Util.invokeEach(types, this.addOneTimeEventListener, this, fn, context)) {
                return this;
            }
            var handler = L.bind(function() {
                this.removeEventListener(types, fn, context).removeEventListener(types, handler, context);
            }, this);
            return this.addEventListener(types, fn, context).addEventListener(types, handler, context);
        }
    };
    L.Mixin.Events.on = L.Mixin.Events.addEventListener;
    L.Mixin.Events.off = L.Mixin.Events.removeEventListener;
    L.Mixin.Events.once = L.Mixin.Events.addOneTimeEventListener;
    L.Mixin.Events.fire = L.Mixin.Events.fireEvent;
    /*
 * L.Browser handles different browser and feature detections for internal Leaflet use.
 */
    (function() {
        var ie = "ActiveXObject" in window, ielt9 = ie && !document.addEventListener, // terrible browser detection to work around Safari / iOS / Android browser bugs
        ua = navigator.userAgent.toLowerCase(), webkit = ua.indexOf("webkit") !== -1, chrome = ua.indexOf("chrome") !== -1, phantomjs = ua.indexOf("phantom") !== -1, android = ua.indexOf("android") !== -1, android23 = ua.search("android [23]") !== -1, gecko = ua.indexOf("gecko") !== -1, mobile = typeof orientation !== undefined + "", msPointer = window.navigator && window.navigator.msPointerEnabled && window.navigator.msMaxTouchPoints && !window.PointerEvent, pointer = window.PointerEvent && window.navigator.pointerEnabled && window.navigator.maxTouchPoints || msPointer, retina = "devicePixelRatio" in window && window.devicePixelRatio > 1 || "matchMedia" in window && window.matchMedia("(min-resolution:144dpi)") && window.matchMedia("(min-resolution:144dpi)").matches, doc = document.documentElement, ie3d = ie && "transition" in doc.style, webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !android23, gecko3d = "MozPerspective" in doc.style, opera3d = "OTransition" in doc.style, any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d || opera3d) && !phantomjs;
        // PhantomJS has 'ontouchstart' in document.documentElement, but doesn't actually support touch.
        // https://github.com/Leaflet/Leaflet/pull/1434#issuecomment-13843151
        var touch = !window.L_NO_TOUCH && !phantomjs && function() {
            var startName = "ontouchstart";
            // IE10+ (We simulate these into touch* events in L.DomEvent and L.DomEvent.Pointer) or WebKit, etc.
            if (pointer || startName in doc) {
                return true;
            }
            // Firefox/Gecko
            var div = document.createElement("div"), supported = false;
            if (!div.setAttribute) {
                return false;
            }
            div.setAttribute(startName, "return;");
            if (typeof div[startName] === "function") {
                supported = true;
            }
            div.removeAttribute(startName);
            div = null;
            return supported;
        }();
        L.Browser = {
            ie: ie,
            ielt9: ielt9,
            webkit: webkit,
            gecko: gecko && !webkit && !window.opera && !ie,
            android: android,
            android23: android23,
            chrome: chrome,
            ie3d: ie3d,
            webkit3d: webkit3d,
            gecko3d: gecko3d,
            opera3d: opera3d,
            any3d: any3d,
            mobile: mobile,
            mobileWebkit: mobile && webkit,
            mobileWebkit3d: mobile && webkit3d,
            mobileOpera: mobile && window.opera,
            touch: touch,
            msPointer: msPointer,
            pointer: pointer,
            retina: retina
        };
    })();
    /*
 * L.Point represents a point with x and y coordinates.
 */
    L.Point = function(/*Number*/ x, /*Number*/ y, /*Boolean*/ round) {
        this.x = round ? Math.round(x) : x;
        this.y = round ? Math.round(y) : y;
    };
    L.Point.prototype = {
        clone: function() {
            return new L.Point(this.x, this.y);
        },
        // non-destructive, returns a new point
        add: function(point) {
            return this.clone()._add(L.point(point));
        },
        // destructive, used directly for performance in situations where it's safe to modify existing point
        _add: function(point) {
            this.x += point.x;
            this.y += point.y;
            return this;
        },
        subtract: function(point) {
            return this.clone()._subtract(L.point(point));
        },
        _subtract: function(point) {
            this.x -= point.x;
            this.y -= point.y;
            return this;
        },
        divideBy: function(num) {
            return this.clone()._divideBy(num);
        },
        _divideBy: function(num) {
            this.x /= num;
            this.y /= num;
            return this;
        },
        multiplyBy: function(num) {
            return this.clone()._multiplyBy(num);
        },
        _multiplyBy: function(num) {
            this.x *= num;
            this.y *= num;
            return this;
        },
        round: function() {
            return this.clone()._round();
        },
        _round: function() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
        },
        floor: function() {
            return this.clone()._floor();
        },
        _floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this;
        },
        distanceTo: function(point) {
            point = L.point(point);
            var x = point.x - this.x, y = point.y - this.y;
            return Math.sqrt(x * x + y * y);
        },
        equals: function(point) {
            point = L.point(point);
            return point.x === this.x && point.y === this.y;
        },
        contains: function(point) {
            point = L.point(point);
            return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
        },
        toString: function() {
            return "Point(" + L.Util.formatNum(this.x) + ", " + L.Util.formatNum(this.y) + ")";
        }
    };
    L.point = function(x, y, round) {
        if (x instanceof L.Point) {
            return x;
        }
        if (L.Util.isArray(x)) {
            return new L.Point(x[0], x[1]);
        }
        if (x === undefined || x === null) {
            return x;
        }
        return new L.Point(x, y, round);
    };
    /*
 * L.Bounds represents a rectangular area on the screen in pixel coordinates.
 */
    L.Bounds = function(a, b) {
        //(Point, Point) or Point[]
        if (!a) {
            return;
        }
        var points = b ? [ a, b ] : a;
        for (var i = 0, len = points.length; i < len; i++) {
            this.extend(points[i]);
        }
    };
    L.Bounds.prototype = {
        // extend the bounds to contain the given point
        extend: function(point) {
            // (Point)
            point = L.point(point);
            if (!this.min && !this.max) {
                this.min = point.clone();
                this.max = point.clone();
            } else {
                this.min.x = Math.min(point.x, this.min.x);
                this.max.x = Math.max(point.x, this.max.x);
                this.min.y = Math.min(point.y, this.min.y);
                this.max.y = Math.max(point.y, this.max.y);
            }
            return this;
        },
        getCenter: function(round) {
            // (Boolean) -> Point
            return new L.Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);
        },
        getBottomLeft: function() {
            // -> Point
            return new L.Point(this.min.x, this.max.y);
        },
        getTopRight: function() {
            // -> Point
            return new L.Point(this.max.x, this.min.y);
        },
        getSize: function() {
            return this.max.subtract(this.min);
        },
        contains: function(obj) {
            // (Bounds) or (Point) -> Boolean
            var min, max;
            if (typeof obj[0] === "number" || obj instanceof L.Point) {
                obj = L.point(obj);
            } else {
                obj = L.bounds(obj);
            }
            if (obj instanceof L.Bounds) {
                min = obj.min;
                max = obj.max;
            } else {
                min = max = obj;
            }
            return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
        },
        intersects: function(bounds) {
            // (Bounds) -> Boolean
            bounds = L.bounds(bounds);
            var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xIntersects = max2.x >= min.x && min2.x <= max.x, yIntersects = max2.y >= min.y && min2.y <= max.y;
            return xIntersects && yIntersects;
        },
        isValid: function() {
            return !!(this.min && this.max);
        }
    };
    L.bounds = function(a, b) {
        // (Bounds) or (Point, Point) or (Point[])
        if (!a || a instanceof L.Bounds) {
            return a;
        }
        return new L.Bounds(a, b);
    };
    /*
 * L.Transformation is an utility class to perform simple point transformations through a 2d-matrix.
 */
    L.Transformation = function(a, b, c, d) {
        this._a = a;
        this._b = b;
        this._c = c;
        this._d = d;
    };
    L.Transformation.prototype = {
        transform: function(point, scale) {
            // (Point, Number) -> Point
            return this._transform(point.clone(), scale);
        },
        // destructive transform (faster)
        _transform: function(point, scale) {
            scale = scale || 1;
            point.x = scale * (this._a * point.x + this._b);
            point.y = scale * (this._c * point.y + this._d);
            return point;
        },
        untransform: function(point, scale) {
            scale = scale || 1;
            return new L.Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);
        }
    };
    /*
 * L.DomUtil contains various utility functions for working with DOM.
 */
    L.DomUtil = {
        get: function(id) {
            return typeof id === "string" ? document.getElementById(id) : id;
        },
        getStyle: function(el, style) {
            var value = el.style[style];
            if (!value && el.currentStyle) {
                value = el.currentStyle[style];
            }
            if ((!value || value === "auto") && document.defaultView) {
                var css = document.defaultView.getComputedStyle(el, null);
                value = css ? css[style] : null;
            }
            return value === "auto" ? null : value;
        },
        getViewportOffset: function(element) {
            var top = 0, left = 0, el = element, docBody = document.body, docEl = document.documentElement, pos;
            do {
                top += el.offsetTop || 0;
                left += el.offsetLeft || 0;
                //add borders
                top += parseInt(L.DomUtil.getStyle(el, "borderTopWidth"), 10) || 0;
                left += parseInt(L.DomUtil.getStyle(el, "borderLeftWidth"), 10) || 0;
                pos = L.DomUtil.getStyle(el, "position");
                if (el.offsetParent === docBody && pos === "absolute") {
                    break;
                }
                if (pos === "fixed") {
                    top += docBody.scrollTop || docEl.scrollTop || 0;
                    left += docBody.scrollLeft || docEl.scrollLeft || 0;
                    break;
                }
                if (pos === "relative" && !el.offsetLeft) {
                    var width = L.DomUtil.getStyle(el, "width"), maxWidth = L.DomUtil.getStyle(el, "max-width"), r = el.getBoundingClientRect();
                    if (width !== "none" || maxWidth !== "none") {
                        left += r.left + el.clientLeft;
                    }
                    //calculate full y offset since we're breaking out of the loop
                    top += r.top + (docBody.scrollTop || docEl.scrollTop || 0);
                    break;
                }
                el = el.offsetParent;
            } while (el);
            el = element;
            do {
                if (el === docBody) {
                    break;
                }
                top -= el.scrollTop || 0;
                left -= el.scrollLeft || 0;
                el = el.parentNode;
            } while (el);
            return new L.Point(left, top);
        },
        documentIsLtr: function() {
            if (!L.DomUtil._docIsLtrCached) {
                L.DomUtil._docIsLtrCached = true;
                L.DomUtil._docIsLtr = L.DomUtil.getStyle(document.body, "direction") === "ltr";
            }
            return L.DomUtil._docIsLtr;
        },
        create: function(tagName, className, container) {
            var el = document.createElement(tagName);
            el.className = className;
            if (container) {
                container.appendChild(el);
            }
            return el;
        },
        hasClass: function(el, name) {
            if (el.classList !== undefined) {
                return el.classList.contains(name);
            }
            var className = L.DomUtil._getClass(el);
            return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
        },
        addClass: function(el, name) {
            if (el.classList !== undefined) {
                var classes = L.Util.splitWords(name);
                for (var i = 0, len = classes.length; i < len; i++) {
                    el.classList.add(classes[i]);
                }
            } else if (!L.DomUtil.hasClass(el, name)) {
                var className = L.DomUtil._getClass(el);
                L.DomUtil._setClass(el, (className ? className + " " : "") + name);
            }
        },
        removeClass: function(el, name) {
            if (el.classList !== undefined) {
                el.classList.remove(name);
            } else {
                L.DomUtil._setClass(el, L.Util.trim((" " + L.DomUtil._getClass(el) + " ").replace(" " + name + " ", " ")));
            }
        },
        _setClass: function(el, name) {
            if (el.className.baseVal === undefined) {
                el.className = name;
            } else {
                // in case of SVG element
                el.className.baseVal = name;
            }
        },
        _getClass: function(el) {
            return el.className.baseVal === undefined ? el.className : el.className.baseVal;
        },
        setOpacity: function(el, value) {
            if ("opacity" in el.style) {
                el.style.opacity = value;
            } else if ("filter" in el.style) {
                var filter = false, filterName = "DXImageTransform.Microsoft.Alpha";
                // filters collection throws an error if we try to retrieve a filter that doesn't exist
                try {
                    filter = el.filters.item(filterName);
                } catch (e) {
                    // don't set opacity to 1 if we haven't already set an opacity,
                    // it isn't needed and breaks transparent pngs.
                    if (value === 1) {
                        return;
                    }
                }
                value = Math.round(value * 100);
                if (filter) {
                    filter.Enabled = value !== 100;
                    filter.Opacity = value;
                } else {
                    el.style.filter += " progid:" + filterName + "(opacity=" + value + ")";
                }
            }
        },
        testProp: function(props) {
            var style = document.documentElement.style;
            for (var i = 0; i < props.length; i++) {
                if (props[i] in style) {
                    return props[i];
                }
            }
            return false;
        },
        getTranslateString: function(point) {
            // on WebKit browsers (Chrome/Safari/iOS Safari/Android) using translate3d instead of translate
            // makes animation smoother as it ensures HW accel is used. Firefox 13 doesn't care
            // (same speed either way), Opera 12 doesn't support translate3d
            var is3d = L.Browser.webkit3d, open = "translate" + (is3d ? "3d" : "") + "(", close = (is3d ? ",0" : "") + ")";
            return open + point.x + "px," + point.y + "px" + close;
        },
        getScaleString: function(scale, origin) {
            var preTranslateStr = L.DomUtil.getTranslateString(origin.add(origin.multiplyBy(-1 * scale))), scaleStr = " scale(" + scale + ") ";
            return preTranslateStr + scaleStr;
        },
        setPosition: function(el, point, disable3D) {
            // (HTMLElement, Point[, Boolean])
            // jshint camelcase: false
            el._leaflet_pos = point;
            if (!disable3D && L.Browser.any3d) {
                el.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(point);
            } else {
                el.style.left = point.x + "px";
                el.style.top = point.y + "px";
            }
        },
        getPosition: function(el) {
            // this method is only used for elements previously positioned using setPosition,
            // so it's safe to cache the position for performance
            // jshint camelcase: false
            return el._leaflet_pos;
        }
    };
    // prefix style property names
    L.DomUtil.TRANSFORM = L.DomUtil.testProp([ "transform", "WebkitTransform", "OTransform", "MozTransform", "msTransform" ]);
    // webkitTransition comes first because some browser versions that drop vendor prefix don't do
    // the same for the transitionend event, in particular the Android 4.1 stock browser
    L.DomUtil.TRANSITION = L.DomUtil.testProp([ "webkitTransition", "transition", "OTransition", "MozTransition", "msTransition" ]);
    L.DomUtil.TRANSITION_END = L.DomUtil.TRANSITION === "webkitTransition" || L.DomUtil.TRANSITION === "OTransition" ? L.DomUtil.TRANSITION + "End" : "transitionend";
    (function() {
        if ("onselectstart" in document) {
            L.extend(L.DomUtil, {
                disableTextSelection: function() {
                    L.DomEvent.on(window, "selectstart", L.DomEvent.preventDefault);
                },
                enableTextSelection: function() {
                    L.DomEvent.off(window, "selectstart", L.DomEvent.preventDefault);
                }
            });
        } else {
            var userSelectProperty = L.DomUtil.testProp([ "userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect" ]);
            L.extend(L.DomUtil, {
                disableTextSelection: function() {
                    if (userSelectProperty) {
                        var style = document.documentElement.style;
                        this._userSelect = style[userSelectProperty];
                        style[userSelectProperty] = "none";
                    }
                },
                enableTextSelection: function() {
                    if (userSelectProperty) {
                        document.documentElement.style[userSelectProperty] = this._userSelect;
                        delete this._userSelect;
                    }
                }
            });
        }
        L.extend(L.DomUtil, {
            disableImageDrag: function() {
                L.DomEvent.on(window, "dragstart", L.DomEvent.preventDefault);
            },
            enableImageDrag: function() {
                L.DomEvent.off(window, "dragstart", L.DomEvent.preventDefault);
            }
        });
    })();
    /*
 * L.LatLng represents a geographical point with latitude and longitude coordinates.
 */
    L.LatLng = function(lat, lng, alt) {
        // (Number, Number, Number)
        lat = parseFloat(lat);
        lng = parseFloat(lng);
        if (isNaN(lat) || isNaN(lng)) {
            throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
        }
        this.lat = lat;
        this.lng = lng;
        if (alt !== undefined) {
            this.alt = parseFloat(alt);
        }
    };
    L.extend(L.LatLng, {
        DEG_TO_RAD: Math.PI / 180,
        RAD_TO_DEG: 180 / Math.PI,
        MAX_MARGIN: 1e-9
    });
    L.LatLng.prototype = {
        equals: function(obj) {
            // (LatLng) -> Boolean
            if (!obj) {
                return false;
            }
            obj = L.latLng(obj);
            var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));
            return margin <= L.LatLng.MAX_MARGIN;
        },
        toString: function(precision) {
            // (Number) -> String
            return "LatLng(" + L.Util.formatNum(this.lat, precision) + ", " + L.Util.formatNum(this.lng, precision) + ")";
        },
        // Haversine distance formula, see http://en.wikipedia.org/wiki/Haversine_formula
        // TODO move to projection code, LatLng shouldn't know about Earth
        distanceTo: function(other) {
            // (LatLng) -> Number
            other = L.latLng(other);
            var R = 6378137, // earth radius in meters
            d2r = L.LatLng.DEG_TO_RAD, dLat = (other.lat - this.lat) * d2r, dLon = (other.lng - this.lng) * d2r, lat1 = this.lat * d2r, lat2 = other.lat * d2r, sin1 = Math.sin(dLat / 2), sin2 = Math.sin(dLon / 2);
            var a = sin1 * sin1 + sin2 * sin2 * Math.cos(lat1) * Math.cos(lat2);
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        },
        wrap: function(a, b) {
            // (Number, Number) -> LatLng
            var lng = this.lng;
            a = a || -180;
            b = b || 180;
            lng = (lng + b) % (b - a) + (lng < a || lng === b ? b : a);
            return new L.LatLng(this.lat, lng);
        }
    };
    L.latLng = function(a, b) {
        // (LatLng) or ([Number, Number]) or (Number, Number)
        if (a instanceof L.LatLng) {
            return a;
        }
        if (L.Util.isArray(a)) {
            if (typeof a[0] === "number" || typeof a[0] === "string") {
                return new L.LatLng(a[0], a[1], a[2]);
            } else {
                return null;
            }
        }
        if (a === undefined || a === null) {
            return a;
        }
        if (typeof a === "object" && "lat" in a) {
            return new L.LatLng(a.lat, "lng" in a ? a.lng : a.lon);
        }
        if (b === undefined) {
            return null;
        }
        return new L.LatLng(a, b);
    };
    /*
 * L.LatLngBounds represents a rectangular area on the map in geographical coordinates.
 */
    L.LatLngBounds = function(southWest, northEast) {
        // (LatLng, LatLng) or (LatLng[])
        if (!southWest) {
            return;
        }
        var latlngs = northEast ? [ southWest, northEast ] : southWest;
        for (var i = 0, len = latlngs.length; i < len; i++) {
            this.extend(latlngs[i]);
        }
    };
    L.LatLngBounds.prototype = {
        // extend the bounds to contain the given point or bounds
        extend: function(obj) {
            // (LatLng) or (LatLngBounds)
            if (!obj) {
                return this;
            }
            var latLng = L.latLng(obj);
            if (latLng !== null) {
                obj = latLng;
            } else {
                obj = L.latLngBounds(obj);
            }
            if (obj instanceof L.LatLng) {
                if (!this._southWest && !this._northEast) {
                    this._southWest = new L.LatLng(obj.lat, obj.lng);
                    this._northEast = new L.LatLng(obj.lat, obj.lng);
                } else {
                    this._southWest.lat = Math.min(obj.lat, this._southWest.lat);
                    this._southWest.lng = Math.min(obj.lng, this._southWest.lng);
                    this._northEast.lat = Math.max(obj.lat, this._northEast.lat);
                    this._northEast.lng = Math.max(obj.lng, this._northEast.lng);
                }
            } else if (obj instanceof L.LatLngBounds) {
                this.extend(obj._southWest);
                this.extend(obj._northEast);
            }
            return this;
        },
        // extend the bounds by a percentage
        pad: function(bufferRatio) {
            // (Number) -> LatLngBounds
            var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
            return new L.LatLngBounds(new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
        },
        getCenter: function() {
            // -> LatLng
            return new L.LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);
        },
        getSouthWest: function() {
            return this._southWest;
        },
        getNorthEast: function() {
            return this._northEast;
        },
        getNorthWest: function() {
            return new L.LatLng(this.getNorth(), this.getWest());
        },
        getSouthEast: function() {
            return new L.LatLng(this.getSouth(), this.getEast());
        },
        getWest: function() {
            return this._southWest.lng;
        },
        getSouth: function() {
            return this._southWest.lat;
        },
        getEast: function() {
            return this._northEast.lng;
        },
        getNorth: function() {
            return this._northEast.lat;
        },
        contains: function(obj) {
            // (LatLngBounds) or (LatLng) -> Boolean
            if (typeof obj[0] === "number" || obj instanceof L.LatLng) {
                obj = L.latLng(obj);
            } else {
                obj = L.latLngBounds(obj);
            }
            var sw = this._southWest, ne = this._northEast, sw2, ne2;
            if (obj instanceof L.LatLngBounds) {
                sw2 = obj.getSouthWest();
                ne2 = obj.getNorthEast();
            } else {
                sw2 = ne2 = obj;
            }
            return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
        },
        intersects: function(bounds) {
            // (LatLngBounds)
            bounds = L.latLngBounds(bounds);
            var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat, lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
            return latIntersects && lngIntersects;
        },
        toBBoxString: function() {
            return [ this.getWest(), this.getSouth(), this.getEast(), this.getNorth() ].join(",");
        },
        equals: function(bounds) {
            // (LatLngBounds)
            if (!bounds) {
                return false;
            }
            bounds = L.latLngBounds(bounds);
            return this._southWest.equals(bounds.getSouthWest()) && this._northEast.equals(bounds.getNorthEast());
        },
        isValid: function() {
            return !!(this._southWest && this._northEast);
        }
    };
    //TODO International date line?
    L.latLngBounds = function(a, b) {
        // (LatLngBounds) or (LatLng, LatLng)
        if (!a || a instanceof L.LatLngBounds) {
            return a;
        }
        return new L.LatLngBounds(a, b);
    };
    /*
 * L.Projection contains various geographical projections used by CRS classes.
 */
    L.Projection = {};
    /*
 * Spherical Mercator is the most popular map projection, used by EPSG:3857 CRS used by default.
 */
    L.Projection.SphericalMercator = {
        MAX_LATITUDE: 85.0511287798,
        project: function(latlng) {
            // (LatLng) -> Point
            var d = L.LatLng.DEG_TO_RAD, max = this.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), x = latlng.lng * d, y = lat * d;
            y = Math.log(Math.tan(Math.PI / 4 + y / 2));
            return new L.Point(x, y);
        },
        unproject: function(point) {
            // (Point, Boolean) -> LatLng
            var d = L.LatLng.RAD_TO_DEG, lng = point.x * d, lat = (2 * Math.atan(Math.exp(point.y)) - Math.PI / 2) * d;
            return new L.LatLng(lat, lng);
        }
    };
    /*
 * Simple equirectangular (Plate Carree) projection, used by CRS like EPSG:4326 and Simple.
 */
    L.Projection.LonLat = {
        project: function(latlng) {
            return new L.Point(latlng.lng, latlng.lat);
        },
        unproject: function(point) {
            return new L.LatLng(point.y, point.x);
        }
    };
    /*
 * L.CRS is a base object for all defined CRS (Coordinate Reference Systems) in Leaflet.
 */
    L.CRS = {
        latLngToPoint: function(latlng, zoom) {
            // (LatLng, Number) -> Point
            var projectedPoint = this.projection.project(latlng), scale = this.scale(zoom);
            return this.transformation._transform(projectedPoint, scale);
        },
        pointToLatLng: function(point, zoom) {
            // (Point, Number[, Boolean]) -> LatLng
            var scale = this.scale(zoom), untransformedPoint = this.transformation.untransform(point, scale);
            return this.projection.unproject(untransformedPoint);
        },
        project: function(latlng) {
            return this.projection.project(latlng);
        },
        scale: function(zoom) {
            return 256 * Math.pow(2, zoom);
        },
        getSize: function(zoom) {
            var s = this.scale(zoom);
            return L.point(s, s);
        }
    };
    /*
 * A simple CRS that can be used for flat non-Earth maps like panoramas or game maps.
 */
    L.CRS.Simple = L.extend({}, L.CRS, {
        projection: L.Projection.LonLat,
        transformation: new L.Transformation(1, 0, -1, 0),
        scale: function(zoom) {
            return Math.pow(2, zoom);
        }
    });
    /*
 * L.CRS.EPSG3857 (Spherical Mercator) is the most common CRS for web mapping
 * and is used by Leaflet by default.
 */
    L.CRS.EPSG3857 = L.extend({}, L.CRS, {
        code: "EPSG:3857",
        projection: L.Projection.SphericalMercator,
        transformation: new L.Transformation(.5 / Math.PI, .5, -.5 / Math.PI, .5),
        project: function(latlng) {
            // (LatLng) -> Point
            var projectedPoint = this.projection.project(latlng), earthRadius = 6378137;
            return projectedPoint.multiplyBy(earthRadius);
        }
    });
    L.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {
        code: "EPSG:900913"
    });
    /*
 * L.CRS.EPSG4326 is a CRS popular among advanced GIS specialists.
 */
    L.CRS.EPSG4326 = L.extend({}, L.CRS, {
        code: "EPSG:4326",
        projection: L.Projection.LonLat,
        transformation: new L.Transformation(1 / 360, .5, -1 / 360, .5)
    });
    /*
 * L.Map is the central class of the API - it is used to create a map.
 */
    L.Map = L.Class.extend({
        includes: L.Mixin.Events,
        options: {
            crs: L.CRS.EPSG3857,
            /*
		center: LatLng,
		zoom: Number,
		layers: Array,
		*/
            fadeAnimation: L.DomUtil.TRANSITION && !L.Browser.android23,
            trackResize: true,
            markerZoomAnimation: L.DomUtil.TRANSITION && L.Browser.any3d
        },
        initialize: function(id, options) {
            // (HTMLElement or String, Object)
            options = L.setOptions(this, options);
            this._initContainer(id);
            this._initLayout();
            // hack for https://github.com/Leaflet/Leaflet/issues/1980
            this._onResize = L.bind(this._onResize, this);
            this._initEvents();
            if (options.maxBounds) {
                this.setMaxBounds(options.maxBounds);
            }
            if (options.center && options.zoom !== undefined) {
                this.setView(L.latLng(options.center), options.zoom, {
                    reset: true
                });
            }
            this._handlers = [];
            this._layers = {};
            this._zoomBoundLayers = {};
            this._tileLayersNum = 0;
            this.callInitHooks();
            this._addLayers(options.layers);
        },
        // public methods that modify map state
        // replaced by animation-powered implementation in Map.PanAnimation.js
        setView: function(center, zoom) {
            zoom = zoom === undefined ? this.getZoom() : zoom;
            this._resetView(L.latLng(center), this._limitZoom(zoom));
            return this;
        },
        setZoom: function(zoom, options) {
            if (!this._loaded) {
                this._zoom = this._limitZoom(zoom);
                return this;
            }
            return this.setView(this.getCenter(), zoom, {
                zoom: options
            });
        },
        zoomIn: function(delta, options) {
            return this.setZoom(this._zoom + (delta || 1), options);
        },
        zoomOut: function(delta, options) {
            return this.setZoom(this._zoom - (delta || 1), options);
        },
        setZoomAround: function(latlng, zoom, options) {
            var scale = this.getZoomScale(zoom), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
            return this.setView(newCenter, zoom, {
                zoom: options
            });
        },
        fitBounds: function(bounds, options) {
            options = options || {};
            bounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);
            var paddingTL = L.point(options.paddingTopLeft || options.padding || [ 0, 0 ]), paddingBR = L.point(options.paddingBottomRight || options.padding || [ 0, 0 ]), zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR)), paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds.getSouthWest(), zoom), nePoint = this.project(bounds.getNorthEast(), zoom), center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);
            zoom = options && options.maxZoom ? Math.min(options.maxZoom, zoom) : zoom;
            return this.setView(center, zoom, options);
        },
        fitWorld: function(options) {
            return this.fitBounds([ [ -90, -180 ], [ 90, 180 ] ], options);
        },
        panTo: function(center, options) {
            // (LatLng)
            return this.setView(center, this._zoom, {
                pan: options
            });
        },
        panBy: function(offset) {
            // (Point)
            // replaced with animated panBy in Map.PanAnimation.js
            this.fire("movestart");
            this._rawPanBy(L.point(offset));
            this.fire("move");
            return this.fire("moveend");
        },
        setMaxBounds: function(bounds) {
            bounds = L.latLngBounds(bounds);
            this.options.maxBounds = bounds;
            if (!bounds) {
                return this.off("moveend", this._panInsideMaxBounds, this);
            }
            if (this._loaded) {
                this._panInsideMaxBounds();
            }
            return this.on("moveend", this._panInsideMaxBounds, this);
        },
        panInsideBounds: function(bounds, options) {
            var center = this.getCenter(), newCenter = this._limitCenter(center, this._zoom, bounds);
            if (center.equals(newCenter)) {
                return this;
            }
            return this.panTo(newCenter, options);
        },
        addLayer: function(layer) {
            // TODO method is too big, refactor
            var id = L.stamp(layer);
            if (this._layers[id]) {
                return this;
            }
            this._layers[id] = layer;
            // TODO getMaxZoom, getMinZoom in ILayer (instead of options)
            if (layer.options && (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom))) {
                this._zoomBoundLayers[id] = layer;
                this._updateZoomLevels();
            }
            // TODO looks ugly, refactor!!!
            if (this.options.zoomAnimation && L.TileLayer && layer instanceof L.TileLayer) {
                this._tileLayersNum++;
                this._tileLayersToLoad++;
                layer.on("load", this._onTileLayerLoad, this);
            }
            if (this._loaded) {
                this._layerAdd(layer);
            }
            return this;
        },
        removeLayer: function(layer) {
            var id = L.stamp(layer);
            if (!this._layers[id]) {
                return this;
            }
            if (this._loaded) {
                layer.onRemove(this);
            }
            delete this._layers[id];
            if (this._loaded) {
                this.fire("layerremove", {
                    layer: layer
                });
            }
            if (this._zoomBoundLayers[id]) {
                delete this._zoomBoundLayers[id];
                this._updateZoomLevels();
            }
            // TODO looks ugly, refactor
            if (this.options.zoomAnimation && L.TileLayer && layer instanceof L.TileLayer) {
                this._tileLayersNum--;
                this._tileLayersToLoad--;
                layer.off("load", this._onTileLayerLoad, this);
            }
            return this;
        },
        hasLayer: function(layer) {
            if (!layer) {
                return false;
            }
            return L.stamp(layer) in this._layers;
        },
        eachLayer: function(method, context) {
            for (var i in this._layers) {
                method.call(context, this._layers[i]);
            }
            return this;
        },
        invalidateSize: function(options) {
            if (!this._loaded) {
                return this;
            }
            options = L.extend({
                animate: false,
                pan: true
            }, options === true ? {
                animate: true
            } : options);
            var oldSize = this.getSize();
            this._sizeChanged = true;
            this._initialCenter = null;
            var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);
            if (!offset.x && !offset.y) {
                return this;
            }
            if (options.animate && options.pan) {
                this.panBy(offset);
            } else {
                if (options.pan) {
                    this._rawPanBy(offset);
                }
                this.fire("move");
                if (options.debounceMoveend) {
                    clearTimeout(this._sizeTimer);
                    this._sizeTimer = setTimeout(L.bind(this.fire, this, "moveend"), 200);
                } else {
                    this.fire("moveend");
                }
            }
            return this.fire("resize", {
                oldSize: oldSize,
                newSize: newSize
            });
        },
        // TODO handler.addTo
        addHandler: function(name, HandlerClass) {
            if (!HandlerClass) {
                return this;
            }
            var handler = this[name] = new HandlerClass(this);
            this._handlers.push(handler);
            if (this.options[name]) {
                handler.enable();
            }
            return this;
        },
        remove: function() {
            if (this._loaded) {
                this.fire("unload");
            }
            this._initEvents("off");
            try {
                // throws error in IE6-8
                delete this._container._leaflet;
            } catch (e) {
                this._container._leaflet = undefined;
            }
            this._clearPanes();
            if (this._clearControlPos) {
                this._clearControlPos();
            }
            this._clearHandlers();
            return this;
        },
        // public methods for getting map state
        getCenter: function() {
            // (Boolean) -> LatLng
            this._checkIfLoaded();
            if (this._initialCenter && !this._moved()) {
                return this._initialCenter;
            }
            return this.layerPointToLatLng(this._getCenterLayerPoint());
        },
        getZoom: function() {
            return this._zoom;
        },
        getBounds: function() {
            var bounds = this.getPixelBounds(), sw = this.unproject(bounds.getBottomLeft()), ne = this.unproject(bounds.getTopRight());
            return new L.LatLngBounds(sw, ne);
        },
        getMinZoom: function() {
            return this.options.minZoom === undefined ? this._layersMinZoom === undefined ? 0 : this._layersMinZoom : this.options.minZoom;
        },
        getMaxZoom: function() {
            return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom;
        },
        getBoundsZoom: function(bounds, inside, padding) {
            // (LatLngBounds[, Boolean, Point]) -> Number
            bounds = L.latLngBounds(bounds);
            var zoom = this.getMinZoom() - (inside ? 1 : 0), maxZoom = this.getMaxZoom(), size = this.getSize(), nw = bounds.getNorthWest(), se = bounds.getSouthEast(), zoomNotFound = true, boundsSize;
            padding = L.point(padding || [ 0, 0 ]);
            do {
                zoom++;
                boundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding);
                zoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y;
            } while (zoomNotFound && zoom <= maxZoom);
            if (zoomNotFound && inside) {
                return null;
            }
            return inside ? zoom : zoom - 1;
        },
        getSize: function() {
            if (!this._size || this._sizeChanged) {
                this._size = new L.Point(this._container.clientWidth, this._container.clientHeight);
                this._sizeChanged = false;
            }
            return this._size.clone();
        },
        getPixelBounds: function() {
            var topLeftPoint = this._getTopLeftPoint();
            return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
        },
        getPixelOrigin: function() {
            this._checkIfLoaded();
            return this._initialTopLeftPoint;
        },
        getPanes: function() {
            return this._panes;
        },
        getContainer: function() {
            return this._container;
        },
        // TODO replace with universal implementation after refactoring projections
        getZoomScale: function(toZoom) {
            var crs = this.options.crs;
            return crs.scale(toZoom) / crs.scale(this._zoom);
        },
        getScaleZoom: function(scale) {
            return this._zoom + Math.log(scale) / Math.LN2;
        },
        // conversion methods
        project: function(latlng, zoom) {
            // (LatLng[, Number]) -> Point
            zoom = zoom === undefined ? this._zoom : zoom;
            return this.options.crs.latLngToPoint(L.latLng(latlng), zoom);
        },
        unproject: function(point, zoom) {
            // (Point[, Number]) -> LatLng
            zoom = zoom === undefined ? this._zoom : zoom;
            return this.options.crs.pointToLatLng(L.point(point), zoom);
        },
        layerPointToLatLng: function(point) {
            // (Point)
            var projectedPoint = L.point(point).add(this.getPixelOrigin());
            return this.unproject(projectedPoint);
        },
        latLngToLayerPoint: function(latlng) {
            // (LatLng)
            var projectedPoint = this.project(L.latLng(latlng))._round();
            return projectedPoint._subtract(this.getPixelOrigin());
        },
        containerPointToLayerPoint: function(point) {
            // (Point)
            return L.point(point).subtract(this._getMapPanePos());
        },
        layerPointToContainerPoint: function(point) {
            // (Point)
            return L.point(point).add(this._getMapPanePos());
        },
        containerPointToLatLng: function(point) {
            var layerPoint = this.containerPointToLayerPoint(L.point(point));
            return this.layerPointToLatLng(layerPoint);
        },
        latLngToContainerPoint: function(latlng) {
            return this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));
        },
        mouseEventToContainerPoint: function(e) {
            // (MouseEvent)
            return L.DomEvent.getMousePosition(e, this._container);
        },
        mouseEventToLayerPoint: function(e) {
            // (MouseEvent)
            return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
        },
        mouseEventToLatLng: function(e) {
            // (MouseEvent)
            return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
        },
        // map initialization methods
        _initContainer: function(id) {
            var container = this._container = L.DomUtil.get(id);
            if (!container) {
                throw new Error("Map container not found.");
            } else if (container._leaflet) {
                throw new Error("Map container is already initialized.");
            }
            container._leaflet = true;
        },
        _initLayout: function() {
            var container = this._container;
            L.DomUtil.addClass(container, "leaflet-container" + (L.Browser.touch ? " leaflet-touch" : "") + (L.Browser.retina ? " leaflet-retina" : "") + (L.Browser.ielt9 ? " leaflet-oldie" : "") + (this.options.fadeAnimation ? " leaflet-fade-anim" : ""));
            var position = L.DomUtil.getStyle(container, "position");
            if (position !== "absolute" && position !== "relative" && position !== "fixed") {
                container.style.position = "relative";
            }
            this._initPanes();
            if (this._initControlPos) {
                this._initControlPos();
            }
        },
        _initPanes: function() {
            var panes = this._panes = {};
            this._mapPane = panes.mapPane = this._createPane("leaflet-map-pane", this._container);
            this._tilePane = panes.tilePane = this._createPane("leaflet-tile-pane", this._mapPane);
            panes.objectsPane = this._createPane("leaflet-objects-pane", this._mapPane);
            panes.shadowPane = this._createPane("leaflet-shadow-pane");
            panes.overlayPane = this._createPane("leaflet-overlay-pane");
            panes.markerPane = this._createPane("leaflet-marker-pane");
            panes.popupPane = this._createPane("leaflet-popup-pane");
            var zoomHide = " leaflet-zoom-hide";
            if (!this.options.markerZoomAnimation) {
                L.DomUtil.addClass(panes.markerPane, zoomHide);
                L.DomUtil.addClass(panes.shadowPane, zoomHide);
                L.DomUtil.addClass(panes.popupPane, zoomHide);
            }
        },
        _createPane: function(className, container) {
            return L.DomUtil.create("div", className, container || this._panes.objectsPane);
        },
        _clearPanes: function() {
            this._container.removeChild(this._mapPane);
        },
        _addLayers: function(layers) {
            layers = layers ? L.Util.isArray(layers) ? layers : [ layers ] : [];
            for (var i = 0, len = layers.length; i < len; i++) {
                this.addLayer(layers[i]);
            }
        },
        // private methods that modify map state
        _resetView: function(center, zoom, preserveMapOffset, afterZoomAnim) {
            var zoomChanged = this._zoom !== zoom;
            if (!afterZoomAnim) {
                this.fire("movestart");
                if (zoomChanged) {
                    this.fire("zoomstart");
                }
            }
            this._zoom = zoom;
            this._initialCenter = center;
            this._initialTopLeftPoint = this._getNewTopLeftPoint(center);
            if (!preserveMapOffset) {
                L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));
            } else {
                this._initialTopLeftPoint._add(this._getMapPanePos());
            }
            this._tileLayersToLoad = this._tileLayersNum;
            var loading = !this._loaded;
            this._loaded = true;
            this.fire("viewreset", {
                hard: !preserveMapOffset
            });
            if (loading) {
                this.fire("load");
                this.eachLayer(this._layerAdd, this);
            }
            this.fire("move");
            if (zoomChanged || afterZoomAnim) {
                this.fire("zoomend");
            }
            this.fire("moveend", {
                hard: !preserveMapOffset
            });
        },
        _rawPanBy: function(offset) {
            L.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
        },
        _getZoomSpan: function() {
            return this.getMaxZoom() - this.getMinZoom();
        },
        _updateZoomLevels: function() {
            var i, minZoom = Infinity, maxZoom = -Infinity, oldZoomSpan = this._getZoomSpan();
            for (i in this._zoomBoundLayers) {
                var layer = this._zoomBoundLayers[i];
                if (!isNaN(layer.options.minZoom)) {
                    minZoom = Math.min(minZoom, layer.options.minZoom);
                }
                if (!isNaN(layer.options.maxZoom)) {
                    maxZoom = Math.max(maxZoom, layer.options.maxZoom);
                }
            }
            if (i === undefined) {
                // we have no tilelayers
                this._layersMaxZoom = this._layersMinZoom = undefined;
            } else {
                this._layersMaxZoom = maxZoom;
                this._layersMinZoom = minZoom;
            }
            if (oldZoomSpan !== this._getZoomSpan()) {
                this.fire("zoomlevelschange");
            }
        },
        _panInsideMaxBounds: function() {
            this.panInsideBounds(this.options.maxBounds);
        },
        _checkIfLoaded: function() {
            if (!this._loaded) {
                throw new Error("Set map center and zoom first.");
            }
        },
        // map events
        _initEvents: function(onOff) {
            if (!L.DomEvent) {
                return;
            }
            onOff = onOff || "on";
            L.DomEvent[onOff](this._container, "click", this._onMouseClick, this);
            var events = [ "dblclick", "mousedown", "mouseup", "mouseenter", "mouseleave", "mousemove", "contextmenu" ], i, len;
            for (i = 0, len = events.length; i < len; i++) {
                L.DomEvent[onOff](this._container, events[i], this._fireMouseEvent, this);
            }
            if (this.options.trackResize) {
                L.DomEvent[onOff](window, "resize", this._onResize, this);
            }
        },
        _onResize: function() {
            L.Util.cancelAnimFrame(this._resizeRequest);
            this._resizeRequest = L.Util.requestAnimFrame(function() {
                this.invalidateSize({
                    debounceMoveend: true
                });
            }, this, false, this._container);
        },
        _onMouseClick: function(e) {
            if (!this._loaded || !e._simulated && (this.dragging && this.dragging.moved() || this.boxZoom && this.boxZoom.moved()) || L.DomEvent._skipped(e)) {
                return;
            }
            this.fire("preclick");
            this._fireMouseEvent(e);
        },
        _fireMouseEvent: function(e) {
            if (!this._loaded || L.DomEvent._skipped(e)) {
                return;
            }
            var type = e.type;
            type = type === "mouseenter" ? "mouseover" : type === "mouseleave" ? "mouseout" : type;
            if (!this.hasEventListeners(type)) {
                return;
            }
            if (type === "contextmenu") {
                L.DomEvent.preventDefault(e);
            }
            var containerPoint = this.mouseEventToContainerPoint(e), layerPoint = this.containerPointToLayerPoint(containerPoint), latlng = this.layerPointToLatLng(layerPoint);
            this.fire(type, {
                latlng: latlng,
                layerPoint: layerPoint,
                containerPoint: containerPoint,
                originalEvent: e
            });
        },
        _onTileLayerLoad: function() {
            this._tileLayersToLoad--;
            if (this._tileLayersNum && !this._tileLayersToLoad) {
                this.fire("tilelayersload");
            }
        },
        _clearHandlers: function() {
            for (var i = 0, len = this._handlers.length; i < len; i++) {
                this._handlers[i].disable();
            }
        },
        whenReady: function(callback, context) {
            if (this._loaded) {
                callback.call(context || this, this);
            } else {
                this.on("load", callback, context);
            }
            return this;
        },
        _layerAdd: function(layer) {
            layer.onAdd(this);
            this.fire("layeradd", {
                layer: layer
            });
        },
        // private methods for getting map state
        _getMapPanePos: function() {
            return L.DomUtil.getPosition(this._mapPane);
        },
        _moved: function() {
            var pos = this._getMapPanePos();
            return pos && !pos.equals([ 0, 0 ]);
        },
        _getTopLeftPoint: function() {
            return this.getPixelOrigin().subtract(this._getMapPanePos());
        },
        _getNewTopLeftPoint: function(center, zoom) {
            var viewHalf = this.getSize()._divideBy(2);
            // TODO round on display, not calculation to increase precision?
            return this.project(center, zoom)._subtract(viewHalf)._round();
        },
        _latLngToNewLayerPoint: function(latlng, newZoom, newCenter) {
            var topLeft = this._getNewTopLeftPoint(newCenter, newZoom).add(this._getMapPanePos());
            return this.project(latlng, newZoom)._subtract(topLeft);
        },
        // layer point of the current center
        _getCenterLayerPoint: function() {
            return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
        },
        // offset of the specified place to the current center in pixels
        _getCenterOffset: function(latlng) {
            return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
        },
        // adjust center for view to get inside bounds
        _limitCenter: function(center, zoom, bounds) {
            if (!bounds) {
                return center;
            }
            var centerPoint = this.project(center, zoom), viewHalf = this.getSize().divideBy(2), viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds, zoom);
            return this.unproject(centerPoint.add(offset), zoom);
        },
        // adjust offset for view to get inside bounds
        _limitOffset: function(offset, bounds) {
            if (!bounds) {
                return offset;
            }
            var viewBounds = this.getPixelBounds(), newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
            return offset.add(this._getBoundsOffset(newBounds, bounds));
        },
        // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
        _getBoundsOffset: function(pxBounds, maxBounds, zoom) {
            var nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min), seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max), dx = this._rebound(nwOffset.x, -seOffset.x), dy = this._rebound(nwOffset.y, -seOffset.y);
            return new L.Point(dx, dy);
        },
        _rebound: function(left, right) {
            return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
        },
        _limitZoom: function(zoom) {
            var min = this.getMinZoom(), max = this.getMaxZoom();
            return Math.max(min, Math.min(max, zoom));
        }
    });
    L.map = function(id, options) {
        return new L.Map(id, options);
    };
    /*
 * Mercator projection that takes into account that the Earth is not a perfect sphere.
 * Less popular than spherical mercator; used by projections like EPSG:3395.
 */
    L.Projection.Mercator = {
        MAX_LATITUDE: 85.0840591556,
        R_MINOR: 6356752.314245179,
        R_MAJOR: 6378137,
        project: function(latlng) {
            // (LatLng) -> Point
            var d = L.LatLng.DEG_TO_RAD, max = this.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), r = this.R_MAJOR, r2 = this.R_MINOR, x = latlng.lng * d * r, y = lat * d, tmp = r2 / r, eccent = Math.sqrt(1 - tmp * tmp), con = eccent * Math.sin(y);
            con = Math.pow((1 - con) / (1 + con), eccent * .5);
            var ts = Math.tan(.5 * (Math.PI * .5 - y)) / con;
            y = -r * Math.log(ts);
            return new L.Point(x, y);
        },
        unproject: function(point) {
            // (Point, Boolean) -> LatLng
            var d = L.LatLng.RAD_TO_DEG, r = this.R_MAJOR, r2 = this.R_MINOR, lng = point.x * d / r, tmp = r2 / r, eccent = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point.y / r), phi = Math.PI / 2 - 2 * Math.atan(ts), numIter = 15, tol = 1e-7, i = numIter, dphi = .1, con;
            while (Math.abs(dphi) > tol && --i > 0) {
                con = eccent * Math.sin(phi);
                dphi = Math.PI / 2 - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), .5 * eccent)) - phi;
                phi += dphi;
            }
            return new L.LatLng(phi * d, lng);
        }
    };
    L.CRS.EPSG3395 = L.extend({}, L.CRS, {
        code: "EPSG:3395",
        projection: L.Projection.Mercator,
        transformation: function() {
            var m = L.Projection.Mercator, r = m.R_MAJOR, scale = .5 / (Math.PI * r);
            return new L.Transformation(scale, .5, -scale, .5);
        }()
    });
    /*
 * L.TileLayer is used for standard xyz-numbered tile layers.
 */
    L.TileLayer = L.Class.extend({
        includes: L.Mixin.Events,
        options: {
            minZoom: 0,
            maxZoom: 18,
            tileSize: 256,
            subdomains: "abc",
            errorTileUrl: "",
            attribution: "",
            zoomOffset: 0,
            opacity: 1,
            /*
		maxNativeZoom: null,
		zIndex: null,
		tms: false,
		continuousWorld: false,
		noWrap: false,
		zoomReverse: false,
		detectRetina: false,
		reuseTiles: false,
		bounds: false,
		*/
            unloadInvisibleTiles: L.Browser.mobile,
            updateWhenIdle: L.Browser.mobile
        },
        initialize: function(url, options) {
            options = L.setOptions(this, options);
            // detecting retina displays, adjusting tileSize and zoom levels
            if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {
                options.tileSize = Math.floor(options.tileSize / 2);
                options.zoomOffset++;
                if (options.minZoom > 0) {
                    options.minZoom--;
                }
                this.options.maxZoom--;
            }
            if (options.bounds) {
                options.bounds = L.latLngBounds(options.bounds);
            }
            this._url = url;
            var subdomains = this.options.subdomains;
            if (typeof subdomains === "string") {
                this.options.subdomains = subdomains.split("");
            }
        },
        onAdd: function(map) {
            this._map = map;
            this._animated = map._zoomAnimated;
            // create a container div for tiles
            this._initContainer();
            // set up events
            map.on({
                viewreset: this._reset,
                moveend: this._update
            }, this);
            if (this._animated) {
                map.on({
                    zoomanim: this._animateZoom,
                    zoomend: this._endZoomAnim
                }, this);
            }
            if (!this.options.updateWhenIdle) {
                this._limitedUpdate = L.Util.limitExecByInterval(this._update, 150, this);
                map.on("move", this._limitedUpdate, this);
            }
            this._reset();
            this._update();
        },
        addTo: function(map) {
            map.addLayer(this);
            return this;
        },
        onRemove: function(map) {
            this._container.parentNode.removeChild(this._container);
            map.off({
                viewreset: this._reset,
                moveend: this._update
            }, this);
            if (this._animated) {
                map.off({
                    zoomanim: this._animateZoom,
                    zoomend: this._endZoomAnim
                }, this);
            }
            if (!this.options.updateWhenIdle) {
                map.off("move", this._limitedUpdate, this);
            }
            this._container = null;
            this._map = null;
        },
        bringToFront: function() {
            var pane = this._map._panes.tilePane;
            if (this._container) {
                pane.appendChild(this._container);
                this._setAutoZIndex(pane, Math.max);
            }
            return this;
        },
        bringToBack: function() {
            var pane = this._map._panes.tilePane;
            if (this._container) {
                pane.insertBefore(this._container, pane.firstChild);
                this._setAutoZIndex(pane, Math.min);
            }
            return this;
        },
        getAttribution: function() {
            return this.options.attribution;
        },
        getContainer: function() {
            return this._container;
        },
        setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._map) {
                this._updateOpacity();
            }
            return this;
        },
        setZIndex: function(zIndex) {
            this.options.zIndex = zIndex;
            this._updateZIndex();
            return this;
        },
        setUrl: function(url, noRedraw) {
            this._url = url;
            if (!noRedraw) {
                this.redraw();
            }
            return this;
        },
        redraw: function() {
            if (this._map) {
                this._reset({
                    hard: true
                });
                this._update();
            }
            return this;
        },
        _updateZIndex: function() {
            if (this._container && this.options.zIndex !== undefined) {
                this._container.style.zIndex = this.options.zIndex;
            }
        },
        _setAutoZIndex: function(pane, compare) {
            var layers = pane.children, edgeZIndex = -compare(Infinity, -Infinity), // -Infinity for max, Infinity for min
            zIndex, i, len;
            for (i = 0, len = layers.length; i < len; i++) {
                if (layers[i] !== this._container) {
                    zIndex = parseInt(layers[i].style.zIndex, 10);
                    if (!isNaN(zIndex)) {
                        edgeZIndex = compare(edgeZIndex, zIndex);
                    }
                }
            }
            this.options.zIndex = this._container.style.zIndex = (isFinite(edgeZIndex) ? edgeZIndex : 0) + compare(1, -1);
        },
        _updateOpacity: function() {
            var i, tiles = this._tiles;
            if (L.Browser.ielt9) {
                for (i in tiles) {
                    L.DomUtil.setOpacity(tiles[i], this.options.opacity);
                }
            } else {
                L.DomUtil.setOpacity(this._container, this.options.opacity);
            }
        },
        _initContainer: function() {
            var tilePane = this._map._panes.tilePane;
            if (!this._container) {
                this._container = L.DomUtil.create("div", "leaflet-layer");
                this._updateZIndex();
                if (this._animated) {
                    var className = "leaflet-tile-container";
                    this._bgBuffer = L.DomUtil.create("div", className, this._container);
                    this._tileContainer = L.DomUtil.create("div", className, this._container);
                } else {
                    this._tileContainer = this._container;
                }
                tilePane.appendChild(this._container);
                if (this.options.opacity < 1) {
                    this._updateOpacity();
                }
            }
        },
        _reset: function(e) {
            for (var key in this._tiles) {
                this.fire("tileunload", {
                    tile: this._tiles[key]
                });
            }
            this._tiles = {};
            this._tilesToLoad = 0;
            if (this.options.reuseTiles) {
                this._unusedTiles = [];
            }
            this._tileContainer.innerHTML = "";
            if (this._animated && e && e.hard) {
                this._clearBgBuffer();
            }
            this._initContainer();
        },
        _getTileSize: function() {
            var map = this._map, zoom = map.getZoom() + this.options.zoomOffset, zoomN = this.options.maxNativeZoom, tileSize = this.options.tileSize;
            if (zoomN && zoom > zoomN) {
                tileSize = Math.round(map.getZoomScale(zoom) / map.getZoomScale(zoomN) * tileSize);
            }
            return tileSize;
        },
        _update: function() {
            if (!this._map) {
                return;
            }
            var map = this._map, bounds = map.getPixelBounds(), zoom = map.getZoom(), tileSize = this._getTileSize();
            if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
                return;
            }
            var tileBounds = L.bounds(bounds.min.divideBy(tileSize)._floor(), bounds.max.divideBy(tileSize)._floor());
            this._addTilesFromCenterOut(tileBounds);
            if (this.options.unloadInvisibleTiles || this.options.reuseTiles) {
                this._removeOtherTiles(tileBounds);
            }
        },
        _addTilesFromCenterOut: function(bounds) {
            var queue = [], center = bounds.getCenter();
            var j, i, point;
            for (j = bounds.min.y; j <= bounds.max.y; j++) {
                for (i = bounds.min.x; i <= bounds.max.x; i++) {
                    point = new L.Point(i, j);
                    if (this._tileShouldBeLoaded(point)) {
                        queue.push(point);
                    }
                }
            }
            var tilesToLoad = queue.length;
            if (tilesToLoad === 0) {
                return;
            }
            // load tiles in order of their distance to center
            queue.sort(function(a, b) {
                return a.distanceTo(center) - b.distanceTo(center);
            });
            var fragment = document.createDocumentFragment();
            // if its the first batch of tiles to load
            if (!this._tilesToLoad) {
                this.fire("loading");
            }
            this._tilesToLoad += tilesToLoad;
            for (i = 0; i < tilesToLoad; i++) {
                this._addTile(queue[i], fragment);
            }
            this._tileContainer.appendChild(fragment);
        },
        _tileShouldBeLoaded: function(tilePoint) {
            if (tilePoint.x + ":" + tilePoint.y in this._tiles) {
                return false;
            }
            var options = this.options;
            if (!options.continuousWorld) {
                var limit = this._getWrapTileNum();
                // don't load if exceeds world bounds
                if (options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x) || tilePoint.y < 0 || tilePoint.y >= limit.y) {
                    return false;
                }
            }
            if (options.bounds) {
                var tileSize = options.tileSize, nwPoint = tilePoint.multiplyBy(tileSize), sePoint = nwPoint.add([ tileSize, tileSize ]), nw = this._map.unproject(nwPoint), se = this._map.unproject(sePoint);
                // TODO temporary hack, will be removed after refactoring projections
                // https://github.com/Leaflet/Leaflet/issues/1618
                if (!options.continuousWorld && !options.noWrap) {
                    nw = nw.wrap();
                    se = se.wrap();
                }
                if (!options.bounds.intersects([ nw, se ])) {
                    return false;
                }
            }
            return true;
        },
        _removeOtherTiles: function(bounds) {
            var kArr, x, y, key;
            for (key in this._tiles) {
                kArr = key.split(":");
                x = parseInt(kArr[0], 10);
                y = parseInt(kArr[1], 10);
                // remove tile if it's out of bounds
                if (x < bounds.min.x || x > bounds.max.x || y < bounds.min.y || y > bounds.max.y) {
                    this._removeTile(key);
                }
            }
        },
        _removeTile: function(key) {
            var tile = this._tiles[key];
            this.fire("tileunload", {
                tile: tile,
                url: tile.src
            });
            if (this.options.reuseTiles) {
                L.DomUtil.removeClass(tile, "leaflet-tile-loaded");
                this._unusedTiles.push(tile);
            } else if (tile.parentNode === this._tileContainer) {
                this._tileContainer.removeChild(tile);
            }
            // for https://github.com/CloudMade/Leaflet/issues/137
            if (!L.Browser.android) {
                tile.onload = null;
                tile.src = L.Util.emptyImageUrl;
            }
            delete this._tiles[key];
        },
        _addTile: function(tilePoint, container) {
            var tilePos = this._getTilePos(tilePoint);
            // get unused tile - or create a new tile
            var tile = this._getTile();
            /*
		Chrome 20 layouts much faster with top/left (verify with timeline, frames)
		Android 4 browser has display issues with top/left and requires transform instead
		(other browsers don't currently care) - see debug/hacks/jitter.html for an example
		*/
            L.DomUtil.setPosition(tile, tilePos, L.Browser.chrome);
            this._tiles[tilePoint.x + ":" + tilePoint.y] = tile;
            this._loadTile(tile, tilePoint);
            if (tile.parentNode !== this._tileContainer) {
                container.appendChild(tile);
            }
        },
        _getZoomForUrl: function() {
            var options = this.options, zoom = this._map.getZoom();
            if (options.zoomReverse) {
                zoom = options.maxZoom - zoom;
            }
            zoom += options.zoomOffset;
            return options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;
        },
        _getTilePos: function(tilePoint) {
            var origin = this._map.getPixelOrigin(), tileSize = this._getTileSize();
            return tilePoint.multiplyBy(tileSize).subtract(origin);
        },
        // image-specific code (override to implement e.g. Canvas or SVG tile layer)
        getTileUrl: function(tilePoint) {
            return L.Util.template(this._url, L.extend({
                s: this._getSubdomain(tilePoint),
                z: tilePoint.z,
                x: tilePoint.x,
                y: tilePoint.y
            }, this.options));
        },
        _getWrapTileNum: function() {
            var crs = this._map.options.crs, size = crs.getSize(this._map.getZoom());
            return size.divideBy(this._getTileSize())._floor();
        },
        _adjustTilePoint: function(tilePoint) {
            var limit = this._getWrapTileNum();
            // wrap tile coordinates
            if (!this.options.continuousWorld && !this.options.noWrap) {
                tilePoint.x = (tilePoint.x % limit.x + limit.x) % limit.x;
            }
            if (this.options.tms) {
                tilePoint.y = limit.y - tilePoint.y - 1;
            }
            tilePoint.z = this._getZoomForUrl();
        },
        _getSubdomain: function(tilePoint) {
            var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
            return this.options.subdomains[index];
        },
        _getTile: function() {
            if (this.options.reuseTiles && this._unusedTiles.length > 0) {
                var tile = this._unusedTiles.pop();
                this._resetTile(tile);
                return tile;
            }
            return this._createTile();
        },
        // Override if data stored on a tile needs to be cleaned up before reuse
        _resetTile: function() {},
        _createTile: function() {
            var tile = L.DomUtil.create("img", "leaflet-tile");
            tile.style.width = tile.style.height = this._getTileSize() + "px";
            tile.galleryimg = "no";
            tile.onselectstart = tile.onmousemove = L.Util.falseFn;
            if (L.Browser.ielt9 && this.options.opacity !== undefined) {
                L.DomUtil.setOpacity(tile, this.options.opacity);
            }
            // without this hack, tiles disappear after zoom on Chrome for Android
            // https://github.com/Leaflet/Leaflet/issues/2078
            if (L.Browser.mobileWebkit3d) {
                tile.style.WebkitBackfaceVisibility = "hidden";
            }
            return tile;
        },
        _loadTile: function(tile, tilePoint) {
            tile._layer = this;
            tile.onload = this._tileOnLoad;
            tile.onerror = this._tileOnError;
            this._adjustTilePoint(tilePoint);
            tile.src = this.getTileUrl(tilePoint);
            this.fire("tileloadstart", {
                tile: tile,
                url: tile.src
            });
        },
        _tileLoaded: function() {
            this._tilesToLoad--;
            if (this._animated) {
                L.DomUtil.addClass(this._tileContainer, "leaflet-zoom-animated");
            }
            if (!this._tilesToLoad) {
                this.fire("load");
                if (this._animated) {
                    // clear scaled tiles after all new tiles are loaded (for performance)
                    clearTimeout(this._clearBgBufferTimer);
                    this._clearBgBufferTimer = setTimeout(L.bind(this._clearBgBuffer, this), 500);
                }
            }
        },
        _tileOnLoad: function() {
            var layer = this._layer;
            //Only if we are loading an actual image
            if (this.src !== L.Util.emptyImageUrl) {
                L.DomUtil.addClass(this, "leaflet-tile-loaded");
                layer.fire("tileload", {
                    tile: this,
                    url: this.src
                });
            }
            layer._tileLoaded();
        },
        _tileOnError: function() {
            var layer = this._layer;
            layer.fire("tileerror", {
                tile: this,
                url: this.src
            });
            var newUrl = layer.options.errorTileUrl;
            if (newUrl) {
                this.src = newUrl;
            }
            layer._tileLoaded();
        }
    });
    L.tileLayer = function(url, options) {
        return new L.TileLayer(url, options);
    };
    /*
 * L.TileLayer.WMS is used for putting WMS tile layers on the map.
 */
    L.TileLayer.WMS = L.TileLayer.extend({
        defaultWmsParams: {
            service: "WMS",
            request: "GetMap",
            version: "1.1.1",
            layers: "",
            styles: "",
            format: "image/jpeg",
            transparent: false
        },
        initialize: function(url, options) {
            // (String, Object)
            this._url = url;
            var wmsParams = L.extend({}, this.defaultWmsParams), tileSize = options.tileSize || this.options.tileSize;
            if (options.detectRetina && L.Browser.retina) {
                wmsParams.width = wmsParams.height = tileSize * 2;
            } else {
                wmsParams.width = wmsParams.height = tileSize;
            }
            for (var i in options) {
                // all keys that are not TileLayer options go to WMS params
                if (!this.options.hasOwnProperty(i) && i !== "crs") {
                    wmsParams[i] = options[i];
                }
            }
            this.wmsParams = wmsParams;
            L.setOptions(this, options);
        },
        onAdd: function(map) {
            this._crs = this.options.crs || map.options.crs;
            this._wmsVersion = parseFloat(this.wmsParams.version);
            var projectionKey = this._wmsVersion >= 1.3 ? "crs" : "srs";
            this.wmsParams[projectionKey] = this._crs.code;
            L.TileLayer.prototype.onAdd.call(this, map);
        },
        getTileUrl: function(tilePoint) {
            // (Point, Number) -> String
            var map = this._map, tileSize = this.options.tileSize, nwPoint = tilePoint.multiplyBy(tileSize), sePoint = nwPoint.add([ tileSize, tileSize ]), nw = this._crs.project(map.unproject(nwPoint, tilePoint.z)), se = this._crs.project(map.unproject(sePoint, tilePoint.z)), bbox = this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ? [ se.y, nw.x, nw.y, se.x ].join(",") : [ nw.x, se.y, se.x, nw.y ].join(","), url = L.Util.template(this._url, {
                s: this._getSubdomain(tilePoint)
            });
            return url + L.Util.getParamString(this.wmsParams, url, true) + "&BBOX=" + bbox;
        },
        setParams: function(params, noRedraw) {
            L.extend(this.wmsParams, params);
            if (!noRedraw) {
                this.redraw();
            }
            return this;
        }
    });
    L.tileLayer.wms = function(url, options) {
        return new L.TileLayer.WMS(url, options);
    };
    /*
 * L.TileLayer.Canvas is a class that you can use as a base for creating
 * dynamically drawn Canvas-based tile layers.
 */
    L.TileLayer.Canvas = L.TileLayer.extend({
        options: {
            async: false
        },
        initialize: function(options) {
            L.setOptions(this, options);
        },
        redraw: function() {
            if (this._map) {
                this._reset({
                    hard: true
                });
                this._update();
            }
            for (var i in this._tiles) {
                this._redrawTile(this._tiles[i]);
            }
            return this;
        },
        _redrawTile: function(tile) {
            this.drawTile(tile, tile._tilePoint, this._map._zoom);
        },
        _createTile: function() {
            var tile = L.DomUtil.create("canvas", "leaflet-tile");
            tile.width = tile.height = this.options.tileSize;
            tile.onselectstart = tile.onmousemove = L.Util.falseFn;
            return tile;
        },
        _loadTile: function(tile, tilePoint) {
            tile._layer = this;
            tile._tilePoint = tilePoint;
            this._redrawTile(tile);
            if (!this.options.async) {
                this.tileDrawn(tile);
            }
        },
        drawTile: function() {},
        tileDrawn: function(tile) {
            this._tileOnLoad.call(tile);
        }
    });
    L.tileLayer.canvas = function(options) {
        return new L.TileLayer.Canvas(options);
    };
    /*
 * L.ImageOverlay is used to overlay images over the map (to specific geographical bounds).
 */
    L.ImageOverlay = L.Class.extend({
        includes: L.Mixin.Events,
        options: {
            opacity: 1
        },
        initialize: function(url, bounds, options) {
            // (String, LatLngBounds, Object)
            this._url = url;
            this._bounds = L.latLngBounds(bounds);
            L.setOptions(this, options);
        },
        onAdd: function(map) {
            this._map = map;
            if (!this._image) {
                this._initImage();
            }
            map._panes.overlayPane.appendChild(this._image);
            map.on("viewreset", this._reset, this);
            if (map.options.zoomAnimation && L.Browser.any3d) {
                map.on("zoomanim", this._animateZoom, this);
            }
            this._reset();
        },
        onRemove: function(map) {
            map.getPanes().overlayPane.removeChild(this._image);
            map.off("viewreset", this._reset, this);
            if (map.options.zoomAnimation) {
                map.off("zoomanim", this._animateZoom, this);
            }
        },
        addTo: function(map) {
            map.addLayer(this);
            return this;
        },
        setOpacity: function(opacity) {
            this.options.opacity = opacity;
            this._updateOpacity();
            return this;
        },
        // TODO remove bringToFront/bringToBack duplication from TileLayer/Path
        bringToFront: function() {
            if (this._image) {
                this._map._panes.overlayPane.appendChild(this._image);
            }
            return this;
        },
        bringToBack: function() {
            var pane = this._map._panes.overlayPane;
            if (this._image) {
                pane.insertBefore(this._image, pane.firstChild);
            }
            return this;
        },
        setUrl: function(url) {
            this._url = url;
            this._image.src = this._url;
        },
        getAttribution: function() {
            return this.options.attribution;
        },
        _initImage: function() {
            this._image = L.DomUtil.create("img", "leaflet-image-layer");
            if (this._map.options.zoomAnimation && L.Browser.any3d) {
                L.DomUtil.addClass(this._image, "leaflet-zoom-animated");
            } else {
                L.DomUtil.addClass(this._image, "leaflet-zoom-hide");
            }
            this._updateOpacity();
            //TODO createImage util method to remove duplication
            L.extend(this._image, {
                galleryimg: "no",
                onselectstart: L.Util.falseFn,
                onmousemove: L.Util.falseFn,
                onload: L.bind(this._onImageLoad, this),
                src: this._url
            });
        },
        _animateZoom: function(e) {
            var map = this._map, image = this._image, scale = map.getZoomScale(e.zoom), nw = this._bounds.getNorthWest(), se = this._bounds.getSouthEast(), topLeft = map._latLngToNewLayerPoint(nw, e.zoom, e.center), size = map._latLngToNewLayerPoint(se, e.zoom, e.center)._subtract(topLeft), origin = topLeft._add(size._multiplyBy(1 / 2 * (1 - 1 / scale)));
            image.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(origin) + " scale(" + scale + ") ";
        },
        _reset: function() {
            var image = this._image, topLeft = this._map.latLngToLayerPoint(this._bounds.getNorthWest()), size = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(topLeft);
            L.DomUtil.setPosition(image, topLeft);
            image.style.width = size.x + "px";
            image.style.height = size.y + "px";
        },
        _onImageLoad: function() {
            this.fire("load");
        },
        _updateOpacity: function() {
            L.DomUtil.setOpacity(this._image, this.options.opacity);
        }
    });
    L.imageOverlay = function(url, bounds, options) {
        return new L.ImageOverlay(url, bounds, options);
    };
    /*
 * L.Icon is an image-based icon class that you can use with L.Marker for custom markers.
 */
    L.Icon = L.Class.extend({
        options: {
            /*
		iconUrl: (String) (required)
		iconRetinaUrl: (String) (optional, used for retina devices if detected)
		iconSize: (Point) (can be set through CSS)
		iconAnchor: (Point) (centered by default, can be set in CSS with negative margins)
		popupAnchor: (Point) (if not specified, popup opens in the anchor point)
		shadowUrl: (String) (no shadow by default)
		shadowRetinaUrl: (String) (optional, used for retina devices if detected)
		shadowSize: (Point)
		shadowAnchor: (Point)
		*/
            className: ""
        },
        initialize: function(options) {
            L.setOptions(this, options);
        },
        createIcon: function(oldIcon) {
            return this._createIcon("icon", oldIcon);
        },
        createShadow: function(oldIcon) {
            return this._createIcon("shadow", oldIcon);
        },
        _createIcon: function(name, oldIcon) {
            var src = this._getIconUrl(name);
            if (!src) {
                if (name === "icon") {
                    throw new Error("iconUrl not set in Icon options (see the docs).");
                }
                return null;
            }
            var img;
            if (!oldIcon || oldIcon.tagName !== "IMG") {
                img = this._createImg(src);
            } else {
                img = this._createImg(src, oldIcon);
            }
            this._setIconStyles(img, name);
            return img;
        },
        _setIconStyles: function(img, name) {
            var options = this.options, size = L.point(options[name + "Size"]), anchor;
            if (name === "shadow") {
                anchor = L.point(options.shadowAnchor || options.iconAnchor);
            } else {
                anchor = L.point(options.iconAnchor);
            }
            if (!anchor && size) {
                anchor = size.divideBy(2, true);
            }
            img.className = "leaflet-marker-" + name + " " + options.className;
            if (anchor) {
                img.style.marginLeft = -anchor.x + "px";
                img.style.marginTop = -anchor.y + "px";
            }
            if (size) {
                img.style.width = size.x + "px";
                img.style.height = size.y + "px";
            }
        },
        _createImg: function(src, el) {
            el = el || document.createElement("img");
            el.src = src;
            return el;
        },
        _getIconUrl: function(name) {
            if (L.Browser.retina && this.options[name + "RetinaUrl"]) {
                return this.options[name + "RetinaUrl"];
            }
            return this.options[name + "Url"];
        }
    });
    L.icon = function(options) {
        return new L.Icon(options);
    };
    /*
 * L.Icon.Default is the blue marker icon used by default in Leaflet.
 */
    L.Icon.Default = L.Icon.extend({
        options: {
            iconSize: [ 25, 41 ],
            iconAnchor: [ 12, 41 ],
            popupAnchor: [ 1, -34 ],
            shadowSize: [ 41, 41 ]
        },
        _getIconUrl: function(name) {
            var key = name + "Url";
            if (this.options[key]) {
                return this.options[key];
            }
            if (L.Browser.retina && name === "icon") {
                name += "-2x";
            }
            var path = L.Icon.Default.imagePath;
            if (!path) {
                throw new Error("Couldn't autodetect L.Icon.Default.imagePath, set it manually.");
            }
            return path + "/marker-" + name + ".png";
        }
    });
    L.Icon.Default.imagePath = function() {
        var scripts = document.getElementsByTagName("script"), leafletRe = /[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;
        var i, len, src, matches, path;
        for (i = 0, len = scripts.length; i < len; i++) {
            src = scripts[i].src;
            matches = src.match(leafletRe);
            if (matches) {
                path = src.split(leafletRe)[0];
                return (path ? path + "/" : "") + "images";
            }
        }
    }();
    /*
 * L.Marker is used to display clickable/draggable icons on the map.
 */
    L.Marker = L.Class.extend({
        includes: L.Mixin.Events,
        options: {
            icon: new L.Icon.Default(),
            title: "",
            alt: "",
            clickable: true,
            draggable: false,
            keyboard: true,
            zIndexOffset: 0,
            opacity: 1,
            riseOnHover: false,
            riseOffset: 250
        },
        initialize: function(latlng, options) {
            L.setOptions(this, options);
            this._latlng = L.latLng(latlng);
        },
        onAdd: function(map) {
            this._map = map;
            map.on("viewreset", this.update, this);
            this._initIcon();
            this.update();
            this.fire("add");
            if (map.options.zoomAnimation && map.options.markerZoomAnimation) {
                map.on("zoomanim", this._animateZoom, this);
            }
        },
        addTo: function(map) {
            map.addLayer(this);
            return this;
        },
        onRemove: function(map) {
            if (this.dragging) {
                this.dragging.disable();
            }
            this._removeIcon();
            this._removeShadow();
            this.fire("remove");
            map.off({
                viewreset: this.update,
                zoomanim: this._animateZoom
            }, this);
            this._map = null;
        },
        getLatLng: function() {
            return this._latlng;
        },
        setLatLng: function(latlng) {
            this._latlng = L.latLng(latlng);
            this.update();
            return this.fire("move", {
                latlng: this._latlng
            });
        },
        setZIndexOffset: function(offset) {
            this.options.zIndexOffset = offset;
            this.update();
            return this;
        },
        setIcon: function(icon) {
            this.options.icon = icon;
            if (this._map) {
                this._initIcon();
                this.update();
            }
            if (this._popup) {
                this.bindPopup(this._popup);
            }
            return this;
        },
        update: function() {
            if (this._icon) {
                var pos = this._map.latLngToLayerPoint(this._latlng).round();
                this._setPos(pos);
            }
            return this;
        },
        _initIcon: function() {
            var options = this.options, map = this._map, animation = map.options.zoomAnimation && map.options.markerZoomAnimation, classToAdd = animation ? "leaflet-zoom-animated" : "leaflet-zoom-hide";
            var icon = options.icon.createIcon(this._icon), addIcon = false;
            // if we're not reusing the icon, remove the old one and init new one
            if (icon !== this._icon) {
                if (this._icon) {
                    this._removeIcon();
                }
                addIcon = true;
                if (options.title) {
                    icon.title = options.title;
                }
                if (options.alt) {
                    icon.alt = options.alt;
                }
            }
            L.DomUtil.addClass(icon, classToAdd);
            if (options.keyboard) {
                icon.tabIndex = "0";
            }
            this._icon = icon;
            this._initInteraction();
            if (options.riseOnHover) {
                L.DomEvent.on(icon, "mouseover", this._bringToFront, this).on(icon, "mouseout", this._resetZIndex, this);
            }
            var newShadow = options.icon.createShadow(this._shadow), addShadow = false;
            if (newShadow !== this._shadow) {
                this._removeShadow();
                addShadow = true;
            }
            if (newShadow) {
                L.DomUtil.addClass(newShadow, classToAdd);
            }
            this._shadow = newShadow;
            if (options.opacity < 1) {
                this._updateOpacity();
            }
            var panes = this._map._panes;
            if (addIcon) {
                panes.markerPane.appendChild(this._icon);
            }
            if (newShadow && addShadow) {
                panes.shadowPane.appendChild(this._shadow);
            }
        },
        _removeIcon: function() {
            if (this.options.riseOnHover) {
                L.DomEvent.off(this._icon, "mouseover", this._bringToFront).off(this._icon, "mouseout", this._resetZIndex);
            }
            this._map._panes.markerPane.removeChild(this._icon);
            this._icon = null;
        },
        _removeShadow: function() {
            if (this._shadow) {
                this._map._panes.shadowPane.removeChild(this._shadow);
            }
            this._shadow = null;
        },
        _setPos: function(pos) {
            L.DomUtil.setPosition(this._icon, pos);
            if (this._shadow) {
                L.DomUtil.setPosition(this._shadow, pos);
            }
            this._zIndex = pos.y + this.options.zIndexOffset;
            this._resetZIndex();
        },
        _updateZIndex: function(offset) {
            this._icon.style.zIndex = this._zIndex + offset;
        },
        _animateZoom: function(opt) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
            this._setPos(pos);
        },
        _initInteraction: function() {
            if (!this.options.clickable) {
                return;
            }
            // TODO refactor into something shared with Map/Path/etc. to DRY it up
            var icon = this._icon, events = [ "dblclick", "mousedown", "mouseover", "mouseout", "contextmenu" ];
            L.DomUtil.addClass(icon, "leaflet-clickable");
            L.DomEvent.on(icon, "click", this._onMouseClick, this);
            L.DomEvent.on(icon, "keypress", this._onKeyPress, this);
            for (var i = 0; i < events.length; i++) {
                L.DomEvent.on(icon, events[i], this._fireMouseEvent, this);
            }
            if (L.Handler.MarkerDrag) {
                this.dragging = new L.Handler.MarkerDrag(this);
                if (this.options.draggable) {
                    this.dragging.enable();
                }
            }
        },
        _onMouseClick: function(e) {
            var wasDragged = this.dragging && this.dragging.moved();
            if (this.hasEventListeners(e.type) || wasDragged) {
                L.DomEvent.stopPropagation(e);
            }
            if (wasDragged) {
                return;
            }
            if ((!this.dragging || !this.dragging._enabled) && this._map.dragging && this._map.dragging.moved()) {
                return;
            }
            this.fire(e.type, {
                originalEvent: e,
                latlng: this._latlng
            });
        },
        _onKeyPress: function(e) {
            if (e.keyCode === 13) {
                this.fire("click", {
                    originalEvent: e,
                    latlng: this._latlng
                });
            }
        },
        _fireMouseEvent: function(e) {
            this.fire(e.type, {
                originalEvent: e,
                latlng: this._latlng
            });
            // TODO proper custom event propagation
            // this line will always be called if marker is in a FeatureGroup
            if (e.type === "contextmenu" && this.hasEventListeners(e.type)) {
                L.DomEvent.preventDefault(e);
            }
            if (e.type !== "mousedown") {
                L.DomEvent.stopPropagation(e);
            } else {
                L.DomEvent.preventDefault(e);
            }
        },
        setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._map) {
                this._updateOpacity();
            }
            return this;
        },
        _updateOpacity: function() {
            L.DomUtil.setOpacity(this._icon, this.options.opacity);
            if (this._shadow) {
                L.DomUtil.setOpacity(this._shadow, this.options.opacity);
            }
        },
        _bringToFront: function() {
            this._updateZIndex(this.options.riseOffset);
        },
        _resetZIndex: function() {
            this._updateZIndex(0);
        }
    });
    L.marker = function(latlng, options) {
        return new L.Marker(latlng, options);
    };
    /*
 * L.DivIcon is a lightweight HTML-based icon class (as opposed to the image-based L.Icon)
 * to use with L.Marker.
 */
    L.DivIcon = L.Icon.extend({
        options: {
            iconSize: [ 12, 12 ],
            // also can be set through CSS
            /*
		iconAnchor: (Point)
		popupAnchor: (Point)
		html: (String)
		bgPos: (Point)
		*/
            className: "leaflet-div-icon",
            html: false
        },
        createIcon: function(oldIcon) {
            var div = oldIcon && oldIcon.tagName === "DIV" ? oldIcon : document.createElement("div"), options = this.options;
            if (options.html !== false) {
                div.innerHTML = options.html;
            } else {
                div.innerHTML = "";
            }
            if (options.bgPos) {
                div.style.backgroundPosition = -options.bgPos.x + "px " + -options.bgPos.y + "px";
            }
            this._setIconStyles(div, "icon");
            return div;
        },
        createShadow: function() {
            return null;
        }
    });
    L.divIcon = function(options) {
        return new L.DivIcon(options);
    };
    /*
 * L.Popup is used for displaying popups on the map.
 */
    L.Map.mergeOptions({
        closePopupOnClick: true
    });
    L.Popup = L.Class.extend({
        includes: L.Mixin.Events,
        options: {
            minWidth: 50,
            maxWidth: 300,
            // maxHeight: null,
            autoPan: true,
            closeButton: true,
            offset: [ 0, 7 ],
            autoPanPadding: [ 5, 5 ],
            // autoPanPaddingTopLeft: null,
            // autoPanPaddingBottomRight: null,
            keepInView: false,
            className: "",
            zoomAnimation: true
        },
        initialize: function(options, source) {
            L.setOptions(this, options);
            this._source = source;
            this._animated = L.Browser.any3d && this.options.zoomAnimation;
            this._isOpen = false;
        },
        onAdd: function(map) {
            this._map = map;
            if (!this._container) {
                this._initLayout();
            }
            var animFade = map.options.fadeAnimation;
            if (animFade) {
                L.DomUtil.setOpacity(this._container, 0);
            }
            map._panes.popupPane.appendChild(this._container);
            map.on(this._getEvents(), this);
            this.update();
            if (animFade) {
                L.DomUtil.setOpacity(this._container, 1);
            }
            this.fire("open");
            map.fire("popupopen", {
                popup: this
            });
            if (this._source) {
                this._source.fire("popupopen", {
                    popup: this
                });
            }
        },
        addTo: function(map) {
            map.addLayer(this);
            return this;
        },
        openOn: function(map) {
            map.openPopup(this);
            return this;
        },
        onRemove: function(map) {
            map._panes.popupPane.removeChild(this._container);
            L.Util.falseFn(this._container.offsetWidth);
            // force reflow
            map.off(this._getEvents(), this);
            if (map.options.fadeAnimation) {
                L.DomUtil.setOpacity(this._container, 0);
            }
            this._map = null;
            this.fire("close");
            map.fire("popupclose", {
                popup: this
            });
            if (this._source) {
                this._source.fire("popupclose", {
                    popup: this
                });
            }
        },
        getLatLng: function() {
            return this._latlng;
        },
        setLatLng: function(latlng) {
            this._latlng = L.latLng(latlng);
            if (this._map) {
                this._updatePosition();
                this._adjustPan();
            }
            return this;
        },
        getContent: function() {
            return this._content;
        },
        setContent: function(content) {
            this._content = content;
            this.update();
            return this;
        },
        update: function() {
            if (!this._map) {
                return;
            }
            this._container.style.visibility = "hidden";
            this._updateContent();
            this._updateLayout();
            this._updatePosition();
            this._container.style.visibility = "";
            this._adjustPan();
        },
        _getEvents: function() {
            var events = {
                viewreset: this._updatePosition
            };
            if (this._animated) {
                events.zoomanim = this._zoomAnimation;
            }
            if ("closeOnClick" in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
                events.preclick = this._close;
            }
            if (this.options.keepInView) {
                events.moveend = this._adjustPan;
            }
            return events;
        },
        _close: function() {
            if (this._map) {
                this._map.closePopup(this);
            }
        },
        _initLayout: function() {
            var prefix = "leaflet-popup", containerClass = prefix + " " + this.options.className + " leaflet-zoom-" + (this._animated ? "animated" : "hide"), container = this._container = L.DomUtil.create("div", containerClass), closeButton;
            if (this.options.closeButton) {
                closeButton = this._closeButton = L.DomUtil.create("a", prefix + "-close-button", container);
                closeButton.href = "#close";
                closeButton.innerHTML = "&#215;";
                L.DomEvent.disableClickPropagation(closeButton);
                L.DomEvent.on(closeButton, "click", this._onCloseButtonClick, this);
            }
            var wrapper = this._wrapper = L.DomUtil.create("div", prefix + "-content-wrapper", container);
            L.DomEvent.disableClickPropagation(wrapper);
            this._contentNode = L.DomUtil.create("div", prefix + "-content", wrapper);
            L.DomEvent.disableScrollPropagation(this._contentNode);
            L.DomEvent.on(wrapper, "contextmenu", L.DomEvent.stopPropagation);
            this._tipContainer = L.DomUtil.create("div", prefix + "-tip-container", container);
            this._tip = L.DomUtil.create("div", prefix + "-tip", this._tipContainer);
        },
        _updateContent: function() {
            if (!this._content) {
                return;
            }
            if (typeof this._content === "string") {
                this._contentNode.innerHTML = this._content;
            } else {
                while (this._contentNode.hasChildNodes()) {
                    this._contentNode.removeChild(this._contentNode.firstChild);
                }
                this._contentNode.appendChild(this._content);
            }
            this.fire("contentupdate");
        },
        _updateLayout: function() {
            var container = this._contentNode, style = container.style;
            style.width = "";
            style.whiteSpace = "nowrap";
            var width = container.offsetWidth;
            width = Math.min(width, this.options.maxWidth);
            width = Math.max(width, this.options.minWidth);
            style.width = width + 1 + "px";
            style.whiteSpace = "";
            style.height = "";
            var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = "leaflet-popup-scrolled";
            if (maxHeight && height > maxHeight) {
                style.height = maxHeight + "px";
                L.DomUtil.addClass(container, scrolledClass);
            } else {
                L.DomUtil.removeClass(container, scrolledClass);
            }
            this._containerWidth = this._container.offsetWidth;
        },
        _updatePosition: function() {
            if (!this._map) {
                return;
            }
            var pos = this._map.latLngToLayerPoint(this._latlng), animated = this._animated, offset = L.point(this.options.offset);
            if (animated) {
                L.DomUtil.setPosition(this._container, pos);
            }
            this._containerBottom = -offset.y - (animated ? 0 : pos.y);
            this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x + (animated ? 0 : pos.x);
            // bottom position the popup in case the height of the popup changes (images loading etc)
            this._container.style.bottom = this._containerBottom + "px";
            this._container.style.left = this._containerLeft + "px";
        },
        _zoomAnimation: function(opt) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center);
            L.DomUtil.setPosition(this._container, pos);
        },
        _adjustPan: function() {
            if (!this.options.autoPan) {
                return;
            }
            var map = this._map, containerHeight = this._container.offsetHeight, containerWidth = this._containerWidth, layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);
            if (this._animated) {
                layerPos._add(L.DomUtil.getPosition(this._container));
            }
            var containerPos = map.layerPointToContainerPoint(layerPos), padding = L.point(this.options.autoPanPadding), paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding), paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding), size = map.getSize(), dx = 0, dy = 0;
            if (containerPos.x + containerWidth + paddingBR.x > size.x) {
                // right
                dx = containerPos.x + containerWidth - size.x + paddingBR.x;
            }
            if (containerPos.x - dx - paddingTL.x < 0) {
                // left
                dx = containerPos.x - paddingTL.x;
            }
            if (containerPos.y + containerHeight + paddingBR.y > size.y) {
                // bottom
                dy = containerPos.y + containerHeight - size.y + paddingBR.y;
            }
            if (containerPos.y - dy - paddingTL.y < 0) {
                // top
                dy = containerPos.y - paddingTL.y;
            }
            if (dx || dy) {
                map.fire("autopanstart").panBy([ dx, dy ]);
            }
        },
        _onCloseButtonClick: function(e) {
            this._close();
            L.DomEvent.stop(e);
        }
    });
    L.popup = function(options, source) {
        return new L.Popup(options, source);
    };
    L.Map.include({
        openPopup: function(popup, latlng, options) {
            // (Popup) or (String || HTMLElement, LatLng[, Object])
            this.closePopup();
            if (!(popup instanceof L.Popup)) {
                var content = popup;
                popup = new L.Popup(options).setLatLng(latlng).setContent(content);
            }
            popup._isOpen = true;
            this._popup = popup;
            return this.addLayer(popup);
        },
        closePopup: function(popup) {
            if (!popup || popup === this._popup) {
                popup = this._popup;
                this._popup = null;
            }
            if (popup) {
                this.removeLayer(popup);
                popup._isOpen = false;
            }
            return this;
        }
    });
    /*
 * Popup extension to L.Marker, adding popup-related methods.
 */
    L.Marker.include({
        openPopup: function() {
            if (this._popup && this._map && !this._map.hasLayer(this._popup)) {
                this._popup.setLatLng(this._latlng);
                this._map.openPopup(this._popup);
            }
            return this;
        },
        closePopup: function() {
            if (this._popup) {
                this._popup._close();
            }
            return this;
        },
        togglePopup: function() {
            if (this._popup) {
                if (this._popup._isOpen) {
                    this.closePopup();
                } else {
                    this.openPopup();
                }
            }
            return this;
        },
        bindPopup: function(content, options) {
            var anchor = L.point(this.options.icon.options.popupAnchor || [ 0, 0 ]);
            anchor = anchor.add(L.Popup.prototype.options.offset);
            if (options && options.offset) {
                anchor = anchor.add(options.offset);
            }
            options = L.extend({
                offset: anchor
            }, options);
            if (!this._popupHandlersAdded) {
                this.on("click", this.togglePopup, this).on("remove", this.closePopup, this).on("move", this._movePopup, this);
                this._popupHandlersAdded = true;
            }
            if (content instanceof L.Popup) {
                L.setOptions(content, options);
                this._popup = content;
            } else {
                this._popup = new L.Popup(options, this).setContent(content);
            }
            return this;
        },
        setPopupContent: function(content) {
            if (this._popup) {
                this._popup.setContent(content);
            }
            return this;
        },
        unbindPopup: function() {
            if (this._popup) {
                this._popup = null;
                this.off("click", this.togglePopup, this).off("remove", this.closePopup, this).off("move", this._movePopup, this);
                this._popupHandlersAdded = false;
            }
            return this;
        },
        getPopup: function() {
            return this._popup;
        },
        _movePopup: function(e) {
            this._popup.setLatLng(e.latlng);
        }
    });
    /*
 * L.LayerGroup is a class to combine several layers into one so that
 * you can manipulate the group (e.g. add/remove it) as one layer.
 */
    L.LayerGroup = L.Class.extend({
        initialize: function(layers) {
            this._layers = {};
            var i, len;
            if (layers) {
                for (i = 0, len = layers.length; i < len; i++) {
                    this.addLayer(layers[i]);
                }
            }
        },
        addLayer: function(layer) {
            var id = this.getLayerId(layer);
            this._layers[id] = layer;
            if (this._map) {
                this._map.addLayer(layer);
            }
            return this;
        },
        removeLayer: function(layer) {
            var id = layer in this._layers ? layer : this.getLayerId(layer);
            if (this._map && this._layers[id]) {
                this._map.removeLayer(this._layers[id]);
            }
            delete this._layers[id];
            return this;
        },
        hasLayer: function(layer) {
            if (!layer) {
                return false;
            }
            return layer in this._layers || this.getLayerId(layer) in this._layers;
        },
        clearLayers: function() {
            this.eachLayer(this.removeLayer, this);
            return this;
        },
        invoke: function(methodName) {
            var args = Array.prototype.slice.call(arguments, 1), i, layer;
            for (i in this._layers) {
                layer = this._layers[i];
                if (layer[methodName]) {
                    layer[methodName].apply(layer, args);
                }
            }
            return this;
        },
        onAdd: function(map) {
            this._map = map;
            this.eachLayer(map.addLayer, map);
        },
        onRemove: function(map) {
            this.eachLayer(map.removeLayer, map);
            this._map = null;
        },
        addTo: function(map) {
            map.addLayer(this);
            return this;
        },
        eachLayer: function(method, context) {
            for (var i in this._layers) {
                method.call(context, this._layers[i]);
            }
            return this;
        },
        getLayer: function(id) {
            return this._layers[id];
        },
        getLayers: function() {
            var layers = [];
            for (var i in this._layers) {
                layers.push(this._layers[i]);
            }
            return layers;
        },
        setZIndex: function(zIndex) {
            return this.invoke("setZIndex", zIndex);
        },
        getLayerId: function(layer) {
            return L.stamp(layer);
        }
    });
    L.layerGroup = function(layers) {
        return new L.LayerGroup(layers);
    };
    /*
 * L.FeatureGroup extends L.LayerGroup by introducing mouse events and additional methods
 * shared between a group of interactive layers (like vectors or markers).
 */
    L.FeatureGroup = L.LayerGroup.extend({
        includes: L.Mixin.Events,
        statics: {
            EVENTS: "click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose"
        },
        addLayer: function(layer) {
            if (this.hasLayer(layer)) {
                return this;
            }
            if ("on" in layer) {
                layer.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);
            }
            L.LayerGroup.prototype.addLayer.call(this, layer);
            if (this._popupContent && layer.bindPopup) {
                layer.bindPopup(this._popupContent, this._popupOptions);
            }
            return this.fire("layeradd", {
                layer: layer
            });
        },
        removeLayer: function(layer) {
            if (!this.hasLayer(layer)) {
                return this;
            }
            if (layer in this._layers) {
                layer = this._layers[layer];
            }
            layer.off(L.FeatureGroup.EVENTS, this._propagateEvent, this);
            L.LayerGroup.prototype.removeLayer.call(this, layer);
            if (this._popupContent) {
                this.invoke("unbindPopup");
            }
            return this.fire("layerremove", {
                layer: layer
            });
        },
        bindPopup: function(content, options) {
            this._popupContent = content;
            this._popupOptions = options;
            return this.invoke("bindPopup", content, options);
        },
        openPopup: function(latlng) {
            // open popup on the first layer
            for (var id in this._layers) {
                this._layers[id].openPopup(latlng);
                break;
            }
            return this;
        },
        setStyle: function(style) {
            return this.invoke("setStyle", style);
        },
        bringToFront: function() {
            return this.invoke("bringToFront");
        },
        bringToBack: function() {
            return this.invoke("bringToBack");
        },
        getBounds: function() {
            var bounds = new L.LatLngBounds();
            this.eachLayer(function(layer) {
                bounds.extend(layer instanceof L.Marker ? layer.getLatLng() : layer.getBounds());
            });
            return bounds;
        },
        _propagateEvent: function(e) {
            e = L.extend({
                layer: e.target,
                target: this
            }, e);
            this.fire(e.type, e);
        }
    });
    L.featureGroup = function(layers) {
        return new L.FeatureGroup(layers);
    };
    /*
 * L.Path is a base class for rendering vector paths on a map. Inherited by Polyline, Circle, etc.
 */
    L.Path = L.Class.extend({
        includes: [ L.Mixin.Events ],
        statics: {
            // how much to extend the clip area around the map view
            // (relative to its size, e.g. 0.5 is half the screen in each direction)
            // set it so that SVG element doesn't exceed 1280px (vectors flicker on dragend if it is)
            CLIP_PADDING: function() {
                var max = L.Browser.mobile ? 1280 : 2e3, target = (max / Math.max(window.outerWidth, window.outerHeight) - 1) / 2;
                return Math.max(0, Math.min(.5, target));
            }()
        },
        options: {
            stroke: true,
            color: "#0033ff",
            dashArray: null,
            lineCap: null,
            lineJoin: null,
            weight: 5,
            opacity: .5,
            fill: false,
            fillColor: null,
            //same as color by default
            fillOpacity: .2,
            clickable: true
        },
        initialize: function(options) {
            L.setOptions(this, options);
        },
        onAdd: function(map) {
            this._map = map;
            if (!this._container) {
                this._initElements();
                this._initEvents();
            }
            this.projectLatlngs();
            this._updatePath();
            if (this._container) {
                this._map._pathRoot.appendChild(this._container);
            }
            this.fire("add");
            map.on({
                viewreset: this.projectLatlngs,
                moveend: this._updatePath
            }, this);
        },
        addTo: function(map) {
            map.addLayer(this);
            return this;
        },
        onRemove: function(map) {
            map._pathRoot.removeChild(this._container);
            // Need to fire remove event before we set _map to null as the event hooks might need the object
            this.fire("remove");
            this._map = null;
            if (L.Browser.vml) {
                this._container = null;
                this._stroke = null;
                this._fill = null;
            }
            map.off({
                viewreset: this.projectLatlngs,
                moveend: this._updatePath
            }, this);
        },
        projectLatlngs: function() {},
        setStyle: function(style) {
            L.setOptions(this, style);
            if (this._container) {
                this._updateStyle();
            }
            return this;
        },
        redraw: function() {
            if (this._map) {
                this.projectLatlngs();
                this._updatePath();
            }
            return this;
        }
    });
    L.Map.include({
        _updatePathViewport: function() {
            var p = L.Path.CLIP_PADDING, size = this.getSize(), panePos = L.DomUtil.getPosition(this._mapPane), min = panePos.multiplyBy(-1)._subtract(size.multiplyBy(p)._round()), max = min.add(size.multiplyBy(1 + p * 2)._round());
            this._pathViewport = new L.Bounds(min, max);
        }
    });
    /*
 * Extends L.Path with SVG-specific rendering code.
 */
    L.Path.SVG_NS = "http://www.w3.org/2000/svg";
    L.Browser.svg = !!(document.createElementNS && document.createElementNS(L.Path.SVG_NS, "svg").createSVGRect);
    L.Path = L.Path.extend({
        statics: {
            SVG: L.Browser.svg
        },
        bringToFront: function() {
            var root = this._map._pathRoot, path = this._container;
            if (path && root.lastChild !== path) {
                root.appendChild(path);
            }
            return this;
        },
        bringToBack: function() {
            var root = this._map._pathRoot, path = this._container, first = root.firstChild;
            if (path && first !== path) {
                root.insertBefore(path, first);
            }
            return this;
        },
        getPathString: function() {},
        _createElement: function(name) {
            return document.createElementNS(L.Path.SVG_NS, name);
        },
        _initElements: function() {
            this._map._initPathRoot();
            this._initPath();
            this._initStyle();
        },
        _initPath: function() {
            this._container = this._createElement("g");
            this._path = this._createElement("path");
            if (this.options.className) {
                L.DomUtil.addClass(this._path, this.options.className);
            }
            this._container.appendChild(this._path);
        },
        _initStyle: function() {
            if (this.options.stroke) {
                this._path.setAttribute("stroke-linejoin", "round");
                this._path.setAttribute("stroke-linecap", "round");
            }
            if (this.options.fill) {
                this._path.setAttribute("fill-rule", "evenodd");
            }
            if (this.options.pointerEvents) {
                this._path.setAttribute("pointer-events", this.options.pointerEvents);
            }
            if (!this.options.clickable && !this.options.pointerEvents) {
                this._path.setAttribute("pointer-events", "none");
            }
            this._updateStyle();
        },
        _updateStyle: function() {
            if (this.options.stroke) {
                this._path.setAttribute("stroke", this.options.color);
                this._path.setAttribute("stroke-opacity", this.options.opacity);
                this._path.setAttribute("stroke-width", this.options.weight);
                if (this.options.dashArray) {
                    this._path.setAttribute("stroke-dasharray", this.options.dashArray);
                } else {
                    this._path.removeAttribute("stroke-dasharray");
                }
                if (this.options.lineCap) {
                    this._path.setAttribute("stroke-linecap", this.options.lineCap);
                }
                if (this.options.lineJoin) {
                    this._path.setAttribute("stroke-linejoin", this.options.lineJoin);
                }
            } else {
                this._path.setAttribute("stroke", "none");
            }
            if (this.options.fill) {
                this._path.setAttribute("fill", this.options.fillColor || this.options.color);
                this._path.setAttribute("fill-opacity", this.options.fillOpacity);
            } else {
                this._path.setAttribute("fill", "none");
            }
        },
        _updatePath: function() {
            var str = this.getPathString();
            if (!str) {
                // fix webkit empty string parsing bug
                str = "M0 0";
            }
            this._path.setAttribute("d", str);
        },
        // TODO remove duplication with L.Map
        _initEvents: function() {
            if (this.options.clickable) {
                if (L.Browser.svg || !L.Browser.vml) {
                    L.DomUtil.addClass(this._path, "leaflet-clickable");
                }
                L.DomEvent.on(this._container, "click", this._onMouseClick, this);
                var events = [ "dblclick", "mousedown", "mouseover", "mouseout", "mousemove", "contextmenu" ];
                for (var i = 0; i < events.length; i++) {
                    L.DomEvent.on(this._container, events[i], this._fireMouseEvent, this);
                }
            }
        },
        _onMouseClick: function(e) {
            if (this._map.dragging && this._map.dragging.moved()) {
                return;
            }
            this._fireMouseEvent(e);
        },
        _fireMouseEvent: function(e) {
            if (!this.hasEventListeners(e.type)) {
                return;
            }
            var map = this._map, containerPoint = map.mouseEventToContainerPoint(e), layerPoint = map.containerPointToLayerPoint(containerPoint), latlng = map.layerPointToLatLng(layerPoint);
            this.fire(e.type, {
                latlng: latlng,
                layerPoint: layerPoint,
                containerPoint: containerPoint,
                originalEvent: e
            });
            if (e.type === "contextmenu") {
                L.DomEvent.preventDefault(e);
            }
            if (e.type !== "mousemove") {
                L.DomEvent.stopPropagation(e);
            }
        }
    });
    L.Map.include({
        _initPathRoot: function() {
            if (!this._pathRoot) {
                this._pathRoot = L.Path.prototype._createElement("svg");
                this._panes.overlayPane.appendChild(this._pathRoot);
                if (this.options.zoomAnimation && L.Browser.any3d) {
                    L.DomUtil.addClass(this._pathRoot, "leaflet-zoom-animated");
                    this.on({
                        zoomanim: this._animatePathZoom,
                        zoomend: this._endPathZoom
                    });
                } else {
                    L.DomUtil.addClass(this._pathRoot, "leaflet-zoom-hide");
                }
                this.on("moveend", this._updateSvgViewport);
                this._updateSvgViewport();
            }
        },
        _animatePathZoom: function(e) {
            var scale = this.getZoomScale(e.zoom), offset = this._getCenterOffset(e.center)._multiplyBy(-scale)._add(this._pathViewport.min);
            this._pathRoot.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(offset) + " scale(" + scale + ") ";
            this._pathZooming = true;
        },
        _endPathZoom: function() {
            this._pathZooming = false;
        },
        _updateSvgViewport: function() {
            if (this._pathZooming) {
                // Do not update SVGs while a zoom animation is going on otherwise the animation will break.
                // When the zoom animation ends we will be updated again anyway
                // This fixes the case where you do a momentum move and zoom while the move is still ongoing.
                return;
            }
            this._updatePathViewport();
            var vp = this._pathViewport, min = vp.min, max = vp.max, width = max.x - min.x, height = max.y - min.y, root = this._pathRoot, pane = this._panes.overlayPane;
            // Hack to make flicker on drag end on mobile webkit less irritating
            if (L.Browser.mobileWebkit) {
                pane.removeChild(root);
            }
            L.DomUtil.setPosition(root, min);
            root.setAttribute("width", width);
            root.setAttribute("height", height);
            root.setAttribute("viewBox", [ min.x, min.y, width, height ].join(" "));
            if (L.Browser.mobileWebkit) {
                pane.appendChild(root);
            }
        }
    });
    /*
 * Popup extension to L.Path (polylines, polygons, circles), adding popup-related methods.
 */
    L.Path.include({
        bindPopup: function(content, options) {
            if (content instanceof L.Popup) {
                this._popup = content;
            } else {
                if (!this._popup || options) {
                    this._popup = new L.Popup(options, this);
                }
                this._popup.setContent(content);
            }
            if (!this._popupHandlersAdded) {
                this.on("click", this._openPopup, this).on("remove", this.closePopup, this);
                this._popupHandlersAdded = true;
            }
            return this;
        },
        unbindPopup: function() {
            if (this._popup) {
                this._popup = null;
                this.off("click", this._openPopup).off("remove", this.closePopup);
                this._popupHandlersAdded = false;
            }
            return this;
        },
        openPopup: function(latlng) {
            if (this._popup) {
                // open the popup from one of the path's points if not specified
                latlng = latlng || this._latlng || this._latlngs[Math.floor(this._latlngs.length / 2)];
                this._openPopup({
                    latlng: latlng
                });
            }
            return this;
        },
        closePopup: function() {
            if (this._popup) {
                this._popup._close();
            }
            return this;
        },
        _openPopup: function(e) {
            this._popup.setLatLng(e.latlng);
            this._map.openPopup(this._popup);
        }
    });
    /*
 * Vector rendering for IE6-8 through VML.
 * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
 */
    L.Browser.vml = !L.Browser.svg && function() {
        try {
            var div = document.createElement("div");
            div.innerHTML = '<v:shape adj="1"/>';
            var shape = div.firstChild;
            shape.style.behavior = "url(#default#VML)";
            return shape && typeof shape.adj === "object";
        } catch (e) {
            return false;
        }
    }();
    L.Path = L.Browser.svg || !L.Browser.vml ? L.Path : L.Path.extend({
        statics: {
            VML: true,
            CLIP_PADDING: .02
        },
        _createElement: function() {
            try {
                document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml");
                return function(name) {
                    return document.createElement("<lvml:" + name + ' class="lvml">');
                };
            } catch (e) {
                return function(name) {
                    return document.createElement("<" + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
                };
            }
        }(),
        _initPath: function() {
            var container = this._container = this._createElement("shape");
            L.DomUtil.addClass(container, "leaflet-vml-shape" + (this.options.className ? " " + this.options.className : ""));
            if (this.options.clickable) {
                L.DomUtil.addClass(container, "leaflet-clickable");
            }
            container.coordsize = "1 1";
            this._path = this._createElement("path");
            container.appendChild(this._path);
            this._map._pathRoot.appendChild(container);
        },
        _initStyle: function() {
            this._updateStyle();
        },
        _updateStyle: function() {
            var stroke = this._stroke, fill = this._fill, options = this.options, container = this._container;
            container.stroked = options.stroke;
            container.filled = options.fill;
            if (options.stroke) {
                if (!stroke) {
                    stroke = this._stroke = this._createElement("stroke");
                    stroke.endcap = "round";
                    container.appendChild(stroke);
                }
                stroke.weight = options.weight + "px";
                stroke.color = options.color;
                stroke.opacity = options.opacity;
                if (options.dashArray) {
                    stroke.dashStyle = L.Util.isArray(options.dashArray) ? options.dashArray.join(" ") : options.dashArray.replace(/( *, *)/g, " ");
                } else {
                    stroke.dashStyle = "";
                }
                if (options.lineCap) {
                    stroke.endcap = options.lineCap.replace("butt", "flat");
                }
                if (options.lineJoin) {
                    stroke.joinstyle = options.lineJoin;
                }
            } else if (stroke) {
                container.removeChild(stroke);
                this._stroke = null;
            }
            if (options.fill) {
                if (!fill) {
                    fill = this._fill = this._createElement("fill");
                    container.appendChild(fill);
                }
                fill.color = options.fillColor || options.color;
                fill.opacity = options.fillOpacity;
            } else if (fill) {
                container.removeChild(fill);
                this._fill = null;
            }
        },
        _updatePath: function() {
            var style = this._container.style;
            style.display = "none";
            this._path.v = this.getPathString() + " ";
            // the space fixes IE empty path string bug
            style.display = "";
        }
    });
    L.Map.include(L.Browser.svg || !L.Browser.vml ? {} : {
        _initPathRoot: function() {
            if (this._pathRoot) {
                return;
            }
            var root = this._pathRoot = document.createElement("div");
            root.className = "leaflet-vml-container";
            this._panes.overlayPane.appendChild(root);
            this.on("moveend", this._updatePathViewport);
            this._updatePathViewport();
        }
    });
    /*
 * Vector rendering for all browsers that support canvas.
 */
    L.Browser.canvas = function() {
        return !!document.createElement("canvas").getContext;
    }();
    L.Path = L.Path.SVG && !window.L_PREFER_CANVAS || !L.Browser.canvas ? L.Path : L.Path.extend({
        statics: {
            //CLIP_PADDING: 0.02, // not sure if there's a need to set it to a small value
            CANVAS: true,
            SVG: false
        },
        redraw: function() {
            if (this._map) {
                this.projectLatlngs();
                this._requestUpdate();
            }
            return this;
        },
        setStyle: function(style) {
            L.setOptions(this, style);
            if (this._map) {
                this._updateStyle();
                this._requestUpdate();
            }
            return this;
        },
        onRemove: function(map) {
            map.off("viewreset", this.projectLatlngs, this).off("moveend", this._updatePath, this);
            if (this.options.clickable) {
                this._map.off("click", this._onClick, this);
                this._map.off("mousemove", this._onMouseMove, this);
            }
            this._requestUpdate();
            this.fire("remove");
            this._map = null;
        },
        _requestUpdate: function() {
            if (this._map && !L.Path._updateRequest) {
                L.Path._updateRequest = L.Util.requestAnimFrame(this._fireMapMoveEnd, this._map);
            }
        },
        _fireMapMoveEnd: function() {
            L.Path._updateRequest = null;
            this.fire("moveend");
        },
        _initElements: function() {
            this._map._initPathRoot();
            this._ctx = this._map._canvasCtx;
        },
        _updateStyle: function() {
            var options = this.options;
            if (options.stroke) {
                this._ctx.lineWidth = options.weight;
                this._ctx.strokeStyle = options.color;
            }
            if (options.fill) {
                this._ctx.fillStyle = options.fillColor || options.color;
            }
        },
        _drawPath: function() {
            var i, j, len, len2, point, drawMethod;
            this._ctx.beginPath();
            for (i = 0, len = this._parts.length; i < len; i++) {
                for (j = 0, len2 = this._parts[i].length; j < len2; j++) {
                    point = this._parts[i][j];
                    drawMethod = (j === 0 ? "move" : "line") + "To";
                    this._ctx[drawMethod](point.x, point.y);
                }
                // TODO refactor ugly hack
                if (this instanceof L.Polygon) {
                    this._ctx.closePath();
                }
            }
        },
        _checkIfEmpty: function() {
            return !this._parts.length;
        },
        _updatePath: function() {
            if (this._checkIfEmpty()) {
                return;
            }
            var ctx = this._ctx, options = this.options;
            this._drawPath();
            ctx.save();
            this._updateStyle();
            if (options.fill) {
                ctx.globalAlpha = options.fillOpacity;
                ctx.fill();
            }
            if (options.stroke) {
                ctx.globalAlpha = options.opacity;
                ctx.stroke();
            }
            ctx.restore();
        },
        _initEvents: function() {
            if (this.options.clickable) {
                // TODO dblclick
                this._map.on("mousemove", this._onMouseMove, this);
                this._map.on("click", this._onClick, this);
            }
        },
        _onClick: function(e) {
            if (this._containsPoint(e.layerPoint)) {
                this.fire("click", e);
            }
        },
        _onMouseMove: function(e) {
            if (!this._map || this._map._animatingZoom) {
                return;
            }
            // TODO don't do on each move
            if (this._containsPoint(e.layerPoint)) {
                this._ctx.canvas.style.cursor = "pointer";
                this._mouseInside = true;
                this.fire("mouseover", e);
            } else if (this._mouseInside) {
                this._ctx.canvas.style.cursor = "";
                this._mouseInside = false;
                this.fire("mouseout", e);
            }
        }
    });
    L.Map.include(L.Path.SVG && !window.L_PREFER_CANVAS || !L.Browser.canvas ? {} : {
        _initPathRoot: function() {
            var root = this._pathRoot, ctx;
            if (!root) {
                root = this._pathRoot = document.createElement("canvas");
                root.style.position = "absolute";
                ctx = this._canvasCtx = root.getContext("2d");
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
                this._panes.overlayPane.appendChild(root);
                if (this.options.zoomAnimation) {
                    this._pathRoot.className = "leaflet-zoom-animated";
                    this.on("zoomanim", this._animatePathZoom);
                    this.on("zoomend", this._endPathZoom);
                }
                this.on("moveend", this._updateCanvasViewport);
                this._updateCanvasViewport();
            }
        },
        _updateCanvasViewport: function() {
            // don't redraw while zooming. See _updateSvgViewport for more details
            if (this._pathZooming) {
                return;
            }
            this._updatePathViewport();
            var vp = this._pathViewport, min = vp.min, size = vp.max.subtract(min), root = this._pathRoot;
            //TODO check if this works properly on mobile webkit
            L.DomUtil.setPosition(root, min);
            root.width = size.x;
            root.height = size.y;
            root.getContext("2d").translate(-min.x, -min.y);
        }
    });
    /*
 * L.LineUtil contains different utility functions for line segments
 * and polylines (clipping, simplification, distances, etc.)
 */
    /*jshint bitwise:false */
    // allow bitwise operations for this file
    L.LineUtil = {
        // Simplify polyline with vertex reduction and Douglas-Peucker simplification.
        // Improves rendering performance dramatically by lessening the number of points to draw.
        simplify: function(/*Point[]*/ points, /*Number*/ tolerance) {
            if (!tolerance || !points.length) {
                return points.slice();
            }
            var sqTolerance = tolerance * tolerance;
            // stage 1: vertex reduction
            points = this._reducePoints(points, sqTolerance);
            // stage 2: Douglas-Peucker simplification
            points = this._simplifyDP(points, sqTolerance);
            return points;
        },
        // distance from a point to a segment between two points
        pointToSegmentDistance: function(/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {
            return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));
        },
        closestPointOnSegment: function(/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {
            return this._sqClosestPointOnSegment(p, p1, p2);
        },
        // Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
        _simplifyDP: function(points, sqTolerance) {
            var len = points.length, ArrayConstructor = typeof Uint8Array !== undefined + "" ? Uint8Array : Array, markers = new ArrayConstructor(len);
            markers[0] = markers[len - 1] = 1;
            this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);
            var i, newPoints = [];
            for (i = 0; i < len; i++) {
                if (markers[i]) {
                    newPoints.push(points[i]);
                }
            }
            return newPoints;
        },
        _simplifyDPStep: function(points, markers, sqTolerance, first, last) {
            var maxSqDist = 0, index, i, sqDist;
            for (i = first + 1; i <= last - 1; i++) {
                sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);
                if (sqDist > maxSqDist) {
                    index = i;
                    maxSqDist = sqDist;
                }
            }
            if (maxSqDist > sqTolerance) {
                markers[index] = 1;
                this._simplifyDPStep(points, markers, sqTolerance, first, index);
                this._simplifyDPStep(points, markers, sqTolerance, index, last);
            }
        },
        // reduce points that are too close to each other to a single point
        _reducePoints: function(points, sqTolerance) {
            var reducedPoints = [ points[0] ];
            for (var i = 1, prev = 0, len = points.length; i < len; i++) {
                if (this._sqDist(points[i], points[prev]) > sqTolerance) {
                    reducedPoints.push(points[i]);
                    prev = i;
                }
            }
            if (prev < len - 1) {
                reducedPoints.push(points[len - 1]);
            }
            return reducedPoints;
        },
        // Cohen-Sutherland line clipping algorithm.
        // Used to avoid rendering parts of a polyline that are not currently visible.
        clipSegment: function(a, b, bounds, useLastCode) {
            var codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds), codeB = this._getBitCode(b, bounds), codeOut, p, newCode;
            // save 2nd code to avoid calculating it on the next segment
            this._lastCode = codeB;
            while (true) {
                // if a,b is inside the clip window (trivial accept)
                if (!(codeA | codeB)) {
                    return [ a, b ];
                } else if (codeA & codeB) {
                    return false;
                } else {
                    codeOut = codeA || codeB;
                    p = this._getEdgeIntersection(a, b, codeOut, bounds);
                    newCode = this._getBitCode(p, bounds);
                    if (codeOut === codeA) {
                        a = p;
                        codeA = newCode;
                    } else {
                        b = p;
                        codeB = newCode;
                    }
                }
            }
        },
        _getEdgeIntersection: function(a, b, code, bounds) {
            var dx = b.x - a.x, dy = b.y - a.y, min = bounds.min, max = bounds.max;
            if (code & 8) {
                // top
                return new L.Point(a.x + dx * (max.y - a.y) / dy, max.y);
            } else if (code & 4) {
                // bottom
                return new L.Point(a.x + dx * (min.y - a.y) / dy, min.y);
            } else if (code & 2) {
                // right
                return new L.Point(max.x, a.y + dy * (max.x - a.x) / dx);
            } else if (code & 1) {
                // left
                return new L.Point(min.x, a.y + dy * (min.x - a.x) / dx);
            }
        },
        _getBitCode: function(/*Point*/ p, bounds) {
            var code = 0;
            if (p.x < bounds.min.x) {
                // left
                code |= 1;
            } else if (p.x > bounds.max.x) {
                // right
                code |= 2;
            }
            if (p.y < bounds.min.y) {
                // bottom
                code |= 4;
            } else if (p.y > bounds.max.y) {
                // top
                code |= 8;
            }
            return code;
        },
        // square distance (to avoid unnecessary Math.sqrt calls)
        _sqDist: function(p1, p2) {
            var dx = p2.x - p1.x, dy = p2.y - p1.y;
            return dx * dx + dy * dy;
        },
        // return closest point on segment or distance to that point
        _sqClosestPointOnSegment: function(p, p1, p2, sqDist) {
            var x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y, dot = dx * dx + dy * dy, t;
            if (dot > 0) {
                t = ((p.x - x) * dx + (p.y - y) * dy) / dot;
                if (t > 1) {
                    x = p2.x;
                    y = p2.y;
                } else if (t > 0) {
                    x += dx * t;
                    y += dy * t;
                }
            }
            dx = p.x - x;
            dy = p.y - y;
            return sqDist ? dx * dx + dy * dy : new L.Point(x, y);
        }
    };
    /*
 * L.Polyline is used to display polylines on a map.
 */
    L.Polyline = L.Path.extend({
        initialize: function(latlngs, options) {
            L.Path.prototype.initialize.call(this, options);
            this._latlngs = this._convertLatLngs(latlngs);
        },
        options: {
            // how much to simplify the polyline on each zoom level
            // more = better performance and smoother look, less = more accurate
            smoothFactor: 1,
            noClip: false
        },
        projectLatlngs: function() {
            this._originalPoints = [];
            for (var i = 0, len = this._latlngs.length; i < len; i++) {
                this._originalPoints[i] = this._map.latLngToLayerPoint(this._latlngs[i]);
            }
        },
        getPathString: function() {
            for (var i = 0, len = this._parts.length, str = ""; i < len; i++) {
                str += this._getPathPartStr(this._parts[i]);
            }
            return str;
        },
        getLatLngs: function() {
            return this._latlngs;
        },
        setLatLngs: function(latlngs) {
            this._latlngs = this._convertLatLngs(latlngs);
            return this.redraw();
        },
        addLatLng: function(latlng) {
            this._latlngs.push(L.latLng(latlng));
            return this.redraw();
        },
        spliceLatLngs: function() {
            // (Number index, Number howMany)
            var removed = [].splice.apply(this._latlngs, arguments);
            this._convertLatLngs(this._latlngs, true);
            this.redraw();
            return removed;
        },
        closestLayerPoint: function(p) {
            var minDistance = Infinity, parts = this._parts, p1, p2, minPoint = null;
            for (var j = 0, jLen = parts.length; j < jLen; j++) {
                var points = parts[j];
                for (var i = 1, len = points.length; i < len; i++) {
                    p1 = points[i - 1];
                    p2 = points[i];
                    var sqDist = L.LineUtil._sqClosestPointOnSegment(p, p1, p2, true);
                    if (sqDist < minDistance) {
                        minDistance = sqDist;
                        minPoint = L.LineUtil._sqClosestPointOnSegment(p, p1, p2);
                    }
                }
            }
            if (minPoint) {
                minPoint.distance = Math.sqrt(minDistance);
            }
            return minPoint;
        },
        getBounds: function() {
            return new L.LatLngBounds(this.getLatLngs());
        },
        _convertLatLngs: function(latlngs, overwrite) {
            var i, len, target = overwrite ? latlngs : [];
            for (i = 0, len = latlngs.length; i < len; i++) {
                if (L.Util.isArray(latlngs[i]) && typeof latlngs[i][0] !== "number") {
                    return;
                }
                target[i] = L.latLng(latlngs[i]);
            }
            return target;
        },
        _initEvents: function() {
            L.Path.prototype._initEvents.call(this);
        },
        _getPathPartStr: function(points) {
            var round = L.Path.VML;
            for (var j = 0, len2 = points.length, str = "", p; j < len2; j++) {
                p = points[j];
                if (round) {
                    p._round();
                }
                str += (j ? "L" : "M") + p.x + " " + p.y;
            }
            return str;
        },
        _clipPoints: function() {
            var points = this._originalPoints, len = points.length, i, k, segment;
            if (this.options.noClip) {
                this._parts = [ points ];
                return;
            }
            this._parts = [];
            var parts = this._parts, vp = this._map._pathViewport, lu = L.LineUtil;
            for (i = 0, k = 0; i < len - 1; i++) {
                segment = lu.clipSegment(points[i], points[i + 1], vp, i);
                if (!segment) {
                    continue;
                }
                parts[k] = parts[k] || [];
                parts[k].push(segment[0]);
                // if segment goes out of screen, or it's the last one, it's the end of the line part
                if (segment[1] !== points[i + 1] || i === len - 2) {
                    parts[k].push(segment[1]);
                    k++;
                }
            }
        },
        // simplify each clipped part of the polyline
        _simplifyPoints: function() {
            var parts = this._parts, lu = L.LineUtil;
            for (var i = 0, len = parts.length; i < len; i++) {
                parts[i] = lu.simplify(parts[i], this.options.smoothFactor);
            }
        },
        _updatePath: function() {
            if (!this._map) {
                return;
            }
            this._clipPoints();
            this._simplifyPoints();
            L.Path.prototype._updatePath.call(this);
        }
    });
    L.polyline = function(latlngs, options) {
        return new L.Polyline(latlngs, options);
    };
    /*
 * L.PolyUtil contains utility functions for polygons (clipping, etc.).
 */
    /*jshint bitwise:false */
    // allow bitwise operations here
    L.PolyUtil = {};
    /*
 * Sutherland-Hodgeman polygon clipping algorithm.
 * Used to avoid rendering parts of a polygon that are not currently visible.
 */
    L.PolyUtil.clipPolygon = function(points, bounds) {
        var clippedPoints, edges = [ 1, 4, 2, 8 ], i, j, k, a, b, len, edge, p, lu = L.LineUtil;
        for (i = 0, len = points.length; i < len; i++) {
            points[i]._code = lu._getBitCode(points[i], bounds);
        }
        // for each edge (left, bottom, right, top)
        for (k = 0; k < 4; k++) {
            edge = edges[k];
            clippedPoints = [];
            for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
                a = points[i];
                b = points[j];
                // if a is inside the clip window
                if (!(a._code & edge)) {
                    // if b is outside the clip window (a->b goes out of screen)
                    if (b._code & edge) {
                        p = lu._getEdgeIntersection(b, a, edge, bounds);
                        p._code = lu._getBitCode(p, bounds);
                        clippedPoints.push(p);
                    }
                    clippedPoints.push(a);
                } else if (!(b._code & edge)) {
                    p = lu._getEdgeIntersection(b, a, edge, bounds);
                    p._code = lu._getBitCode(p, bounds);
                    clippedPoints.push(p);
                }
            }
            points = clippedPoints;
        }
        return points;
    };
    /*
 * L.Polygon is used to display polygons on a map.
 */
    L.Polygon = L.Polyline.extend({
        options: {
            fill: true
        },
        initialize: function(latlngs, options) {
            L.Polyline.prototype.initialize.call(this, latlngs, options);
            this._initWithHoles(latlngs);
        },
        _initWithHoles: function(latlngs) {
            var i, len, hole;
            if (latlngs && L.Util.isArray(latlngs[0]) && typeof latlngs[0][0] !== "number") {
                this._latlngs = this._convertLatLngs(latlngs[0]);
                this._holes = latlngs.slice(1);
                for (i = 0, len = this._holes.length; i < len; i++) {
                    hole = this._holes[i] = this._convertLatLngs(this._holes[i]);
                    if (hole[0].equals(hole[hole.length - 1])) {
                        hole.pop();
                    }
                }
            }
            // filter out last point if its equal to the first one
            latlngs = this._latlngs;
            if (latlngs.length >= 2 && latlngs[0].equals(latlngs[latlngs.length - 1])) {
                latlngs.pop();
            }
        },
        projectLatlngs: function() {
            L.Polyline.prototype.projectLatlngs.call(this);
            // project polygon holes points
            // TODO move this logic to Polyline to get rid of duplication
            this._holePoints = [];
            if (!this._holes) {
                return;
            }
            var i, j, len, len2;
            for (i = 0, len = this._holes.length; i < len; i++) {
                this._holePoints[i] = [];
                for (j = 0, len2 = this._holes[i].length; j < len2; j++) {
                    this._holePoints[i][j] = this._map.latLngToLayerPoint(this._holes[i][j]);
                }
            }
        },
        setLatLngs: function(latlngs) {
            if (latlngs && L.Util.isArray(latlngs[0]) && typeof latlngs[0][0] !== "number") {
                this._initWithHoles(latlngs);
                return this.redraw();
            } else {
                return L.Polyline.prototype.setLatLngs.call(this, latlngs);
            }
        },
        _clipPoints: function() {
            var points = this._originalPoints, newParts = [];
            this._parts = [ points ].concat(this._holePoints);
            if (this.options.noClip) {
                return;
            }
            for (var i = 0, len = this._parts.length; i < len; i++) {
                var clipped = L.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);
                if (clipped.length) {
                    newParts.push(clipped);
                }
            }
            this._parts = newParts;
        },
        _getPathPartStr: function(points) {
            var str = L.Polyline.prototype._getPathPartStr.call(this, points);
            return str + (L.Browser.svg ? "z" : "x");
        }
    });
    L.polygon = function(latlngs, options) {
        return new L.Polygon(latlngs, options);
    };
    /*
 * Contains L.MultiPolyline and L.MultiPolygon layers.
 */
    (function() {
        function createMulti(Klass) {
            return L.FeatureGroup.extend({
                initialize: function(latlngs, options) {
                    this._layers = {};
                    this._options = options;
                    this.setLatLngs(latlngs);
                },
                setLatLngs: function(latlngs) {
                    var i = 0, len = latlngs.length;
                    this.eachLayer(function(layer) {
                        if (i < len) {
                            layer.setLatLngs(latlngs[i++]);
                        } else {
                            this.removeLayer(layer);
                        }
                    }, this);
                    while (i < len) {
                        this.addLayer(new Klass(latlngs[i++], this._options));
                    }
                    return this;
                },
                getLatLngs: function() {
                    var latlngs = [];
                    this.eachLayer(function(layer) {
                        latlngs.push(layer.getLatLngs());
                    });
                    return latlngs;
                }
            });
        }
        L.MultiPolyline = createMulti(L.Polyline);
        L.MultiPolygon = createMulti(L.Polygon);
        L.multiPolyline = function(latlngs, options) {
            return new L.MultiPolyline(latlngs, options);
        };
        L.multiPolygon = function(latlngs, options) {
            return new L.MultiPolygon(latlngs, options);
        };
    })();
    /*
 * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
 */
    L.Rectangle = L.Polygon.extend({
        initialize: function(latLngBounds, options) {
            L.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
        },
        setBounds: function(latLngBounds) {
            this.setLatLngs(this._boundsToLatLngs(latLngBounds));
        },
        _boundsToLatLngs: function(latLngBounds) {
            latLngBounds = L.latLngBounds(latLngBounds);
            return [ latLngBounds.getSouthWest(), latLngBounds.getNorthWest(), latLngBounds.getNorthEast(), latLngBounds.getSouthEast() ];
        }
    });
    L.rectangle = function(latLngBounds, options) {
        return new L.Rectangle(latLngBounds, options);
    };
    /*
 * L.Circle is a circle overlay (with a certain radius in meters).
 */
    L.Circle = L.Path.extend({
        initialize: function(latlng, radius, options) {
            L.Path.prototype.initialize.call(this, options);
            this._latlng = L.latLng(latlng);
            this._mRadius = radius;
        },
        options: {
            fill: true
        },
        setLatLng: function(latlng) {
            this._latlng = L.latLng(latlng);
            return this.redraw();
        },
        setRadius: function(radius) {
            this._mRadius = radius;
            return this.redraw();
        },
        projectLatlngs: function() {
            var lngRadius = this._getLngRadius(), latlng = this._latlng, pointLeft = this._map.latLngToLayerPoint([ latlng.lat, latlng.lng - lngRadius ]);
            this._point = this._map.latLngToLayerPoint(latlng);
            this._radius = Math.max(this._point.x - pointLeft.x, 1);
        },
        getBounds: function() {
            var lngRadius = this._getLngRadius(), latRadius = this._mRadius / 40075017 * 360, latlng = this._latlng;
            return new L.LatLngBounds([ latlng.lat - latRadius, latlng.lng - lngRadius ], [ latlng.lat + latRadius, latlng.lng + lngRadius ]);
        },
        getLatLng: function() {
            return this._latlng;
        },
        getPathString: function() {
            var p = this._point, r = this._radius;
            if (this._checkIfEmpty()) {
                return "";
            }
            if (L.Browser.svg) {
                return "M" + p.x + "," + (p.y - r) + "A" + r + "," + r + ",0,1,1," + (p.x - .1) + "," + (p.y - r) + " z";
            } else {
                p._round();
                r = Math.round(r);
                return "AL " + p.x + "," + p.y + " " + r + "," + r + " 0," + 65535 * 360;
            }
        },
        getRadius: function() {
            return this._mRadius;
        },
        // TODO Earth hardcoded, move into projection code!
        _getLatRadius: function() {
            return this._mRadius / 40075017 * 360;
        },
        _getLngRadius: function() {
            return this._getLatRadius() / Math.cos(L.LatLng.DEG_TO_RAD * this._latlng.lat);
        },
        _checkIfEmpty: function() {
            if (!this._map) {
                return false;
            }
            var vp = this._map._pathViewport, r = this._radius, p = this._point;
            return p.x - r > vp.max.x || p.y - r > vp.max.y || p.x + r < vp.min.x || p.y + r < vp.min.y;
        }
    });
    L.circle = function(latlng, radius, options) {
        return new L.Circle(latlng, radius, options);
    };
    /*
 * L.CircleMarker is a circle overlay with a permanent pixel radius.
 */
    L.CircleMarker = L.Circle.extend({
        options: {
            radius: 10,
            weight: 2
        },
        initialize: function(latlng, options) {
            L.Circle.prototype.initialize.call(this, latlng, null, options);
            this._radius = this.options.radius;
        },
        projectLatlngs: function() {
            this._point = this._map.latLngToLayerPoint(this._latlng);
        },
        _updateStyle: function() {
            L.Circle.prototype._updateStyle.call(this);
            this.setRadius(this.options.radius);
        },
        setLatLng: function(latlng) {
            L.Circle.prototype.setLatLng.call(this, latlng);
            if (this._popup && this._popup._isOpen) {
                this._popup.setLatLng(latlng);
            }
            return this;
        },
        setRadius: function(radius) {
            this.options.radius = this._radius = radius;
            return this.redraw();
        },
        getRadius: function() {
            return this._radius;
        }
    });
    L.circleMarker = function(latlng, options) {
        return new L.CircleMarker(latlng, options);
    };
    /*
 * Extends L.Polyline to be able to manually detect clicks on Canvas-rendered polylines.
 */
    L.Polyline.include(!L.Path.CANVAS ? {} : {
        _containsPoint: function(p, closed) {
            var i, j, k, len, len2, dist, part, w = this.options.weight / 2;
            if (L.Browser.touch) {
                w += 10;
            }
            for (i = 0, len = this._parts.length; i < len; i++) {
                part = this._parts[i];
                for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                    if (!closed && j === 0) {
                        continue;
                    }
                    dist = L.LineUtil.pointToSegmentDistance(p, part[k], part[j]);
                    if (dist <= w) {
                        return true;
                    }
                }
            }
            return false;
        }
    });
    /*
 * Extends L.Polygon to be able to manually detect clicks on Canvas-rendered polygons.
 */
    L.Polygon.include(!L.Path.CANVAS ? {} : {
        _containsPoint: function(p) {
            var inside = false, part, p1, p2, i, j, k, len, len2;
            // TODO optimization: check if within bounds first
            if (L.Polyline.prototype._containsPoint.call(this, p, true)) {
                // click on polygon border
                return true;
            }
            // ray casting algorithm for detecting if point is in polygon
            for (i = 0, len = this._parts.length; i < len; i++) {
                part = this._parts[i];
                for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                    p1 = part[j];
                    p2 = part[k];
                    if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
                        inside = !inside;
                    }
                }
            }
            return inside;
        }
    });
    /*
 * Extends L.Circle with Canvas-specific code.
 */
    L.Circle.include(!L.Path.CANVAS ? {} : {
        _drawPath: function() {
            var p = this._point;
            this._ctx.beginPath();
            this._ctx.arc(p.x, p.y, this._radius, 0, Math.PI * 2, false);
        },
        _containsPoint: function(p) {
            var center = this._point, w2 = this.options.stroke ? this.options.weight / 2 : 0;
            return p.distanceTo(center) <= this._radius + w2;
        }
    });
    /*
 * CircleMarker canvas specific drawing parts.
 */
    L.CircleMarker.include(!L.Path.CANVAS ? {} : {
        _updateStyle: function() {
            L.Path.prototype._updateStyle.call(this);
        }
    });
    /*
 * L.GeoJSON turns any GeoJSON data into a Leaflet layer.
 */
    L.GeoJSON = L.FeatureGroup.extend({
        initialize: function(geojson, options) {
            L.setOptions(this, options);
            this._layers = {};
            if (geojson) {
                this.addData(geojson);
            }
        },
        addData: function(geojson) {
            var features = L.Util.isArray(geojson) ? geojson : geojson.features, i, len, feature;
            if (features) {
                for (i = 0, len = features.length; i < len; i++) {
                    // Only add this if geometry or geometries are set and not null
                    feature = features[i];
                    if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
                        this.addData(features[i]);
                    }
                }
                return this;
            }
            var options = this.options;
            if (options.filter && !options.filter(geojson)) {
                return;
            }
            var layer = L.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng, options);
            layer.feature = L.GeoJSON.asFeature(geojson);
            layer.defaultOptions = layer.options;
            this.resetStyle(layer);
            if (options.onEachFeature) {
                options.onEachFeature(geojson, layer);
            }
            return this.addLayer(layer);
        },
        resetStyle: function(layer) {
            var style = this.options.style;
            if (style) {
                // reset any custom styles
                L.Util.extend(layer.options, layer.defaultOptions);
                this._setLayerStyle(layer, style);
            }
        },
        setStyle: function(style) {
            this.eachLayer(function(layer) {
                this._setLayerStyle(layer, style);
            }, this);
        },
        _setLayerStyle: function(layer, style) {
            if (typeof style === "function") {
                style = style(layer.feature);
            }
            if (layer.setStyle) {
                layer.setStyle(style);
            }
        }
    });
    L.extend(L.GeoJSON, {
        geometryToLayer: function(geojson, pointToLayer, coordsToLatLng, vectorOptions) {
            var geometry = geojson.type === "Feature" ? geojson.geometry : geojson, coords = geometry.coordinates, layers = [], latlng, latlngs, i, len;
            coordsToLatLng = coordsToLatLng || this.coordsToLatLng;
            switch (geometry.type) {
              case "Point":
                latlng = coordsToLatLng(coords);
                return pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);

              case "MultiPoint":
                for (i = 0, len = coords.length; i < len; i++) {
                    latlng = coordsToLatLng(coords[i]);
                    layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));
                }
                return new L.FeatureGroup(layers);

              case "LineString":
                latlngs = this.coordsToLatLngs(coords, 0, coordsToLatLng);
                return new L.Polyline(latlngs, vectorOptions);

              case "Polygon":
                if (coords.length === 2 && !coords[1].length) {
                    throw new Error("Invalid GeoJSON object.");
                }
                latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);
                return new L.Polygon(latlngs, vectorOptions);

              case "MultiLineString":
                latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);
                return new L.MultiPolyline(latlngs, vectorOptions);

              case "MultiPolygon":
                latlngs = this.coordsToLatLngs(coords, 2, coordsToLatLng);
                return new L.MultiPolygon(latlngs, vectorOptions);

              case "GeometryCollection":
                for (i = 0, len = geometry.geometries.length; i < len; i++) {
                    layers.push(this.geometryToLayer({
                        geometry: geometry.geometries[i],
                        type: "Feature",
                        properties: geojson.properties
                    }, pointToLayer, coordsToLatLng, vectorOptions));
                }
                return new L.FeatureGroup(layers);

              default:
                throw new Error("Invalid GeoJSON object.");
            }
        },
        coordsToLatLng: function(coords) {
            // (Array[, Boolean]) -> LatLng
            return new L.LatLng(coords[1], coords[0], coords[2]);
        },
        coordsToLatLngs: function(coords, levelsDeep, coordsToLatLng) {
            // (Array[, Number, Function]) -> Array
            var latlng, i, len, latlngs = [];
            for (i = 0, len = coords.length; i < len; i++) {
                latlng = levelsDeep ? this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) : (coordsToLatLng || this.coordsToLatLng)(coords[i]);
                latlngs.push(latlng);
            }
            return latlngs;
        },
        latLngToCoords: function(latlng) {
            var coords = [ latlng.lng, latlng.lat ];
            if (latlng.alt !== undefined) {
                coords.push(latlng.alt);
            }
            return coords;
        },
        latLngsToCoords: function(latLngs) {
            var coords = [];
            for (var i = 0, len = latLngs.length; i < len; i++) {
                coords.push(L.GeoJSON.latLngToCoords(latLngs[i]));
            }
            return coords;
        },
        getFeature: function(layer, newGeometry) {
            return layer.feature ? L.extend({}, layer.feature, {
                geometry: newGeometry
            }) : L.GeoJSON.asFeature(newGeometry);
        },
        asFeature: function(geoJSON) {
            if (geoJSON.type === "Feature") {
                return geoJSON;
            }
            return {
                type: "Feature",
                properties: {},
                geometry: geoJSON
            };
        }
    });
    var PointToGeoJSON = {
        toGeoJSON: function() {
            return L.GeoJSON.getFeature(this, {
                type: "Point",
                coordinates: L.GeoJSON.latLngToCoords(this.getLatLng())
            });
        }
    };
    L.Marker.include(PointToGeoJSON);
    L.Circle.include(PointToGeoJSON);
    L.CircleMarker.include(PointToGeoJSON);
    L.Polyline.include({
        toGeoJSON: function() {
            return L.GeoJSON.getFeature(this, {
                type: "LineString",
                coordinates: L.GeoJSON.latLngsToCoords(this.getLatLngs())
            });
        }
    });
    L.Polygon.include({
        toGeoJSON: function() {
            var coords = [ L.GeoJSON.latLngsToCoords(this.getLatLngs()) ], i, len, hole;
            coords[0].push(coords[0][0]);
            if (this._holes) {
                for (i = 0, len = this._holes.length; i < len; i++) {
                    hole = L.GeoJSON.latLngsToCoords(this._holes[i]);
                    hole.push(hole[0]);
                    coords.push(hole);
                }
            }
            return L.GeoJSON.getFeature(this, {
                type: "Polygon",
                coordinates: coords
            });
        }
    });
    (function() {
        function multiToGeoJSON(type) {
            return function() {
                var coords = [];
                this.eachLayer(function(layer) {
                    coords.push(layer.toGeoJSON().geometry.coordinates);
                });
                return L.GeoJSON.getFeature(this, {
                    type: type,
                    coordinates: coords
                });
            };
        }
        L.MultiPolyline.include({
            toGeoJSON: multiToGeoJSON("MultiLineString")
        });
        L.MultiPolygon.include({
            toGeoJSON: multiToGeoJSON("MultiPolygon")
        });
        L.LayerGroup.include({
            toGeoJSON: function() {
                var geometry = this.feature && this.feature.geometry, jsons = [], json;
                if (geometry && geometry.type === "MultiPoint") {
                    return multiToGeoJSON("MultiPoint").call(this);
                }
                var isGeometryCollection = geometry && geometry.type === "GeometryCollection";
                this.eachLayer(function(layer) {
                    if (layer.toGeoJSON) {
                        json = layer.toGeoJSON();
                        jsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));
                    }
                });
                if (isGeometryCollection) {
                    return L.GeoJSON.getFeature(this, {
                        geometries: jsons,
                        type: "GeometryCollection"
                    });
                }
                return {
                    type: "FeatureCollection",
                    features: jsons
                };
            }
        });
    })();
    L.geoJson = function(geojson, options) {
        return new L.GeoJSON(geojson, options);
    };
    /*
 * L.DomEvent contains functions for working with DOM events.
 */
    L.DomEvent = {
        /* inspired by John Resig, Dean Edwards and YUI addEvent implementations */
        addListener: function(obj, type, fn, context) {
            // (HTMLElement, String, Function[, Object])
            var id = L.stamp(fn), key = "_leaflet_" + type + id, handler, originalHandler, newType;
            if (obj[key]) {
                return this;
            }
            handler = function(e) {
                return fn.call(context || obj, e || L.DomEvent._getEvent());
            };
            if (L.Browser.pointer && type.indexOf("touch") === 0) {
                return this.addPointerListener(obj, type, handler, id);
            }
            if (L.Browser.touch && type === "dblclick" && this.addDoubleTapListener) {
                this.addDoubleTapListener(obj, handler, id);
            }
            if ("addEventListener" in obj) {
                if (type === "mousewheel") {
                    obj.addEventListener("DOMMouseScroll", handler, false);
                    obj.addEventListener(type, handler, false);
                } else if (type === "mouseenter" || type === "mouseleave") {
                    originalHandler = handler;
                    newType = type === "mouseenter" ? "mouseover" : "mouseout";
                    handler = function(e) {
                        if (!L.DomEvent._checkMouse(obj, e)) {
                            return;
                        }
                        return originalHandler(e);
                    };
                    obj.addEventListener(newType, handler, false);
                } else if (type === "click" && L.Browser.android) {
                    originalHandler = handler;
                    handler = function(e) {
                        return L.DomEvent._filterClick(e, originalHandler);
                    };
                    obj.addEventListener(type, handler, false);
                } else {
                    obj.addEventListener(type, handler, false);
                }
            } else if ("attachEvent" in obj) {
                obj.attachEvent("on" + type, handler);
            }
            obj[key] = handler;
            return this;
        },
        removeListener: function(obj, type, fn) {
            // (HTMLElement, String, Function)
            var id = L.stamp(fn), key = "_leaflet_" + type + id, handler = obj[key];
            if (!handler) {
                return this;
            }
            if (L.Browser.pointer && type.indexOf("touch") === 0) {
                this.removePointerListener(obj, type, id);
            } else if (L.Browser.touch && type === "dblclick" && this.removeDoubleTapListener) {
                this.removeDoubleTapListener(obj, id);
            } else if ("removeEventListener" in obj) {
                if (type === "mousewheel") {
                    obj.removeEventListener("DOMMouseScroll", handler, false);
                    obj.removeEventListener(type, handler, false);
                } else if (type === "mouseenter" || type === "mouseleave") {
                    obj.removeEventListener(type === "mouseenter" ? "mouseover" : "mouseout", handler, false);
                } else {
                    obj.removeEventListener(type, handler, false);
                }
            } else if ("detachEvent" in obj) {
                obj.detachEvent("on" + type, handler);
            }
            obj[key] = null;
            return this;
        },
        stopPropagation: function(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            } else {
                e.cancelBubble = true;
            }
            L.DomEvent._skipped(e);
            return this;
        },
        disableScrollPropagation: function(el) {
            var stop = L.DomEvent.stopPropagation;
            return L.DomEvent.on(el, "mousewheel", stop).on(el, "MozMousePixelScroll", stop);
        },
        disableClickPropagation: function(el) {
            var stop = L.DomEvent.stopPropagation;
            for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
                L.DomEvent.on(el, L.Draggable.START[i], stop);
            }
            return L.DomEvent.on(el, "click", L.DomEvent._fakeStop).on(el, "dblclick", stop);
        },
        preventDefault: function(e) {
            if (e.preventDefault) {
                e.preventDefault();
            } else {
                e.returnValue = false;
            }
            return this;
        },
        stop: function(e) {
            return L.DomEvent.preventDefault(e).stopPropagation(e);
        },
        getMousePosition: function(e, container) {
            if (!container) {
                return new L.Point(e.clientX, e.clientY);
            }
            var rect = container.getBoundingClientRect();
            return new L.Point(e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop);
        },
        getWheelDelta: function(e) {
            var delta = 0;
            if (e.wheelDelta) {
                delta = e.wheelDelta / 120;
            }
            if (e.detail) {
                delta = -e.detail / 3;
            }
            return delta;
        },
        _skipEvents: {},
        _fakeStop: function(e) {
            // fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)
            L.DomEvent._skipEvents[e.type] = true;
        },
        _skipped: function(e) {
            var skipped = this._skipEvents[e.type];
            // reset when checking, as it's only used in map container and propagates outside of the map
            this._skipEvents[e.type] = false;
            return skipped;
        },
        // check if element really left/entered the event target (for mouseenter/mouseleave)
        _checkMouse: function(el, e) {
            var related = e.relatedTarget;
            if (!related) {
                return true;
            }
            try {
                while (related && related !== el) {
                    related = related.parentNode;
                }
            } catch (err) {
                return false;
            }
            return related !== el;
        },
        _getEvent: function() {
            // evil magic for IE
            /*jshint noarg:false */
            var e = window.event;
            if (!e) {
                var caller = arguments.callee.caller;
                while (caller) {
                    e = caller["arguments"][0];
                    if (e && window.Event === e.constructor) {
                        break;
                    }
                    caller = caller.caller;
                }
            }
            return e;
        },
        // this is a horrible workaround for a bug in Android where a single touch triggers two click events
        _filterClick: function(e, handler) {
            var timeStamp = e.timeStamp || e.originalEvent.timeStamp, elapsed = L.DomEvent._lastClick && timeStamp - L.DomEvent._lastClick;
            // are they closer together than 500ms yet more than 100ms?
            // Android typically triggers them ~300ms apart while multiple listeners
            // on the same event should be triggered far faster;
            // or check if click is simulated on the element, and if it is, reject any non-simulated events
            if (elapsed && elapsed > 100 && elapsed < 500 || e.target._simulatedClick && !e._simulated) {
                L.DomEvent.stop(e);
                return;
            }
            L.DomEvent._lastClick = timeStamp;
            return handler(e);
        }
    };
    L.DomEvent.on = L.DomEvent.addListener;
    L.DomEvent.off = L.DomEvent.removeListener;
    /*
 * L.Draggable allows you to add dragging capabilities to any element. Supports mobile devices too.
 */
    L.Draggable = L.Class.extend({
        includes: L.Mixin.Events,
        statics: {
            START: L.Browser.touch ? [ "touchstart", "mousedown" ] : [ "mousedown" ],
            END: {
                mousedown: "mouseup",
                touchstart: "touchend",
                pointerdown: "touchend",
                MSPointerDown: "touchend"
            },
            MOVE: {
                mousedown: "mousemove",
                touchstart: "touchmove",
                pointerdown: "touchmove",
                MSPointerDown: "touchmove"
            }
        },
        initialize: function(element, dragStartTarget) {
            this._element = element;
            this._dragStartTarget = dragStartTarget || element;
        },
        enable: function() {
            if (this._enabled) {
                return;
            }
            for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
                L.DomEvent.on(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);
            }
            this._enabled = true;
        },
        disable: function() {
            if (!this._enabled) {
                return;
            }
            for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
                L.DomEvent.off(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);
            }
            this._enabled = false;
            this._moved = false;
        },
        _onDown: function(e) {
            this._moved = false;
            if (e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {
                return;
            }
            L.DomEvent.stopPropagation(e);
            if (L.Draggable._disabled) {
                return;
            }
            L.DomUtil.disableImageDrag();
            L.DomUtil.disableTextSelection();
            if (this._moving) {
                return;
            }
            var first = e.touches ? e.touches[0] : e;
            this._startPoint = new L.Point(first.clientX, first.clientY);
            this._startPos = this._newPos = L.DomUtil.getPosition(this._element);
            L.DomEvent.on(document, L.Draggable.MOVE[e.type], this._onMove, this).on(document, L.Draggable.END[e.type], this._onUp, this);
        },
        _onMove: function(e) {
            if (e.touches && e.touches.length > 1) {
                this._moved = true;
                return;
            }
            var first = e.touches && e.touches.length === 1 ? e.touches[0] : e, newPoint = new L.Point(first.clientX, first.clientY), offset = newPoint.subtract(this._startPoint);
            if (!offset.x && !offset.y) {
                return;
            }
            if (L.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) {
                return;
            }
            L.DomEvent.preventDefault(e);
            if (!this._moved) {
                this.fire("dragstart");
                this._moved = true;
                this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);
                L.DomUtil.addClass(document.body, "leaflet-dragging");
                this._lastTarget = e.target || e.srcElement;
                L.DomUtil.addClass(this._lastTarget, "leaflet-drag-target");
            }
            this._newPos = this._startPos.add(offset);
            this._moving = true;
            L.Util.cancelAnimFrame(this._animRequest);
            this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);
        },
        _updatePosition: function() {
            this.fire("predrag");
            L.DomUtil.setPosition(this._element, this._newPos);
            this.fire("drag");
        },
        _onUp: function() {
            L.DomUtil.removeClass(document.body, "leaflet-dragging");
            if (this._lastTarget) {
                L.DomUtil.removeClass(this._lastTarget, "leaflet-drag-target");
                this._lastTarget = null;
            }
            for (var i in L.Draggable.MOVE) {
                L.DomEvent.off(document, L.Draggable.MOVE[i], this._onMove).off(document, L.Draggable.END[i], this._onUp);
            }
            L.DomUtil.enableImageDrag();
            L.DomUtil.enableTextSelection();
            if (this._moved && this._moving) {
                // ensure drag is not fired after dragend
                L.Util.cancelAnimFrame(this._animRequest);
                this.fire("dragend", {
                    distance: this._newPos.distanceTo(this._startPos)
                });
            }
            this._moving = false;
        }
    });
    /*
	L.Handler is a base class for handler classes that are used internally to inject
	interaction features like dragging to classes like Map and Marker.
*/
    L.Handler = L.Class.extend({
        initialize: function(map) {
            this._map = map;
        },
        enable: function() {
            if (this._enabled) {
                return;
            }
            this._enabled = true;
            this.addHooks();
        },
        disable: function() {
            if (!this._enabled) {
                return;
            }
            this._enabled = false;
            this.removeHooks();
        },
        enabled: function() {
            return !!this._enabled;
        }
    });
    /*
 * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
 */
    L.Map.mergeOptions({
        dragging: true,
        inertia: !L.Browser.android23,
        inertiaDeceleration: 3400,
        // px/s^2
        inertiaMaxSpeed: Infinity,
        // px/s
        inertiaThreshold: L.Browser.touch ? 32 : 18,
        // ms
        easeLinearity: .25,
        // TODO refactor, move to CRS
        worldCopyJump: false
    });
    L.Map.Drag = L.Handler.extend({
        addHooks: function() {
            if (!this._draggable) {
                var map = this._map;
                this._draggable = new L.Draggable(map._mapPane, map._container);
                this._draggable.on({
                    dragstart: this._onDragStart,
                    drag: this._onDrag,
                    dragend: this._onDragEnd
                }, this);
                if (map.options.worldCopyJump) {
                    this._draggable.on("predrag", this._onPreDrag, this);
                    map.on("viewreset", this._onViewReset, this);
                    map.whenReady(this._onViewReset, this);
                }
            }
            this._draggable.enable();
        },
        removeHooks: function() {
            this._draggable.disable();
        },
        moved: function() {
            return this._draggable && this._draggable._moved;
        },
        _onDragStart: function() {
            var map = this._map;
            if (map._panAnim) {
                map._panAnim.stop();
            }
            map.fire("movestart").fire("dragstart");
            if (map.options.inertia) {
                this._positions = [];
                this._times = [];
            }
        },
        _onDrag: function() {
            if (this._map.options.inertia) {
                var time = this._lastTime = +new Date(), pos = this._lastPos = this._draggable._newPos;
                this._positions.push(pos);
                this._times.push(time);
                if (time - this._times[0] > 200) {
                    this._positions.shift();
                    this._times.shift();
                }
            }
            this._map.fire("move").fire("drag");
        },
        _onViewReset: function() {
            // TODO fix hardcoded Earth values
            var pxCenter = this._map.getSize()._divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([ 0, 0 ]);
            this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
            this._worldWidth = this._map.project([ 0, 180 ]).x;
        },
        _onPreDrag: function() {
            // TODO refactor to be able to adjust map pane position after zoom
            var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x = this._draggable._newPos.x, newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
            this._draggable._newPos.x = newX;
        },
        _onDragEnd: function(e) {
            var map = this._map, options = map.options, delay = +new Date() - this._lastTime, noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];
            map.fire("dragend", e);
            if (noInertia) {
                map.fire("moveend");
            } else {
                var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime + delay - this._times[0]) / 1e3, ease = options.easeLinearity, speedVector = direction.multiplyBy(ease / duration), speed = speedVector.distanceTo([ 0, 0 ]), limitedSpeed = Math.min(options.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease), offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
                if (!offset.x || !offset.y) {
                    map.fire("moveend");
                } else {
                    offset = map._limitOffset(offset, map.options.maxBounds);
                    L.Util.requestAnimFrame(function() {
                        map.panBy(offset, {
                            duration: decelerationDuration,
                            easeLinearity: ease,
                            noMoveStart: true
                        });
                    });
                }
            }
        }
    });
    L.Map.addInitHook("addHandler", "dragging", L.Map.Drag);
    /*
 * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
 */
    L.Map.mergeOptions({
        doubleClickZoom: true
    });
    L.Map.DoubleClickZoom = L.Handler.extend({
        addHooks: function() {
            this._map.on("dblclick", this._onDoubleClick, this);
        },
        removeHooks: function() {
            this._map.off("dblclick", this._onDoubleClick, this);
        },
        _onDoubleClick: function(e) {
            var map = this._map, zoom = map.getZoom() + (e.originalEvent.shiftKey ? -1 : 1);
            if (map.options.doubleClickZoom === "center") {
                map.setZoom(zoom);
            } else {
                map.setZoomAround(e.containerPoint, zoom);
            }
        }
    });
    L.Map.addInitHook("addHandler", "doubleClickZoom", L.Map.DoubleClickZoom);
    /*
 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
 */
    L.Map.mergeOptions({
        scrollWheelZoom: true
    });
    L.Map.ScrollWheelZoom = L.Handler.extend({
        addHooks: function() {
            L.DomEvent.on(this._map._container, "mousewheel", this._onWheelScroll, this);
            L.DomEvent.on(this._map._container, "MozMousePixelScroll", L.DomEvent.preventDefault);
            this._delta = 0;
        },
        removeHooks: function() {
            L.DomEvent.off(this._map._container, "mousewheel", this._onWheelScroll);
            L.DomEvent.off(this._map._container, "MozMousePixelScroll", L.DomEvent.preventDefault);
        },
        _onWheelScroll: function(e) {
            var delta = L.DomEvent.getWheelDelta(e);
            this._delta += delta;
            this._lastMousePos = this._map.mouseEventToContainerPoint(e);
            if (!this._startTime) {
                this._startTime = +new Date();
            }
            var left = Math.max(40 - (+new Date() - this._startTime), 0);
            clearTimeout(this._timer);
            this._timer = setTimeout(L.bind(this._performZoom, this), left);
            L.DomEvent.preventDefault(e);
            L.DomEvent.stopPropagation(e);
        },
        _performZoom: function() {
            var map = this._map, delta = this._delta, zoom = map.getZoom();
            delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
            delta = Math.max(Math.min(delta, 4), -4);
            delta = map._limitZoom(zoom + delta) - zoom;
            this._delta = 0;
            this._startTime = null;
            if (!delta) {
                return;
            }
            if (map.options.scrollWheelZoom === "center") {
                map.setZoom(zoom + delta);
            } else {
                map.setZoomAround(this._lastMousePos, zoom + delta);
            }
        }
    });
    L.Map.addInitHook("addHandler", "scrollWheelZoom", L.Map.ScrollWheelZoom);
    /*
 * Extends the event handling code with double tap support for mobile browsers.
 */
    L.extend(L.DomEvent, {
        _touchstart: L.Browser.msPointer ? "MSPointerDown" : L.Browser.pointer ? "pointerdown" : "touchstart",
        _touchend: L.Browser.msPointer ? "MSPointerUp" : L.Browser.pointer ? "pointerup" : "touchend",
        // inspired by Zepto touch code by Thomas Fuchs
        addDoubleTapListener: function(obj, handler, id) {
            var last, doubleTap = false, delay = 250, touch, pre = "_leaflet_", touchstart = this._touchstart, touchend = this._touchend, trackedTouches = [];
            function onTouchStart(e) {
                var count;
                if (L.Browser.pointer) {
                    trackedTouches.push(e.pointerId);
                    count = trackedTouches.length;
                } else {
                    count = e.touches.length;
                }
                if (count > 1) {
                    return;
                }
                var now = Date.now(), delta = now - (last || now);
                touch = e.touches ? e.touches[0] : e;
                doubleTap = delta > 0 && delta <= delay;
                last = now;
            }
            function onTouchEnd(e) {
                if (L.Browser.pointer) {
                    var idx = trackedTouches.indexOf(e.pointerId);
                    if (idx === -1) {
                        return;
                    }
                    trackedTouches.splice(idx, 1);
                }
                if (doubleTap) {
                    if (L.Browser.pointer) {
                        // work around .type being readonly with MSPointer* events
                        var newTouch = {}, prop;
                        // jshint forin:false
                        for (var i in touch) {
                            prop = touch[i];
                            if (typeof prop === "function") {
                                newTouch[i] = prop.bind(touch);
                            } else {
                                newTouch[i] = prop;
                            }
                        }
                        touch = newTouch;
                    }
                    touch.type = "dblclick";
                    handler(touch);
                    last = null;
                }
            }
            obj[pre + touchstart + id] = onTouchStart;
            obj[pre + touchend + id] = onTouchEnd;
            // on pointer we need to listen on the document, otherwise a drag starting on the map and moving off screen
            // will not come through to us, so we will lose track of how many touches are ongoing
            var endElement = L.Browser.pointer ? document.documentElement : obj;
            obj.addEventListener(touchstart, onTouchStart, false);
            endElement.addEventListener(touchend, onTouchEnd, false);
            if (L.Browser.pointer) {
                endElement.addEventListener(L.DomEvent.POINTER_CANCEL, onTouchEnd, false);
            }
            return this;
        },
        removeDoubleTapListener: function(obj, id) {
            var pre = "_leaflet_";
            obj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);
            (L.Browser.pointer ? document.documentElement : obj).removeEventListener(this._touchend, obj[pre + this._touchend + id], false);
            if (L.Browser.pointer) {
                document.documentElement.removeEventListener(L.DomEvent.POINTER_CANCEL, obj[pre + this._touchend + id], false);
            }
            return this;
        }
    });
    /*
 * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
 */
    L.extend(L.DomEvent, {
        //static
        POINTER_DOWN: L.Browser.msPointer ? "MSPointerDown" : "pointerdown",
        POINTER_MOVE: L.Browser.msPointer ? "MSPointerMove" : "pointermove",
        POINTER_UP: L.Browser.msPointer ? "MSPointerUp" : "pointerup",
        POINTER_CANCEL: L.Browser.msPointer ? "MSPointerCancel" : "pointercancel",
        _pointers: [],
        _pointerDocumentListener: false,
        // Provides a touch events wrapper for (ms)pointer events.
        // Based on changes by veproza https://github.com/CloudMade/Leaflet/pull/1019
        //ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890
        addPointerListener: function(obj, type, handler, id) {
            switch (type) {
              case "touchstart":
                return this.addPointerListenerStart(obj, type, handler, id);

              case "touchend":
                return this.addPointerListenerEnd(obj, type, handler, id);

              case "touchmove":
                return this.addPointerListenerMove(obj, type, handler, id);

              default:
                throw "Unknown touch event type";
            }
        },
        addPointerListenerStart: function(obj, type, handler, id) {
            var pre = "_leaflet_", pointers = this._pointers;
            var cb = function(e) {
                L.DomEvent.preventDefault(e);
                var alreadyInArray = false;
                for (var i = 0; i < pointers.length; i++) {
                    if (pointers[i].pointerId === e.pointerId) {
                        alreadyInArray = true;
                        break;
                    }
                }
                if (!alreadyInArray) {
                    pointers.push(e);
                }
                e.touches = pointers.slice();
                e.changedTouches = [ e ];
                handler(e);
            };
            obj[pre + "touchstart" + id] = cb;
            obj.addEventListener(this.POINTER_DOWN, cb, false);
            // need to also listen for end events to keep the _pointers list accurate
            // this needs to be on the body and never go away
            if (!this._pointerDocumentListener) {
                var internalCb = function(e) {
                    for (var i = 0; i < pointers.length; i++) {
                        if (pointers[i].pointerId === e.pointerId) {
                            pointers.splice(i, 1);
                            break;
                        }
                    }
                };
                //We listen on the documentElement as any drags that end by moving the touch off the screen get fired there
                document.documentElement.addEventListener(this.POINTER_UP, internalCb, false);
                document.documentElement.addEventListener(this.POINTER_CANCEL, internalCb, false);
                this._pointerDocumentListener = true;
            }
            return this;
        },
        addPointerListenerMove: function(obj, type, handler, id) {
            var pre = "_leaflet_", touches = this._pointers;
            function cb(e) {
                // don't fire touch moves when mouse isn't down
                if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === "mouse") && e.buttons === 0) {
                    return;
                }
                for (var i = 0; i < touches.length; i++) {
                    if (touches[i].pointerId === e.pointerId) {
                        touches[i] = e;
                        break;
                    }
                }
                e.touches = touches.slice();
                e.changedTouches = [ e ];
                handler(e);
            }
            obj[pre + "touchmove" + id] = cb;
            obj.addEventListener(this.POINTER_MOVE, cb, false);
            return this;
        },
        addPointerListenerEnd: function(obj, type, handler, id) {
            var pre = "_leaflet_", touches = this._pointers;
            var cb = function(e) {
                for (var i = 0; i < touches.length; i++) {
                    if (touches[i].pointerId === e.pointerId) {
                        touches.splice(i, 1);
                        break;
                    }
                }
                e.touches = touches.slice();
                e.changedTouches = [ e ];
                handler(e);
            };
            obj[pre + "touchend" + id] = cb;
            obj.addEventListener(this.POINTER_UP, cb, false);
            obj.addEventListener(this.POINTER_CANCEL, cb, false);
            return this;
        },
        removePointerListener: function(obj, type, id) {
            var pre = "_leaflet_", cb = obj[pre + type + id];
            switch (type) {
              case "touchstart":
                obj.removeEventListener(this.POINTER_DOWN, cb, false);
                break;

              case "touchmove":
                obj.removeEventListener(this.POINTER_MOVE, cb, false);
                break;

              case "touchend":
                obj.removeEventListener(this.POINTER_UP, cb, false);
                obj.removeEventListener(this.POINTER_CANCEL, cb, false);
                break;
            }
            return this;
        }
    });
    /*
 * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
 */
    L.Map.mergeOptions({
        touchZoom: L.Browser.touch && !L.Browser.android23,
        bounceAtZoomLimits: true
    });
    L.Map.TouchZoom = L.Handler.extend({
        addHooks: function() {
            L.DomEvent.on(this._map._container, "touchstart", this._onTouchStart, this);
        },
        removeHooks: function() {
            L.DomEvent.off(this._map._container, "touchstart", this._onTouchStart, this);
        },
        _onTouchStart: function(e) {
            var map = this._map;
            if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {
                return;
            }
            var p1 = map.mouseEventToLayerPoint(e.touches[0]), p2 = map.mouseEventToLayerPoint(e.touches[1]), viewCenter = map._getCenterLayerPoint();
            this._startCenter = p1.add(p2)._divideBy(2);
            this._startDist = p1.distanceTo(p2);
            this._moved = false;
            this._zooming = true;
            this._centerOffset = viewCenter.subtract(this._startCenter);
            if (map._panAnim) {
                map._panAnim.stop();
            }
            L.DomEvent.on(document, "touchmove", this._onTouchMove, this).on(document, "touchend", this._onTouchEnd, this);
            L.DomEvent.preventDefault(e);
        },
        _onTouchMove: function(e) {
            var map = this._map;
            if (!e.touches || e.touches.length !== 2 || !this._zooming) {
                return;
            }
            var p1 = map.mouseEventToLayerPoint(e.touches[0]), p2 = map.mouseEventToLayerPoint(e.touches[1]);
            this._scale = p1.distanceTo(p2) / this._startDist;
            this._delta = p1._add(p2)._divideBy(2)._subtract(this._startCenter);
            if (this._scale === 1) {
                return;
            }
            if (!map.options.bounceAtZoomLimits) {
                if (map.getZoom() === map.getMinZoom() && this._scale < 1 || map.getZoom() === map.getMaxZoom() && this._scale > 1) {
                    return;
                }
            }
            if (!this._moved) {
                L.DomUtil.addClass(map._mapPane, "leaflet-touching");
                map.fire("movestart").fire("zoomstart");
                this._moved = true;
            }
            L.Util.cancelAnimFrame(this._animRequest);
            this._animRequest = L.Util.requestAnimFrame(this._updateOnMove, this, true, this._map._container);
            L.DomEvent.preventDefault(e);
        },
        _updateOnMove: function() {
            var map = this._map, origin = this._getScaleOrigin(), center = map.layerPointToLatLng(origin), zoom = map.getScaleZoom(this._scale);
            map._animateZoom(center, zoom, this._startCenter, this._scale, this._delta, false, true);
        },
        _onTouchEnd: function() {
            if (!this._moved || !this._zooming) {
                this._zooming = false;
                return;
            }
            var map = this._map;
            this._zooming = false;
            L.DomUtil.removeClass(map._mapPane, "leaflet-touching");
            L.Util.cancelAnimFrame(this._animRequest);
            L.DomEvent.off(document, "touchmove", this._onTouchMove).off(document, "touchend", this._onTouchEnd);
            var origin = this._getScaleOrigin(), center = map.layerPointToLatLng(origin), oldZoom = map.getZoom(), floatZoomDelta = map.getScaleZoom(this._scale) - oldZoom, roundZoomDelta = floatZoomDelta > 0 ? Math.ceil(floatZoomDelta) : Math.floor(floatZoomDelta), zoom = map._limitZoom(oldZoom + roundZoomDelta), scale = map.getZoomScale(zoom) / this._scale;
            map._animateZoom(center, zoom, origin, scale);
        },
        _getScaleOrigin: function() {
            var centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);
            return this._startCenter.add(centerOffset);
        }
    });
    L.Map.addInitHook("addHandler", "touchZoom", L.Map.TouchZoom);
    /*
 * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
 */
    L.Map.mergeOptions({
        tap: true,
        tapTolerance: 15
    });
    L.Map.Tap = L.Handler.extend({
        addHooks: function() {
            L.DomEvent.on(this._map._container, "touchstart", this._onDown, this);
        },
        removeHooks: function() {
            L.DomEvent.off(this._map._container, "touchstart", this._onDown, this);
        },
        _onDown: function(e) {
            if (!e.touches) {
                return;
            }
            L.DomEvent.preventDefault(e);
            this._fireClick = true;
            // don't simulate click or track longpress if more than 1 touch
            if (e.touches.length > 1) {
                this._fireClick = false;
                clearTimeout(this._holdTimeout);
                return;
            }
            var first = e.touches[0], el = first.target;
            this._startPos = this._newPos = new L.Point(first.clientX, first.clientY);
            // if touching a link, highlight it
            if (el.tagName && el.tagName.toLowerCase() === "a") {
                L.DomUtil.addClass(el, "leaflet-active");
            }
            // simulate long hold but setting a timeout
            this._holdTimeout = setTimeout(L.bind(function() {
                if (this._isTapValid()) {
                    this._fireClick = false;
                    this._onUp();
                    this._simulateEvent("contextmenu", first);
                }
            }, this), 1e3);
            L.DomEvent.on(document, "touchmove", this._onMove, this).on(document, "touchend", this._onUp, this);
        },
        _onUp: function(e) {
            clearTimeout(this._holdTimeout);
            L.DomEvent.off(document, "touchmove", this._onMove, this).off(document, "touchend", this._onUp, this);
            if (this._fireClick && e && e.changedTouches) {
                var first = e.changedTouches[0], el = first.target;
                if (el && el.tagName && el.tagName.toLowerCase() === "a") {
                    L.DomUtil.removeClass(el, "leaflet-active");
                }
                // simulate click if the touch didn't move too much
                if (this._isTapValid()) {
                    this._simulateEvent("click", first);
                }
            }
        },
        _isTapValid: function() {
            return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
        },
        _onMove: function(e) {
            var first = e.touches[0];
            this._newPos = new L.Point(first.clientX, first.clientY);
        },
        _simulateEvent: function(type, e) {
            var simulatedEvent = document.createEvent("MouseEvents");
            simulatedEvent._simulated = true;
            e.target._simulatedClick = true;
            simulatedEvent.initMouseEvent(type, true, true, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, false, false, false, false, 0, null);
            e.target.dispatchEvent(simulatedEvent);
        }
    });
    if (L.Browser.touch && !L.Browser.pointer) {
        L.Map.addInitHook("addHandler", "tap", L.Map.Tap);
    }
    /*
 * L.Handler.ShiftDragZoom is used to add shift-drag zoom interaction to the map
  * (zoom to a selected bounding box), enabled by default.
 */
    L.Map.mergeOptions({
        boxZoom: true
    });
    L.Map.BoxZoom = L.Handler.extend({
        initialize: function(map) {
            this._map = map;
            this._container = map._container;
            this._pane = map._panes.overlayPane;
            this._moved = false;
        },
        addHooks: function() {
            L.DomEvent.on(this._container, "mousedown", this._onMouseDown, this);
        },
        removeHooks: function() {
            L.DomEvent.off(this._container, "mousedown", this._onMouseDown);
            this._moved = false;
        },
        moved: function() {
            return this._moved;
        },
        _onMouseDown: function(e) {
            this._moved = false;
            if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
                return false;
            }
            L.DomUtil.disableTextSelection();
            L.DomUtil.disableImageDrag();
            this._startLayerPoint = this._map.mouseEventToLayerPoint(e);
            L.DomEvent.on(document, "mousemove", this._onMouseMove, this).on(document, "mouseup", this._onMouseUp, this).on(document, "keydown", this._onKeyDown, this);
        },
        _onMouseMove: function(e) {
            if (!this._moved) {
                this._box = L.DomUtil.create("div", "leaflet-zoom-box", this._pane);
                L.DomUtil.setPosition(this._box, this._startLayerPoint);
                //TODO refactor: move cursor to styles
                this._container.style.cursor = "crosshair";
                this._map.fire("boxzoomstart");
            }
            var startPoint = this._startLayerPoint, box = this._box, layerPoint = this._map.mouseEventToLayerPoint(e), offset = layerPoint.subtract(startPoint), newPos = new L.Point(Math.min(layerPoint.x, startPoint.x), Math.min(layerPoint.y, startPoint.y));
            L.DomUtil.setPosition(box, newPos);
            this._moved = true;
            // TODO refactor: remove hardcoded 4 pixels
            box.style.width = Math.max(0, Math.abs(offset.x) - 4) + "px";
            box.style.height = Math.max(0, Math.abs(offset.y) - 4) + "px";
        },
        _finish: function() {
            if (this._moved) {
                this._pane.removeChild(this._box);
                this._container.style.cursor = "";
            }
            L.DomUtil.enableTextSelection();
            L.DomUtil.enableImageDrag();
            L.DomEvent.off(document, "mousemove", this._onMouseMove).off(document, "mouseup", this._onMouseUp).off(document, "keydown", this._onKeyDown);
        },
        _onMouseUp: function(e) {
            this._finish();
            var map = this._map, layerPoint = map.mouseEventToLayerPoint(e);
            if (this._startLayerPoint.equals(layerPoint)) {
                return;
            }
            var bounds = new L.LatLngBounds(map.layerPointToLatLng(this._startLayerPoint), map.layerPointToLatLng(layerPoint));
            map.fitBounds(bounds);
            map.fire("boxzoomend", {
                boxZoomBounds: bounds
            });
        },
        _onKeyDown: function(e) {
            if (e.keyCode === 27) {
                this._finish();
            }
        }
    });
    L.Map.addInitHook("addHandler", "boxZoom", L.Map.BoxZoom);
    /*
 * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
 */
    L.Map.mergeOptions({
        keyboard: true,
        keyboardPanOffset: 80,
        keyboardZoomOffset: 1
    });
    L.Map.Keyboard = L.Handler.extend({
        keyCodes: {
            left: [ 37 ],
            right: [ 39 ],
            down: [ 40 ],
            up: [ 38 ],
            zoomIn: [ 187, 107, 61, 171 ],
            zoomOut: [ 189, 109, 173 ]
        },
        initialize: function(map) {
            this._map = map;
            this._setPanOffset(map.options.keyboardPanOffset);
            this._setZoomOffset(map.options.keyboardZoomOffset);
        },
        addHooks: function() {
            var container = this._map._container;
            // make the container focusable by tabbing
            if (container.tabIndex === -1) {
                container.tabIndex = "0";
            }
            L.DomEvent.on(container, "focus", this._onFocus, this).on(container, "blur", this._onBlur, this).on(container, "mousedown", this._onMouseDown, this);
            this._map.on("focus", this._addHooks, this).on("blur", this._removeHooks, this);
        },
        removeHooks: function() {
            this._removeHooks();
            var container = this._map._container;
            L.DomEvent.off(container, "focus", this._onFocus, this).off(container, "blur", this._onBlur, this).off(container, "mousedown", this._onMouseDown, this);
            this._map.off("focus", this._addHooks, this).off("blur", this._removeHooks, this);
        },
        _onMouseDown: function() {
            if (this._focused) {
                return;
            }
            var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;
            this._map._container.focus();
            window.scrollTo(left, top);
        },
        _onFocus: function() {
            this._focused = true;
            this._map.fire("focus");
        },
        _onBlur: function() {
            this._focused = false;
            this._map.fire("blur");
        },
        _setPanOffset: function(pan) {
            var keys = this._panKeys = {}, codes = this.keyCodes, i, len;
            for (i = 0, len = codes.left.length; i < len; i++) {
                keys[codes.left[i]] = [ -1 * pan, 0 ];
            }
            for (i = 0, len = codes.right.length; i < len; i++) {
                keys[codes.right[i]] = [ pan, 0 ];
            }
            for (i = 0, len = codes.down.length; i < len; i++) {
                keys[codes.down[i]] = [ 0, pan ];
            }
            for (i = 0, len = codes.up.length; i < len; i++) {
                keys[codes.up[i]] = [ 0, -1 * pan ];
            }
        },
        _setZoomOffset: function(zoom) {
            var keys = this._zoomKeys = {}, codes = this.keyCodes, i, len;
            for (i = 0, len = codes.zoomIn.length; i < len; i++) {
                keys[codes.zoomIn[i]] = zoom;
            }
            for (i = 0, len = codes.zoomOut.length; i < len; i++) {
                keys[codes.zoomOut[i]] = -zoom;
            }
        },
        _addHooks: function() {
            L.DomEvent.on(document, "keydown", this._onKeyDown, this);
        },
        _removeHooks: function() {
            L.DomEvent.off(document, "keydown", this._onKeyDown, this);
        },
        _onKeyDown: function(e) {
            var key = e.keyCode, map = this._map;
            if (key in this._panKeys) {
                if (map._panAnim && map._panAnim._inProgress) {
                    return;
                }
                map.panBy(this._panKeys[key]);
                if (map.options.maxBounds) {
                    map.panInsideBounds(map.options.maxBounds);
                }
            } else if (key in this._zoomKeys) {
                map.setZoom(map.getZoom() + this._zoomKeys[key]);
            } else {
                return;
            }
            L.DomEvent.stop(e);
        }
    });
    L.Map.addInitHook("addHandler", "keyboard", L.Map.Keyboard);
    /*
 * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
 */
    L.Handler.MarkerDrag = L.Handler.extend({
        initialize: function(marker) {
            this._marker = marker;
        },
        addHooks: function() {
            var icon = this._marker._icon;
            if (!this._draggable) {
                this._draggable = new L.Draggable(icon, icon);
            }
            this._draggable.on("dragstart", this._onDragStart, this).on("drag", this._onDrag, this).on("dragend", this._onDragEnd, this);
            this._draggable.enable();
            L.DomUtil.addClass(this._marker._icon, "leaflet-marker-draggable");
        },
        removeHooks: function() {
            this._draggable.off("dragstart", this._onDragStart, this).off("drag", this._onDrag, this).off("dragend", this._onDragEnd, this);
            this._draggable.disable();
            L.DomUtil.removeClass(this._marker._icon, "leaflet-marker-draggable");
        },
        moved: function() {
            return this._draggable && this._draggable._moved;
        },
        _onDragStart: function() {
            this._marker.closePopup().fire("movestart").fire("dragstart");
        },
        _onDrag: function() {
            var marker = this._marker, shadow = marker._shadow, iconPos = L.DomUtil.getPosition(marker._icon), latlng = marker._map.layerPointToLatLng(iconPos);
            // update shadow position
            if (shadow) {
                L.DomUtil.setPosition(shadow, iconPos);
            }
            marker._latlng = latlng;
            marker.fire("move", {
                latlng: latlng
            }).fire("drag");
        },
        _onDragEnd: function(e) {
            this._marker.fire("moveend").fire("dragend", e);
        }
    });
    /*
 * L.Control is a base class for implementing map controls. Handles positioning.
 * All other controls extend from this class.
 */
    L.Control = L.Class.extend({
        options: {
            position: "topright"
        },
        initialize: function(options) {
            L.setOptions(this, options);
        },
        getPosition: function() {
            return this.options.position;
        },
        setPosition: function(position) {
            var map = this._map;
            if (map) {
                map.removeControl(this);
            }
            this.options.position = position;
            if (map) {
                map.addControl(this);
            }
            return this;
        },
        getContainer: function() {
            return this._container;
        },
        addTo: function(map) {
            this._map = map;
            var container = this._container = this.onAdd(map), pos = this.getPosition(), corner = map._controlCorners[pos];
            L.DomUtil.addClass(container, "leaflet-control");
            if (pos.indexOf("bottom") !== -1) {
                corner.insertBefore(container, corner.firstChild);
            } else {
                corner.appendChild(container);
            }
            return this;
        },
        removeFrom: function(map) {
            var pos = this.getPosition(), corner = map._controlCorners[pos];
            corner.removeChild(this._container);
            this._map = null;
            if (this.onRemove) {
                this.onRemove(map);
            }
            return this;
        },
        _refocusOnMap: function() {
            if (this._map) {
                this._map.getContainer().focus();
            }
        }
    });
    L.control = function(options) {
        return new L.Control(options);
    };
    // adds control-related methods to L.Map
    L.Map.include({
        addControl: function(control) {
            control.addTo(this);
            return this;
        },
        removeControl: function(control) {
            control.removeFrom(this);
            return this;
        },
        _initControlPos: function() {
            var corners = this._controlCorners = {}, l = "leaflet-", container = this._controlContainer = L.DomUtil.create("div", l + "control-container", this._container);
            function createCorner(vSide, hSide) {
                var className = l + vSide + " " + l + hSide;
                corners[vSide + hSide] = L.DomUtil.create("div", className, container);
            }
            createCorner("top", "left");
            createCorner("top", "right");
            createCorner("bottom", "left");
            createCorner("bottom", "right");
        },
        _clearControlPos: function() {
            this._container.removeChild(this._controlContainer);
        }
    });
    /*
 * L.Control.Zoom is used for the default zoom buttons on the map.
 */
    L.Control.Zoom = L.Control.extend({
        options: {
            position: "topleft",
            zoomInText: "+",
            zoomInTitle: "Zoom in",
            zoomOutText: "-",
            zoomOutTitle: "Zoom out"
        },
        onAdd: function(map) {
            var zoomName = "leaflet-control-zoom", container = L.DomUtil.create("div", zoomName + " leaflet-bar");
            this._map = map;
            this._zoomInButton = this._createButton(this.options.zoomInText, this.options.zoomInTitle, zoomName + "-in", container, this._zoomIn, this);
            this._zoomOutButton = this._createButton(this.options.zoomOutText, this.options.zoomOutTitle, zoomName + "-out", container, this._zoomOut, this);
            this._updateDisabled();
            map.on("zoomend zoomlevelschange", this._updateDisabled, this);
            return container;
        },
        onRemove: function(map) {
            map.off("zoomend zoomlevelschange", this._updateDisabled, this);
        },
        _zoomIn: function(e) {
            this._map.zoomIn(e.shiftKey ? 3 : 1);
        },
        _zoomOut: function(e) {
            this._map.zoomOut(e.shiftKey ? 3 : 1);
        },
        _createButton: function(html, title, className, container, fn, context) {
            var link = L.DomUtil.create("a", className, container);
            link.innerHTML = html;
            link.href = "#";
            link.title = title;
            var stop = L.DomEvent.stopPropagation;
            L.DomEvent.on(link, "click", stop).on(link, "mousedown", stop).on(link, "dblclick", stop).on(link, "click", L.DomEvent.preventDefault).on(link, "click", fn, context).on(link, "click", this._refocusOnMap, context);
            return link;
        },
        _updateDisabled: function() {
            var map = this._map, className = "leaflet-disabled";
            L.DomUtil.removeClass(this._zoomInButton, className);
            L.DomUtil.removeClass(this._zoomOutButton, className);
            if (map._zoom === map.getMinZoom()) {
                L.DomUtil.addClass(this._zoomOutButton, className);
            }
            if (map._zoom === map.getMaxZoom()) {
                L.DomUtil.addClass(this._zoomInButton, className);
            }
        }
    });
    L.Map.mergeOptions({
        zoomControl: true
    });
    L.Map.addInitHook(function() {
        if (this.options.zoomControl) {
            this.zoomControl = new L.Control.Zoom();
            this.addControl(this.zoomControl);
        }
    });
    L.control.zoom = function(options) {
        return new L.Control.Zoom(options);
    };
    /*
 * L.Control.Attribution is used for displaying attribution on the map (added by default).
 */
    L.Control.Attribution = L.Control.extend({
        options: {
            position: "bottomright",
            prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
        },
        initialize: function(options) {
            L.setOptions(this, options);
            this._attributions = {};
        },
        onAdd: function(map) {
            this._container = L.DomUtil.create("div", "leaflet-control-attribution");
            L.DomEvent.disableClickPropagation(this._container);
            for (var i in map._layers) {
                if (map._layers[i].getAttribution) {
                    this.addAttribution(map._layers[i].getAttribution());
                }
            }
            map.on("layeradd", this._onLayerAdd, this).on("layerremove", this._onLayerRemove, this);
            this._update();
            return this._container;
        },
        onRemove: function(map) {
            map.off("layeradd", this._onLayerAdd).off("layerremove", this._onLayerRemove);
        },
        setPrefix: function(prefix) {
            this.options.prefix = prefix;
            this._update();
            return this;
        },
        addAttribution: function(text) {
            if (!text) {
                return;
            }
            if (!this._attributions[text]) {
                this._attributions[text] = 0;
            }
            this._attributions[text]++;
            this._update();
            return this;
        },
        removeAttribution: function(text) {
            if (!text) {
                return;
            }
            if (this._attributions[text]) {
                this._attributions[text]--;
                this._update();
            }
            return this;
        },
        _update: function() {
            if (!this._map) {
                return;
            }
            var attribs = [];
            for (var i in this._attributions) {
                if (this._attributions[i]) {
                    attribs.push(i);
                }
            }
            var prefixAndAttribs = [];
            if (this.options.prefix) {
                prefixAndAttribs.push(this.options.prefix);
            }
            if (attribs.length) {
                prefixAndAttribs.push(attribs.join(", "));
            }
            this._container.innerHTML = prefixAndAttribs.join(" | ");
        },
        _onLayerAdd: function(e) {
            if (e.layer.getAttribution) {
                this.addAttribution(e.layer.getAttribution());
            }
        },
        _onLayerRemove: function(e) {
            if (e.layer.getAttribution) {
                this.removeAttribution(e.layer.getAttribution());
            }
        }
    });
    L.Map.mergeOptions({
        attributionControl: true
    });
    L.Map.addInitHook(function() {
        if (this.options.attributionControl) {
            this.attributionControl = new L.Control.Attribution().addTo(this);
        }
    });
    L.control.attribution = function(options) {
        return new L.Control.Attribution(options);
    };
    /*
 * L.Control.Scale is used for displaying metric/imperial scale on the map.
 */
    L.Control.Scale = L.Control.extend({
        options: {
            position: "bottomleft",
            maxWidth: 100,
            metric: true,
            imperial: true,
            updateWhenIdle: false
        },
        onAdd: function(map) {
            this._map = map;
            var className = "leaflet-control-scale", container = L.DomUtil.create("div", className), options = this.options;
            this._addScales(options, className, container);
            map.on(options.updateWhenIdle ? "moveend" : "move", this._update, this);
            map.whenReady(this._update, this);
            return container;
        },
        onRemove: function(map) {
            map.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
        },
        _addScales: function(options, className, container) {
            if (options.metric) {
                this._mScale = L.DomUtil.create("div", className + "-line", container);
            }
            if (options.imperial) {
                this._iScale = L.DomUtil.create("div", className + "-line", container);
            }
        },
        _update: function() {
            var bounds = this._map.getBounds(), centerLat = bounds.getCenter().lat, halfWorldMeters = 6378137 * Math.PI * Math.cos(centerLat * Math.PI / 180), dist = halfWorldMeters * (bounds.getNorthEast().lng - bounds.getSouthWest().lng) / 180, size = this._map.getSize(), options = this.options, maxMeters = 0;
            if (size.x > 0) {
                maxMeters = dist * (options.maxWidth / size.x);
            }
            this._updateScales(options, maxMeters);
        },
        _updateScales: function(options, maxMeters) {
            if (options.metric && maxMeters) {
                this._updateMetric(maxMeters);
            }
            if (options.imperial && maxMeters) {
                this._updateImperial(maxMeters);
            }
        },
        _updateMetric: function(maxMeters) {
            var meters = this._getRoundNum(maxMeters);
            this._mScale.style.width = this._getScaleWidth(meters / maxMeters) + "px";
            this._mScale.innerHTML = meters < 1e3 ? meters + " m" : meters / 1e3 + " km";
        },
        _updateImperial: function(maxMeters) {
            var maxFeet = maxMeters * 3.2808399, scale = this._iScale, maxMiles, miles, feet;
            if (maxFeet > 5280) {
                maxMiles = maxFeet / 5280;
                miles = this._getRoundNum(maxMiles);
                scale.style.width = this._getScaleWidth(miles / maxMiles) + "px";
                scale.innerHTML = miles + " mi";
            } else {
                feet = this._getRoundNum(maxFeet);
                scale.style.width = this._getScaleWidth(feet / maxFeet) + "px";
                scale.innerHTML = feet + " ft";
            }
        },
        _getScaleWidth: function(ratio) {
            return Math.round(this.options.maxWidth * ratio) - 10;
        },
        _getRoundNum: function(num) {
            var pow10 = Math.pow(10, (Math.floor(num) + "").length - 1), d = num / pow10;
            d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
            return pow10 * d;
        }
    });
    L.control.scale = function(options) {
        return new L.Control.Scale(options);
    };
    /*
 * L.Control.Layers is a control to allow users to switch between different layers on the map.
 */
    L.Control.Layers = L.Control.extend({
        options: {
            collapsed: true,
            position: "topright",
            autoZIndex: true
        },
        initialize: function(baseLayers, overlays, options) {
            L.setOptions(this, options);
            this._layers = {};
            this._lastZIndex = 0;
            this._handlingClick = false;
            for (var i in baseLayers) {
                this._addLayer(baseLayers[i], i);
            }
            for (i in overlays) {
                this._addLayer(overlays[i], i, true);
            }
        },
        onAdd: function(map) {
            this._initLayout();
            this._update();
            map.on("layeradd", this._onLayerChange, this).on("layerremove", this._onLayerChange, this);
            return this._container;
        },
        onRemove: function(map) {
            map.off("layeradd", this._onLayerChange, this).off("layerremove", this._onLayerChange, this);
        },
        addBaseLayer: function(layer, name) {
            this._addLayer(layer, name);
            this._update();
            return this;
        },
        addOverlay: function(layer, name) {
            this._addLayer(layer, name, true);
            this._update();
            return this;
        },
        removeLayer: function(layer) {
            var id = L.stamp(layer);
            delete this._layers[id];
            this._update();
            return this;
        },
        _initLayout: function() {
            var className = "leaflet-control-layers", container = this._container = L.DomUtil.create("div", className);
            //Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released
            container.setAttribute("aria-haspopup", true);
            if (!L.Browser.touch) {
                L.DomEvent.disableClickPropagation(container).disableScrollPropagation(container);
            } else {
                L.DomEvent.on(container, "click", L.DomEvent.stopPropagation);
            }
            var form = this._form = L.DomUtil.create("form", className + "-list");
            if (this.options.collapsed) {
                if (!L.Browser.android) {
                    L.DomEvent.on(container, "mouseover", this._expand, this).on(container, "mouseout", this._collapse, this);
                }
                var link = this._layersLink = L.DomUtil.create("a", className + "-toggle", container);
                link.href = "#";
                link.title = "Layers";
                if (L.Browser.touch) {
                    L.DomEvent.on(link, "click", L.DomEvent.stop).on(link, "click", this._expand, this);
                } else {
                    L.DomEvent.on(link, "focus", this._expand, this);
                }
                //Work around for Firefox android issue https://github.com/Leaflet/Leaflet/issues/2033
                L.DomEvent.on(form, "click", function() {
                    setTimeout(L.bind(this._onInputClick, this), 0);
                }, this);
                this._map.on("click", this._collapse, this);
            } else {
                this._expand();
            }
            this._baseLayersList = L.DomUtil.create("div", className + "-base", form);
            this._separator = L.DomUtil.create("div", className + "-separator", form);
            this._overlaysList = L.DomUtil.create("div", className + "-overlays", form);
            container.appendChild(form);
        },
        _addLayer: function(layer, name, overlay) {
            var id = L.stamp(layer);
            this._layers[id] = {
                layer: layer,
                name: name,
                overlay: overlay
            };
            if (this.options.autoZIndex && layer.setZIndex) {
                this._lastZIndex++;
                layer.setZIndex(this._lastZIndex);
            }
        },
        _update: function() {
            if (!this._container) {
                return;
            }
            this._baseLayersList.innerHTML = "";
            this._overlaysList.innerHTML = "";
            var baseLayersPresent = false, overlaysPresent = false, i, obj;
            for (i in this._layers) {
                obj = this._layers[i];
                this._addItem(obj);
                overlaysPresent = overlaysPresent || obj.overlay;
                baseLayersPresent = baseLayersPresent || !obj.overlay;
            }
            this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none";
        },
        _onLayerChange: function(e) {
            var obj = this._layers[L.stamp(e.layer)];
            if (!obj) {
                return;
            }
            if (!this._handlingClick) {
                this._update();
            }
            var type = obj.overlay ? e.type === "layeradd" ? "overlayadd" : "overlayremove" : e.type === "layeradd" ? "baselayerchange" : null;
            if (type) {
                this._map.fire(type, obj);
            }
        },
        // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
        _createRadioElement: function(name, checked) {
            var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"';
            if (checked) {
                radioHtml += ' checked="checked"';
            }
            radioHtml += "/>";
            var radioFragment = document.createElement("div");
            radioFragment.innerHTML = radioHtml;
            return radioFragment.firstChild;
        },
        _addItem: function(obj) {
            var label = document.createElement("label"), input, checked = this._map.hasLayer(obj.layer);
            if (obj.overlay) {
                input = document.createElement("input");
                input.type = "checkbox";
                input.className = "leaflet-control-layers-selector";
                input.defaultChecked = checked;
            } else {
                input = this._createRadioElement("leaflet-base-layers", checked);
            }
            input.layerId = L.stamp(obj.layer);
            L.DomEvent.on(input, "click", this._onInputClick, this);
            var name = document.createElement("span");
            name.innerHTML = " " + obj.name;
            label.appendChild(input);
            label.appendChild(name);
            var container = obj.overlay ? this._overlaysList : this._baseLayersList;
            container.appendChild(label);
            return label;
        },
        _onInputClick: function() {
            var i, input, obj, inputs = this._form.getElementsByTagName("input"), inputsLen = inputs.length;
            this._handlingClick = true;
            for (i = 0; i < inputsLen; i++) {
                input = inputs[i];
                obj = this._layers[input.layerId];
                if (input.checked && !this._map.hasLayer(obj.layer)) {
                    this._map.addLayer(obj.layer);
                } else if (!input.checked && this._map.hasLayer(obj.layer)) {
                    this._map.removeLayer(obj.layer);
                }
            }
            this._handlingClick = false;
            this._refocusOnMap();
        },
        _expand: function() {
            L.DomUtil.addClass(this._container, "leaflet-control-layers-expanded");
        },
        _collapse: function() {
            this._container.className = this._container.className.replace(" leaflet-control-layers-expanded", "");
        }
    });
    L.control.layers = function(baseLayers, overlays, options) {
        return new L.Control.Layers(baseLayers, overlays, options);
    };
    /*
 * L.PosAnimation is used by Leaflet internally for pan animations.
 */
    L.PosAnimation = L.Class.extend({
        includes: L.Mixin.Events,
        run: function(el, newPos, duration, easeLinearity) {
            // (HTMLElement, Point[, Number, Number])
            this.stop();
            this._el = el;
            this._inProgress = true;
            this._newPos = newPos;
            this.fire("start");
            el.style[L.DomUtil.TRANSITION] = "all " + (duration || .25) + "s cubic-bezier(0,0," + (easeLinearity || .5) + ",1)";
            L.DomEvent.on(el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);
            L.DomUtil.setPosition(el, newPos);
            // toggle reflow, Chrome flickers for some reason if you don't do this
            L.Util.falseFn(el.offsetWidth);
            // there's no native way to track value updates of transitioned properties, so we imitate this
            this._stepTimer = setInterval(L.bind(this._onStep, this), 50);
        },
        stop: function() {
            if (!this._inProgress) {
                return;
            }
            // if we just removed the transition property, the element would jump to its final position,
            // so we need to make it stay at the current position
            L.DomUtil.setPosition(this._el, this._getPos());
            this._onTransitionEnd();
            L.Util.falseFn(this._el.offsetWidth);
        },
        _onStep: function() {
            var stepPos = this._getPos();
            if (!stepPos) {
                this._onTransitionEnd();
                return;
            }
            // jshint camelcase: false
            // make L.DomUtil.getPosition return intermediate position value during animation
            this._el._leaflet_pos = stepPos;
            this.fire("step");
        },
        // you can't easily get intermediate values of properties animated with CSS3 Transitions,
        // we need to parse computed style (in case of transform it returns matrix string)
        _transformRe: /([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,
        _getPos: function() {
            var left, top, matches, el = this._el, style = window.getComputedStyle(el);
            if (L.Browser.any3d) {
                matches = style[L.DomUtil.TRANSFORM].match(this._transformRe);
                if (!matches) {
                    return;
                }
                left = parseFloat(matches[1]);
                top = parseFloat(matches[2]);
            } else {
                left = parseFloat(style.left);
                top = parseFloat(style.top);
            }
            return new L.Point(left, top, true);
        },
        _onTransitionEnd: function() {
            L.DomEvent.off(this._el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);
            if (!this._inProgress) {
                return;
            }
            this._inProgress = false;
            this._el.style[L.DomUtil.TRANSITION] = "";
            // jshint camelcase: false
            // make sure L.DomUtil.getPosition returns the final position value after animation
            this._el._leaflet_pos = this._newPos;
            clearInterval(this._stepTimer);
            this.fire("step").fire("end");
        }
    });
    /*
 * Extends L.Map to handle panning animations.
 */
    L.Map.include({
        setView: function(center, zoom, options) {
            zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
            center = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);
            options = options || {};
            if (this._panAnim) {
                this._panAnim.stop();
            }
            if (this._loaded && !options.reset && options !== true) {
                if (options.animate !== undefined) {
                    options.zoom = L.extend({
                        animate: options.animate
                    }, options.zoom);
                    options.pan = L.extend({
                        animate: options.animate
                    }, options.pan);
                }
                // try animating pan or zoom
                var animated = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);
                if (animated) {
                    // prevent resize handler call, the view will refresh after animation anyway
                    clearTimeout(this._sizeTimer);
                    return this;
                }
            }
            // animation didn't start, just reset the map view
            this._resetView(center, zoom);
            return this;
        },
        panBy: function(offset, options) {
            offset = L.point(offset).round();
            options = options || {};
            if (!offset.x && !offset.y) {
                return this;
            }
            if (!this._panAnim) {
                this._panAnim = new L.PosAnimation();
                this._panAnim.on({
                    step: this._onPanTransitionStep,
                    end: this._onPanTransitionEnd
                }, this);
            }
            // don't fire movestart if animating inertia
            if (!options.noMoveStart) {
                this.fire("movestart");
            }
            // animate pan unless animate: false specified
            if (options.animate !== false) {
                L.DomUtil.addClass(this._mapPane, "leaflet-pan-anim");
                var newPos = this._getMapPanePos().subtract(offset);
                this._panAnim.run(this._mapPane, newPos, options.duration || .25, options.easeLinearity);
            } else {
                this._rawPanBy(offset);
                this.fire("move").fire("moveend");
            }
            return this;
        },
        _onPanTransitionStep: function() {
            this.fire("move");
        },
        _onPanTransitionEnd: function() {
            L.DomUtil.removeClass(this._mapPane, "leaflet-pan-anim");
            this.fire("moveend");
        },
        _tryAnimatedPan: function(center, options) {
            // difference between the new and current centers in pixels
            var offset = this._getCenterOffset(center)._floor();
            // don't animate too far unless animate: true specified in options
            if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
                return false;
            }
            this.panBy(offset, options);
            return true;
        }
    });
    /*
 * L.PosAnimation fallback implementation that powers Leaflet pan animations
 * in browsers that don't support CSS3 Transitions.
 */
    L.PosAnimation = L.DomUtil.TRANSITION ? L.PosAnimation : L.PosAnimation.extend({
        run: function(el, newPos, duration, easeLinearity) {
            // (HTMLElement, Point[, Number, Number])
            this.stop();
            this._el = el;
            this._inProgress = true;
            this._duration = duration || .25;
            this._easeOutPower = 1 / Math.max(easeLinearity || .5, .2);
            this._startPos = L.DomUtil.getPosition(el);
            this._offset = newPos.subtract(this._startPos);
            this._startTime = +new Date();
            this.fire("start");
            this._animate();
        },
        stop: function() {
            if (!this._inProgress) {
                return;
            }
            this._step();
            this._complete();
        },
        _animate: function() {
            // animation loop
            this._animId = L.Util.requestAnimFrame(this._animate, this);
            this._step();
        },
        _step: function() {
            var elapsed = +new Date() - this._startTime, duration = this._duration * 1e3;
            if (elapsed < duration) {
                this._runFrame(this._easeOut(elapsed / duration));
            } else {
                this._runFrame(1);
                this._complete();
            }
        },
        _runFrame: function(progress) {
            var pos = this._startPos.add(this._offset.multiplyBy(progress));
            L.DomUtil.setPosition(this._el, pos);
            this.fire("step");
        },
        _complete: function() {
            L.Util.cancelAnimFrame(this._animId);
            this._inProgress = false;
            this.fire("end");
        },
        _easeOut: function(t) {
            return 1 - Math.pow(1 - t, this._easeOutPower);
        }
    });
    /*
 * Extends L.Map to handle zoom animations.
 */
    L.Map.mergeOptions({
        zoomAnimation: true,
        zoomAnimationThreshold: 4
    });
    if (L.DomUtil.TRANSITION) {
        L.Map.addInitHook(function() {
            // don't animate on browsers without hardware-accelerated transitions or old Android/Opera
            this._zoomAnimated = this.options.zoomAnimation && L.DomUtil.TRANSITION && L.Browser.any3d && !L.Browser.android23 && !L.Browser.mobileOpera;
            // zoom transitions run with the same duration for all layers, so if one of transitionend events
            // happens after starting zoom animation (propagating to the map pane), we know that it ended globally
            if (this._zoomAnimated) {
                L.DomEvent.on(this._mapPane, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);
            }
        });
    }
    L.Map.include(!L.DomUtil.TRANSITION ? {} : {
        _catchTransitionEnd: function(e) {
            if (this._animatingZoom && e.propertyName.indexOf("transform") >= 0) {
                this._onZoomTransitionEnd();
            }
        },
        _nothingToAnimate: function() {
            return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
        },
        _tryAnimatedZoom: function(center, zoom, options) {
            if (this._animatingZoom) {
                return true;
            }
            options = options || {};
            // don't animate if disabled, not supported or zoom difference is too large
            if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {
                return false;
            }
            // offset is the pixel coords of the zoom origin relative to the current center
            var scale = this.getZoomScale(zoom), offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale), origin = this._getCenterLayerPoint()._add(offset);
            // don't animate if the zoom origin isn't within one screen from the current center, unless forced
            if (options.animate !== true && !this.getSize().contains(offset)) {
                return false;
            }
            this.fire("movestart").fire("zoomstart");
            this._animateZoom(center, zoom, origin, scale, null, true);
            return true;
        },
        _animateZoom: function(center, zoom, origin, scale, delta, backwards, forTouchZoom) {
            if (!forTouchZoom) {
                this._animatingZoom = true;
            }
            // put transform transition on all layers with leaflet-zoom-animated class
            L.DomUtil.addClass(this._mapPane, "leaflet-zoom-anim");
            // remember what center/zoom to set after animation
            this._animateToCenter = center;
            this._animateToZoom = zoom;
            // disable any dragging during animation
            if (L.Draggable) {
                L.Draggable._disabled = true;
            }
            L.Util.requestAnimFrame(function() {
                this.fire("zoomanim", {
                    center: center,
                    zoom: zoom,
                    origin: origin,
                    scale: scale,
                    delta: delta,
                    backwards: backwards
                });
            }, this);
        },
        _onZoomTransitionEnd: function() {
            this._animatingZoom = false;
            L.DomUtil.removeClass(this._mapPane, "leaflet-zoom-anim");
            this._resetView(this._animateToCenter, this._animateToZoom, true, true);
            if (L.Draggable) {
                L.Draggable._disabled = false;
            }
        }
    });
    /*
	Zoom animation logic for L.TileLayer.
*/
    L.TileLayer.include({
        _animateZoom: function(e) {
            if (!this._animating) {
                this._animating = true;
                this._prepareBgBuffer();
            }
            var bg = this._bgBuffer, transform = L.DomUtil.TRANSFORM, initialTransform = e.delta ? L.DomUtil.getTranslateString(e.delta) : bg.style[transform], scaleStr = L.DomUtil.getScaleString(e.scale, e.origin);
            bg.style[transform] = e.backwards ? scaleStr + " " + initialTransform : initialTransform + " " + scaleStr;
        },
        _endZoomAnim: function() {
            var front = this._tileContainer, bg = this._bgBuffer;
            front.style.visibility = "";
            front.parentNode.appendChild(front);
            // Bring to fore
            // force reflow
            L.Util.falseFn(bg.offsetWidth);
            this._animating = false;
        },
        _clearBgBuffer: function() {
            var map = this._map;
            if (map && !map._animatingZoom && !map.touchZoom._zooming) {
                this._bgBuffer.innerHTML = "";
                this._bgBuffer.style[L.DomUtil.TRANSFORM] = "";
            }
        },
        _prepareBgBuffer: function() {
            var front = this._tileContainer, bg = this._bgBuffer;
            // if foreground layer doesn't have many tiles but bg layer does,
            // keep the existing bg layer and just zoom it some more
            var bgLoaded = this._getLoadedTilesPercentage(bg), frontLoaded = this._getLoadedTilesPercentage(front);
            if (bg && bgLoaded > .5 && frontLoaded < .5) {
                front.style.visibility = "hidden";
                this._stopLoadingImages(front);
                return;
            }
            // prepare the buffer to become the front tile pane
            bg.style.visibility = "hidden";
            bg.style[L.DomUtil.TRANSFORM] = "";
            // switch out the current layer to be the new bg layer (and vice-versa)
            this._tileContainer = bg;
            bg = this._bgBuffer = front;
            this._stopLoadingImages(bg);
            //prevent bg buffer from clearing right after zoom
            clearTimeout(this._clearBgBufferTimer);
        },
        _getLoadedTilesPercentage: function(container) {
            var tiles = container.getElementsByTagName("img"), i, len, count = 0;
            for (i = 0, len = tiles.length; i < len; i++) {
                if (tiles[i].complete) {
                    count++;
                }
            }
            return count / len;
        },
        // stops loading all tiles in the background layer
        _stopLoadingImages: function(container) {
            var tiles = Array.prototype.slice.call(container.getElementsByTagName("img")), i, len, tile;
            for (i = 0, len = tiles.length; i < len; i++) {
                tile = tiles[i];
                if (!tile.complete) {
                    tile.onload = L.Util.falseFn;
                    tile.onerror = L.Util.falseFn;
                    tile.src = L.Util.emptyImageUrl;
                    tile.parentNode.removeChild(tile);
                }
            }
        }
    });
    /*
 * Provides L.Map with convenient shortcuts for using browser geolocation features.
 */
    L.Map.include({
        _defaultLocateOptions: {
            watch: false,
            setView: false,
            maxZoom: Infinity,
            timeout: 1e4,
            maximumAge: 0,
            enableHighAccuracy: false
        },
        locate: function(/*Object*/ options) {
            options = this._locateOptions = L.extend(this._defaultLocateOptions, options);
            if (!navigator.geolocation) {
                this._handleGeolocationError({
                    code: 0,
                    message: "Geolocation not supported."
                });
                return this;
            }
            var onResponse = L.bind(this._handleGeolocationResponse, this), onError = L.bind(this._handleGeolocationError, this);
            if (options.watch) {
                this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
            } else {
                navigator.geolocation.getCurrentPosition(onResponse, onError, options);
            }
            return this;
        },
        stopLocate: function() {
            if (navigator.geolocation) {
                navigator.geolocation.clearWatch(this._locationWatchId);
            }
            if (this._locateOptions) {
                this._locateOptions.setView = false;
            }
            return this;
        },
        _handleGeolocationError: function(error) {
            var c = error.code, message = error.message || (c === 1 ? "permission denied" : c === 2 ? "position unavailable" : "timeout");
            if (this._locateOptions.setView && !this._loaded) {
                this.fitWorld();
            }
            this.fire("locationerror", {
                code: c,
                message: "Geolocation error: " + message + "."
            });
        },
        _handleGeolocationResponse: function(pos) {
            var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new L.LatLng(lat, lng), latAccuracy = 180 * pos.coords.accuracy / 40075017, lngAccuracy = latAccuracy / Math.cos(L.LatLng.DEG_TO_RAD * lat), bounds = L.latLngBounds([ lat - latAccuracy, lng - lngAccuracy ], [ lat + latAccuracy, lng + lngAccuracy ]), options = this._locateOptions;
            if (options.setView) {
                var zoom = Math.min(this.getBoundsZoom(bounds), options.maxZoom);
                this.setView(latlng, zoom);
            }
            var data = {
                latlng: latlng,
                bounds: bounds,
                timestamp: pos.timestamp
            };
            for (var i in pos.coords) {
                if (typeof pos.coords[i] === "number") {
                    data[i] = pos.coords[i];
                }
            }
            this.fire("locationfound", data);
        }
    });
})(window, document);

!function(t, e, i, n) {
    "use strict";
    Array.isArray || (Array.isArray = function(t) {
        return "[object Array]" === Object.prototype.toString.call(t);
    }), Array.prototype.indexOf || (Array.prototype.indexOf = function(t, e) {
        var i;
        if (null === this || void 0 === this) throw new TypeError('"this" is null or not defined');
        var n = Object(this), r = n.length >>> 0;
        if (0 === r) return -1;
        var a = +e || 0;
        if (1 / 0 === Math.abs(a) && (a = 0), a >= r) return -1;
        for (i = Math.max(a >= 0 ? a : r - Math.abs(a), 0); r > i; ) {
            if (i in n && n[i] === t) return i;
            i++;
        }
        return -1;
    });
    var r = t.maptiks || {};
    "object" == typeof i && "object" == typeof i.exports ? i.exports = r : "function" == typeof n && n.amd && n(r), 
    t.maptiks = r, r._minifiedObjectPropertyMap = {
        action: "act",
        category: "cat",
        clickable: "clck",
        draggable: "drag",
        href: "href",
        icon: "ico",
        id: "id",
        initial: "init",
        internal: "intr",
        label: "lbl",
        map_bbox: "bbox",
        map_center: "cp",
        map_id: "mid",
        map_library: "lib",
        map_session: "msid",
        map_trackcode: "tid",
        map_zoom: "zm",
        marker: "mkr",
        popup: "pop",
        popup_active: "popa",
        position: "pos",
        position_initial: "posi",
        session: "lsid",
        tile_center: "tcp",
        tile_url: "turl",
        timestamp: "t",
        url: "url",
        value: "vle"
    }, r._server_template = "//{s}.maptiks.com/store/a.gif", r._subdomains = [ "a", "b", "c", "d" ], 
    r.debug = r.debug || null, r.standalone = r.standalone || null, r.trackcode = r.trackcode || null, 
    r.version = "0.3.5", r.track = r.track || {}, r.track.Base = function(t) {
        var e = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[0-9a-f]{4}-[0-9a-f]{12}$/, i = t.session.match(e), n = t.trackcode.match(e);
        if (null === t.id || void 0 === t.id) throw "Maptiks ID must be defined";
        if (this._id = t.id.toString(), "leaflet" !== t.library && "gmaps" !== t.library && "ol3" !== t.library) throw "Library must defined as leaflet, gmaps, or ol3";
        if (this._library = t.library, null === t.map || void 0 === t.map) throw "Map must be defined";
        if ("object" != typeof t.map) throw "Map must be an object";
        if (this._map = t.map, "string" != typeof t.session || "" === t.session) throw "Session must be defined";
        if (!i) throw "Session must be a v4 UUID, use maptiks.utils.generateUUID()";
        if (this._session = t.session, "string" != typeof t.trackcode || "" === t.trackcode) throw "Trackcode must be defined";
        if (!n) throw "Trackcode not valid";
        if (this._trackcode = t.trackcode, null !== t.debug && void 0 !== t.debug) {
            if ("boolean" != typeof t.debug) throw "Debug must be true or false";
            this._debug = t.debug;
        } else this._debug = !1;
        if (null !== t.standalone && void 0 !== t.standalone) {
            if ("boolean" != typeof t.standalone) throw "Standalone must be true or false";
            this._standalone = t.standalone;
        } else this._standalone = !1;
        if (null === t.getMapState || void 0 === t.getMapState) throw "getMapState must be defined";
        if ("function" != typeof t.getMapState) throw "getMapState must be a function";
        this.getMapState = t.getMapState;
    }, r.track.Base.mixin = function(t) {
        r.utils.extend(r.track.Base.prototype, t);
    }, r.track.Base.prototype = {
        constructor: function() {},
        _subdomain_index: 0,
        _getServerUrl: function() {
            var t;
            return this._subdomain_index >= r._subdomains.length && (this._subdomain_index = 0), 
            t = r.utils.template(r._server_template, {
                s: r._subdomains[this._subdomain_index]
            }), this._subdomain_index++, t;
        },
        _isInitial: function() {
            return new Date().getTime() - this._initialTime < this._initialTimeout;
        },
        _minifyObjectPropertyNames: function(t) {
            var e = r._minifiedObjectPropertyMap, i = {};
            for (var n in t) t.hasOwnProperty(n) && e.hasOwnProperty(n) ? i[e[n]] = t[n] : i[n] = t[n];
            return i;
        },
        getId: function() {
            return this._id;
        },
        getLibrary: function() {
            return this._library;
        },
        getMapState: function() {
            throw "getMapState has not been overriden with map library";
        },
        getSession: function() {
            return this._session;
        },
        getTrackcode: function() {
            return this._trackcode;
        },
        track: function(t, i) {
            var n, a, o, s, c = new Image(), u = [], p = this.getMapState();
            if ("object" == typeof t && t !== {}) {
                t.map_id = this.getId(), t.map_library = this.getLibrary(), t.map_session = this.getSession(), 
                t.map_trackcode = this.getTrackcode(), t.map_bbox = p.bbox, t.map_center = p.center, 
                t.map_zoom = p.zoom, t.timestamp = new Date().getTime(), t = this._minifyObjectPropertyNames(t);
                for (s in t) if (t.hasOwnProperty(s)) {
                    if (a = t[s], o = typeof a, Array.isArray(t[s])) a = a.join(","); else if (-1 === [ "string", "number", "boolean" ].indexOf(o)) continue;
                    u.push(encodeURIComponent(s) + "=" + encodeURIComponent(a));
                }
                if (e && (this._debug || r.debug || "debug" === i)) {
                    e.log("***");
                    for (var l in u) u.hasOwnProperty(l) && e.log(decodeURIComponent(u[l]).replace("=", ": "));
                } else "test" === i || (n = this._getServerUrl(), c.src = n + "?" + u.join("&"));
                return t;
            }
        }
    }, r.track.Map = function() {}, r.track.Map.mixin = function(t) {
        r.utils.extend(r.track.Map.prototype, t);
    }, r.track.Map.prototype = {
        constructor: function() {},
        _mapSessionTracked: null,
        getMap: function() {
            return this._map;
        },
        _trackMap: function(t) {
            this._standalone || this.track({
                category: t.category,
                action: t.action,
                label: t.label,
                internal: !0
            });
        },
        trackMapSession: function() {
            this._mapSessionTracked || (this._mapSessionTracked = !0, this._trackMap({
                category: "map",
                action: "mapload",
                label: "mapsession"
            }));
        },
        trackPanZoom: function() {
            this.getMapState().zoom === this._zoom ? this._trackMap({
                category: "map",
                action: "mapactivity",
                label: "pan"
            }) : this._zoom && this._trackMap({
                category: "map",
                action: "mapactivity",
                label: "zoom"
            }), this._zoom = this.getMapState().zoom;
        }
    }, r.track.Layer = function() {}, r.track.Layer.mixin = function(t) {
        r.utils.extend(r.track.Layer.prototype, t);
    }, r.track.Layer.prototype = {
        constructor: function() {},
        _layers: null,
        _trackLayer: function(t, e) {
            this._standalone || this.track({
                category: e.category,
                action: e.action,
                label: e.label,
                value: e.value,
                id: t.getId(),
                session: t.getSession(),
                url: t.getUrl(),
                tile_center: e.tile_center,
                tile_url: e.tile_url,
                internal: !0
            });
        },
        getLayers: function() {
            return this._layers;
        },
        getActiveLayers: function() {
            for (var t = [], e = 0; e < this._layers.length; e++) this._layers[e].maptiks._session && t.push(this._layers[e]);
            return t;
        },
        getInactiveLayers: function() {
            for (var t = [], e = 0; e < this._layers.length; e++) this._layers[e].maptiks._session || t.push(this._layers[e]);
            return t;
        },
        trackLayerAdd: function(t) {
            t._session = r.utils.generateUUID(), t = r.utils.createTimer(t), r.utils.pushUnique(this._layers, t._layer), 
            this._trackLayer(t, {
                category: "layersession",
                action: "statechange",
                label: "active"
            });
        },
        trackLayerRemove: function(t) {
            this._trackLayer(t, {
                category: "layersession",
                action: "statechange",
                label: "inactive"
            }), t._session = null;
        },
        trackLayerLoad: function(t) {
            t._timer && t.getSession() && this._trackLayer(t, {
                category: "tlayer",
                action: "layerload",
                value: t._timer.stop()
            });
        },
        trackTileError: function(t, e, i) {
            this._trackLayer(t, {
                category: "tlayer",
                action: "tileerror",
                tile_center: e,
                tile_url: i
            });
        }
    }, r.track.Marker = function() {}, r.track.Marker.mixin = function(t) {
        r.utils.extend(r.track.Marker.prototype, t);
    }, r.track.Marker.prototype = {
        constructor: function() {},
        _markers: null,
        _trackMarker: function(t, e) {
            var i = this;
            this._standalone || setTimeout(function() {
                i.track({
                    category: "marker",
                    action: e.action,
                    value: e.value,
                    id: t.getId(),
                    icon: t.getIcon(),
                    position: t.getPosition(),
                    position_initial: e.position,
                    popup: t.hasPopup(),
                    popup_active: t.isPopupActive(),
                    clickable: t.isClickable(),
                    draggable: t.isDraggable(),
                    internal: !0
                });
            }, 0);
        },
        getMarkers: function() {
            return this._markers;
        },
        getActiveMarkers: function() {
            for (var t = [], e = 0; e < this._markers.length; e++) this._markers[e].maptiks._active && t.push(this._markers[e]);
            return t;
        },
        getInactiveMarkers: function() {
            for (var t = [], e = 0; e < this._markers.length; e++) this._markers[e].maptiks._active || t.push(this._markers[e]);
            return t;
        },
        trackMarkerAdd: function(t) {
            t._active = !0, t = r.utils.createTimer(t), r.utils.pushUnique(this._markers, t._marker), 
            this._trackMarker(t, {
                action: "add"
            });
        },
        trackMarkerClick: function(t) {
            this._trackMarker(t, {
                action: "click"
            });
        },
        trackMarkerRemove: function(t) {
            t._timer && (t._active = !1, this._trackMarker(t, {
                action: "remove",
                value: t._timer.stop()
            }));
        },
        trackMarkerDrag: function(t, e) {
            t._timer._timer && this._trackMarker(t, {
                action: "drag",
                value: t._timer._timer.stop(),
                position: e
            });
        }
    }, r.track.Popup = function() {}, r.track.Popup.mixin = function(t) {
        r.utils.extend(r.track.Popup.prototype, t);
    }, r.track.Popup.prototype = {
        constructor: function() {},
        _popups: null,
        _trackPopup: function(t, e) {
            this._standalone || this.track({
                category: "popup",
                action: e.action,
                value: e.value,
                href: e.href,
                id: t.getId(),
                position: t.getPosition(),
                marker: t.hasMarker(),
                icon: t.getMarkerIcon(),
                internal: !0
            });
        },
        getPopups: function() {
            return this._popups;
        },
        getActivePopups: function() {
            for (var t = [], e = 0; e < this._popups.length; e++) this._popups[e].maptiks._active && t.push(this._popups[e]);
            return t;
        },
        getInactivePopups: function() {
            for (var t = [], e = 0; e < this._popups.length; e++) this._popups[e].maptiks._active || t.push(this._popups[e]);
            return t;
        },
        trackPopupAdd: function(t) {
            t._active = !0, t = r.utils.createTimer(t), r.utils.pushUnique(this._popups, t._popup), 
            this._trackPopup(t, {
                action: "add"
            });
        },
        trackPopupRemove: function(t) {
            t._timer && (t._active = !1, this._trackPopup(t, {
                action: "remove",
                value: t._timer.stop()
            }));
        },
        trackPopupNavigate: function(t, e) {
            t._timer && (this._trackPopup(t, {
                action: "navigate",
                value: t._timer.stop(),
                href: e
            }), t = r.utils.createTimer(t));
        }
    }, r.track = r.track || {}, r.track.Source = function() {}, r.track.Source.mixin = function(t) {
        r.utils.extend(r.track.Source.prototype, t);
    }, r.track.Source.prototype = {
        constructor: function() {},
        _sources: null,
        getSources: function() {
            return this._sources;
        },
        getActiveSources: function() {
            for (var t = [], e = 0; e < this._sources.length; e++) this._sources[e].maptiks.isActive() && t.push(this._sources[e]);
            return t;
        },
        getInactiveSources: function() {
            for (var t = [], e = 0; e < this._sources.length; e++) this._sources[e].maptiks.isActive() || t.push(this._sources[e]);
            return t;
        }
    }, r.layer = r.layer || {}, r.layer.Base = function() {}, r.layer.Base.mixin = function(t) {
        r.utils.extend(r.layer.Base.prototype, t);
    }, r.layer.Base.prototype = {
        constructor: function() {},
        _layer: null,
        _map: null,
        _id: null,
        _session: null,
        _url: null,
        getId: function() {
            return this._id;
        },
        getLayer: function() {
            return this._layer;
        },
        getMap: function() {
            return this._map;
        },
        getSession: function() {
            return this._session;
        },
        getUrl: function() {
            return this._url;
        },
        isActive: function() {
            return this._session ? !0 : !1;
        }
    }, r.marker = r.marker || {}, r.marker.Base = function() {}, r.marker.Base.mixin = function(t) {
        r.utils.extend(r.marker.Base.prototype, t);
    }, r.marker.Base.prototype = {
        constructor: function() {},
        _active: null,
        _clickable: null,
        _draggable: null,
        _icon: null,
        _id: null,
        _map: null,
        _marker: null,
        _popup: null,
        _position: null,
        getIcon: function() {
            return this._icon;
        },
        getId: function() {
            return this._id;
        },
        getMap: function() {
            return this._map;
        },
        getMarker: function() {
            return this._marker;
        },
        getPopup: function() {
            return this._popup;
        },
        getPosition: function() {
            return this._position;
        },
        hasPopup: function() {
            return this._popup ? !0 : !1;
        },
        isActive: function() {
            return this._active;
        },
        isClickable: function() {
            return this._clickable;
        },
        isDraggable: function() {
            return this._draggable;
        },
        isPopupActive: function() {
            return this._popup && this._popup.maptiks ? this._popup.maptiks._active : !1;
        }
    }, r.popup = r.popup || {}, r.popup.Base = function() {}, r.popup.Base.mixin = function(t) {
        r.utils.extend(r.popup.Base.prototype, t);
    }, r.popup.Base.prototype = {
        constructor: function() {},
        _active: null,
        _content: null,
        _map: null,
        _id: null,
        _marker: null,
        _popup: null,
        _position: null,
        getContent: function() {
            return this._content;
        },
        getId: function() {
            return this._id;
        },
        getMap: function() {
            return this._map;
        },
        getMarker: function() {
            return this._marker;
        },
        getMarkerIcon: function() {
            return this._marker ? this._marker.maptiks._icon : null;
        },
        getPopup: function() {
            return this._popup;
        },
        getPosition: function() {
            return this._position;
        },
        hasMarker: function() {
            return this._marker ? !0 : !1;
        },
        isActive: function() {
            return this._active;
        }
    }, r.source = r.source || {}, r.source.Base = function() {}, r.source.Base.mixin = function(t) {
        r.utils.extend(r.source.Base.prototype, t);
    }, r.source.Base.prototype = {
        constructor: function() {},
        _layers: null,
        _map: null,
        _source: null,
        _url: null,
        getActiveLayers: function() {
            for (var t = [], e = 0; e < this._layers.length; e++) this._layers[e].maptiks._session && t.push(this._layers[e]);
            return t;
        },
        getInactiveLayers: function() {
            for (var t = [], e = 0; e < this._layers.length; e++) this._layers[e].maptiks._session || t.push(this._layers[e]);
            return t;
        },
        getLayers: function() {
            return this._layers;
        },
        getMap: function() {
            return this._map;
        },
        getSource: function() {
            return this._source;
        },
        getUrl: function() {
            return this._url;
        },
        isActive: function() {
            return this.getActiveLayers().length ? !0 : !1;
        }
    }, r.utils = {
        convertXYZtoLatLng: function(t, e, i, n) {
            var r, a, o, s = Math.pow(2, i), c = e + .5;
            return n && (c = s - c), r = (t + .5) / s * 360 - 180, a = Math.atan(Math.sinh(Math.PI * (1 - 2 * c / s))), 
            o = a * (180 / Math.PI), o > 90 || -90 > o ? void 0 : {
                lat: o,
                lng: r
            };
        },
        generateUUID: function() {
            var t, e, i = new Date().getTime();
            return t = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(t) {
                return e = (i + 16 * Math.random()) % 16 | 0, i = Math.floor(i / 16), ("x" == t ? e : 7 & e | 8).toString(16);
            });
        },
        generateXYZUrl: function(t) {
            var e = t.match(/^(?:(?:https?|ftp):\/\/)[a-z]\./), i = t.match(/\/([0-9]|1[0-9]|2[0-9])\/[-0-9]+\/[0-9]+/);
            return t = t.split(i[0]), t = t[0] + "/{z}/{x}/{y}" + t[1], e && (t = t.split(e[0]), 
            e = e[0].slice(0, -2), e += "{s}.", t = e + t[1]), t;
        },
        getBaseUrl: function(t) {
            var e = t.indexOf("?"), i = t.substring(0, -1 != e ? e : t.length).toLowerCase();
            return i = i.match(/\/\/(www\.)?(([^\/]*)(\/#\/)?([^#]+))/), i = i[2].replace(/(\/(index|default)\.[a-z]{3,4})?$|(\/)?$/, "");
        },
        inherits: function(t, e) {
            function i() {}
            i.prototype = e.prototype, t.superClass_ = e.prototype, t.prototype = new i(), t.prototype.constructor = t;
        },
        extend: function(t, e) {
            for (var i in t) t.hasOwnProperty(i) && "prototype" !== i && !e[i] && (e[i] = t[i]);
            return e;
        },
        onDOMReady: function(t, e) {
            document.addEventListener ? document.addEventListener("DOMContentLoaded", function() {
                for (var i = 0; i < e.length; i++) e[i].apply(t);
            }) : document.attachEvent && document.attachEvent("onreadystatechange", function() {
                for (var i = 0; i < e.length; i++) e[i].apply(t);
            });
        },
        pushUnique: function(t, e) {
            return -1 == t.indexOf(e) ? (t.push(e), !0) : !1;
        },
        createTimer: function(t) {
            return t._timer = t._timer || {}, t._timer.stop = function() {
                var e = new Date().getTime(), i = e - this._startTime;
                return delete t._timer, i;
            }, t._timer._startTime = new Date().getTime(), t;
        },
        template: function(t, e) {
            return t.replace(/\{ *([\w_]+) *\}/g, function(t, i) {
                var n = e[i];
                if (void 0 === n) throw new Error("No value provided for variable " + t);
                return "function" == typeof n && (n = n(e)), n;
            });
        },
        truncateCoordinate: function(t, e) {
            return (null === e || void 0 === e || 0 > e) && (e = 5), Number(t.toFixed(e));
        },
        warn: function(t) {
            return e ? e.warn(t) : void 0;
        }
    }, r.utils.warn("The following options will be depreciated in future versions.\nhttps://analytics.maptiks.com/#/help/\nsa_id    --> maptiks_id\ntrack_id --> maptiks.trackcode");
}(window, window.console, window.module, window.define), function(t, e) {
    "use strict";
    function i() {
        u._initialTimeout = 100, u._initialTime = new Date().getTime(), u.trackMapSession(), 
        u._zoom = u.getMapState().zoom, u._map.on("moveend", u.trackPanZoom, u), u._map.on("layeradd", function(t) {
            n(t);
        }), u._map.on("layerremove", function(t) {
            n(t);
        });
    }
    function n(t) {
        var e = t.layer || t.target;
        "layeradd" === t.type ? (e._tiles && e._url && r(e), e._icon && e._latlng && o(e), 
        e._content && e._latlng && c(e)) : "layerremove" === t.type && (e._tiles && e._url && u.trackLayerRemove(e ? e.maptiks : null), 
        e._content && e._latlng && u.trackPopupRemove(e ? e.maptiks : null));
    }
    function r(e) {
        var i, n, r = e.options ? e.options.id || null : null, o = e.options ? e.options.layers || null : null;
        e.maptiks = e.maptiks || {}, i = e.maptiks, t.layer.Base.mixin(i), i._map = u._map, 
        i._layer = e, i._url = r ? e._url.replace("{id}", r) : o ? e._url + "?layers=" + o : e._url, 
        n = e.options.maptiks_id || e.options.sa_id || i._url, i._id = n, u.trackLayerAdd(i), 
        e.on("loading", function() {
            i = t.utils.createTimer(i);
        }), e.on("load", function() {
            u.trackLayerLoad(i);
        }), e.on("tileloaderror", a, u);
    }
    function a(e) {
        var i, n, r, a, o = e.target, s = e.tile, c = (o.options.tileSize || 256) / 2, p = t.utils.truncateCoordinate;
        o = o.maptiks, i = parseInt(s.style.left.replace("px", ""), 10) + c, n = parseInt(s.style.top.replace("px", ""), 10) + c, 
        r = u._map.containerPointToLayerPoint([ n, i ]), a = u._map.layerPointToLatLng([ r.y, r.x ]), 
        u.trackTileError(o, [ p(a.lng), p(a.lat) ], s.src);
    }
    function o(e) {
        var i, n = t.utils.truncateCoordinate;
        e.maptiks = e.maptiks || {}, i = e.maptiks, t.marker.Base.mixin(i), i._map = u._map, 
        i._marker = e, i._position = [ n(e.getLatLng().lng), n(e.getLatLng().lat) ] || null, 
        i._icon = e._icon ? e._icon.src : null, i._clickable = e.options.clickable || !0, 
        i._draggable = e.options.draggable || !1, i._id = e.options.maptiks_id || i._icon || i._position || null, 
        setTimeout(function() {
            i._popup = e._popup || null;
        }, 0), u.trackMarkerAdd(i), e.on("move", function() {
            s(i);
        }), e.on("click", function() {
            s(i), u.trackMarkerClick(i);
        }), e.on("remove", function() {
            s(i), u.trackMarkerRemove(i);
        }), e.on("dragstart", function() {
            s(i);
            var n = i._position;
            i._timer = t.utils.createTimer(i._timer), e.once("dragend", function() {
                s(i), u.trackMarkerDrag(i, n);
            });
        });
    }
    function s(e) {
        var i = t.utils.truncateCoordinate;
        e._position = [ i(e._marker.getLatLng().lng), i(e._marker.getLatLng().lat) ], e._icon = e._marker._icon ? e._marker._icon.src : null;
    }
    function c(e) {
        var i, n = t.utils.truncateCoordinate;
        e.maptiks = e.maptiks || {}, i = e.maptiks, t.popup.Base.mixin(i), i._content = e.getContent ? e.getContent() : e._content, 
        i._map = u._map, i._popup = e, i._marker = e._source || null, i._position = [ n(e.getLatLng ? e.getLatLng().lng : e._latlng.lng), n(e.getLatLng ? e.getLatLng().lat : e._latlng.lat) ], 
        i._id = e.options.maptiks_id || i.getMarkerIcon() || i._position, i._marker && (i._marker.maptiks._popup = e), 
        u.trackPopupAdd(i), window.addEventListener ? i._popup._contentNode.addEventListener("click", function r() {
            document.activeElement.href && (i._popup._contentNode.removeEventListener("click", r), 
            u.trackPopupNavigate(i, document.activeElement.href));
        }) : window.attachEvent && i._popup._contentNode.attachEvent("onclick", function a() {
            document.activeElement.href && (i._popup._contentNode.detachEvent("onclick", a), 
            u.trackPopupNavigate(i, document.activeElement.href));
        });
    }
    var u;
    e.Map.addInitHook(function() {
        var e = t.trackcode || this.options.maptiks_trackcode || this.options.track_id || null;
        e && !this.options.maptiks_notrack && (this.maptiks = new t.track.Base({
            id: this.options.maptiks_id || this.options.sa_id || t.utils.getBaseUrl(window.location.href) + "?mapDiv=" + this._container.id,
            library: "leaflet",
            map: this,
            session: t.utils.generateUUID(),
            trackcode: e,
            debug: t.debug || this.options.maptiks_debug,
            standalone: t.standalone || this.options.maptiks_standalone,
            getMapState: l
        }), u = this.maptiks, t.track.Map.mixin(u), t.track.Layer.mixin(u), u._layers = [], 
        t.track.Marker.mixin(u), u._markers = [], t.track.Popup.mixin(u), u._popups = []), 
        u && (void 0 === this.getZoom() ? this.once("load", i, u) : i());
    });
    var p = e.TileLayer.prototype._tileOnError;
    e.TileLayer.prototype._tileOnError = function() {
        var t = this._layer || this, e = arguments[1] || this;
        t.fire("tileloaderror", {
            tile: e
        }), p.apply(this, arguments);
    }, t.utils.inherits(e.TileLayer.prototype._tileOnError, p);
    var l = function() {
        var e = this._map.getCenter(), i = this._map.getBounds(), n = i.getNorthEast(), r = i.getSouthWest(), a = t.utils.truncateCoordinate;
        return {
            bbox: [ a(r.lng), a(r.lat), a(n.lng), a(n.lat) ],
            center: [ a(e.lng), a(e.lat) ],
            zoom: this._map.getZoom()
        };
    };
}(window.maptiks, window.L);

// Development environment Maptiks tracking
maptiks.trackcode = "2341082f-ed99-41ea-b498-886cabbd5b96";

(function(exports) {
    /*
 * tile.stamen.js v1.3.0
 */
    var SUBDOMAINS = "a. b. c. d.".split(" "), MAKE_PROVIDER = function(layer, type, minZoom, maxZoom) {
        return {
            url: [ "http://{S}tile.stamen.com/", layer, "/{Z}/{X}/{Y}.", type ].join(""),
            type: type,
            subdomains: SUBDOMAINS.slice(),
            minZoom: minZoom,
            maxZoom: maxZoom,
            attribution: [ 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, ', 'under <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. ', 'Data by <a href="http://openstreetmap.org">OpenStreetMap</a>, ', 'under <a href="http://creativecommons.org/licenses/by-sa/3.0">CC BY SA</a>.' ].join("")
        };
    }, PROVIDERS = {
        toner: MAKE_PROVIDER("toner", "png", 0, 20),
        terrain: MAKE_PROVIDER("terrain", "jpg", 4, 18),
        watercolor: MAKE_PROVIDER("watercolor", "jpg", 1, 18),
        "trees-cabs-crime": {
            url: "http://{S}.tiles.mapbox.com/v3/stamen.trees-cabs-crime/{Z}/{X}/{Y}.png",
            type: "png",
            subdomains: "a b c d".split(" "),
            minZoom: 11,
            maxZoom: 18,
            extent: [ {
                lat: 37.853,
                lon: -122.577
            }, {
                lat: 37.684,
                lon: -122.313
            } ],
            attribution: [ 'Design by Shawn Allen at <a href="http://stamen.com">Stamen</a>.', 'Data courtesy of <a href="http://fuf.net">FuF</a>,', '<a href="http://www.yellowcabsf.com">Yellow Cab</a>', '&amp; <a href="http://sf-police.org">SFPD</a>.' ].join(" ")
        }
    };
    // set up toner and terrain flavors
    setupFlavors("toner", [ "hybrid", "labels", "lines", "background", "lite" ]);
    // toner 2010
    setupFlavors("toner", [ "2010" ]);
    // toner 2011 flavors
    setupFlavors("toner", [ "2011", "2011-lines", "2011-labels", "2011-lite" ]);
    setupFlavors("terrain", [ "background" ]);
    setupFlavors("terrain", [ "labels", "lines" ], "png");
    /*
 * Export stamen.tile to the provided namespace.
 */
    exports.stamen = exports.stamen || {};
    exports.stamen.tile = exports.stamen.tile || {};
    exports.stamen.tile.providers = PROVIDERS;
    exports.stamen.tile.getProvider = getProvider;
    /*
 * A shortcut for specifying "flavors" of a style, which are assumed to have the
 * same type and zoom range.
 */
    function setupFlavors(base, flavors, type) {
        var provider = getProvider(base);
        for (var i = 0; i < flavors.length; i++) {
            var flavor = [ base, flavors[i] ].join("-");
            PROVIDERS[flavor] = MAKE_PROVIDER(flavor, type || provider.type, provider.minZoom, provider.maxZoom);
        }
    }
    /*
 * Get the named provider, or throw an exception if it doesn't exist.
 */
    function getProvider(name) {
        if (name in PROVIDERS) {
            return PROVIDERS[name];
        } else {
            throw "No such provider (" + name + ")";
        }
    }
    /*
 * StamenTileLayer for modestmaps-js
 * <https://github.com/modestmaps/modestmaps-js/>
 *
 * Works with both 1.x and 2.x by checking for the existence of MM.Template.
 */
    if (typeof MM === "object") {
        var ModestTemplate = typeof MM.Template === "function" ? MM.Template : MM.TemplatedMapProvider;
        MM.StamenTileLayer = function(name) {
            var provider = getProvider(name);
            this._provider = provider;
            MM.Layer.call(this, new ModestTemplate(provider.url, provider.subdomains));
            this.provider.setZoomRange(provider.minZoom, provider.maxZoom);
            this.attribution = provider.attribution;
        };
        MM.StamenTileLayer.prototype = {
            setCoordLimits: function(map) {
                var provider = this._provider;
                if (provider.extent) {
                    map.coordLimits = [ map.locationCoordinate(provider.extent[0]).zoomTo(provider.minZoom), map.locationCoordinate(provider.extent[1]).zoomTo(provider.maxZoom) ];
                    return true;
                } else {
                    return false;
                }
            }
        };
        MM.extend(MM.StamenTileLayer, MM.Layer);
    }
    /*
 * StamenTileLayer for Leaflet
 * <http://leaflet.cloudmade.com/>
 *
 * Tested with version 0.3 and 0.4, but should work on all 0.x releases.
 */
    if (typeof L === "object") {
        L.StamenTileLayer = L.TileLayer.extend({
            initialize: function(name, options) {
                var provider = getProvider(name), url = provider.url.replace(/({[A-Z]})/g, function(s) {
                    return s.toLowerCase();
                }), opts = L.extend({}, options, {
                    minZoom: provider.minZoom,
                    maxZoom: provider.maxZoom,
                    subdomains: provider.subdomains,
                    scheme: "xyz",
                    attribution: provider.attribution
                });
                L.TileLayer.prototype.initialize.call(this, url, opts);
            }
        });
        /*
     * Factory function for consistency with Leaflet conventions 
     */
        L.stamenTileLayer = function(options, source) {
            return new L.StamenTileLayer(options, source);
        };
    }
    /*
 * StamenTileLayer for OpenLayers
 * <http://openlayers.org/>
 *
 * Tested with v2.1x.
 */
    if (typeof OpenLayers === "object") {
        // make a tile URL template OpenLayers-compatible
        function openlayerize(url) {
            return url.replace(/({.})/g, function(v) {
                return "$" + v.toLowerCase();
            });
        }
        // based on http://www.bostongis.com/PrinterFriendly.aspx?content_name=using_custom_osm_tiles
        OpenLayers.Layer.Stamen = OpenLayers.Class(OpenLayers.Layer.OSM, {
            initialize: function(name, options) {
                var provider = getProvider(name), url = provider.url, subdomains = provider.subdomains, hosts = [];
                if (url.indexOf("{S}") > -1) {
                    for (var i = 0; i < subdomains.length; i++) {
                        hosts.push(openlayerize(url.replace("{S}", subdomains[i])));
                    }
                } else {
                    hosts.push(openlayerize(url));
                }
                options = OpenLayers.Util.extend({
                    numZoomLevels: provider.maxZoom,
                    buffer: 0,
                    transitionEffect: "resize",
                    // see: <http://dev.openlayers.org/apidocs/files/OpenLayers/Layer/OSM-js.html#OpenLayers.Layer.OSM.tileOptions>
                    // and: <http://dev.openlayers.org/apidocs/files/OpenLayers/Tile/Image-js.html#OpenLayers.Tile.Image.crossOriginKeyword>
                    tileOptions: {
                        crossOriginKeyword: null
                    },
                    attribution: ATTRIBUTION
                }, options);
                return OpenLayers.Layer.OSM.prototype.initialize.call(this, name, hosts, options);
            }
        });
    }
    /*
 * StamenMapType for Google Maps API V3
 * <https://developers.google.com/maps/documentation/javascript/>
 */
    if (typeof google === "object" && typeof google.maps === "object") {
        google.maps.StamenMapType = function(name) {
            var provider = getProvider(name), subdomains = provider.subdomains;
            return google.maps.ImageMapType.call(this, {
                getTileUrl: function(coord, zoom) {
                    var numTiles = 1 << zoom, wx = coord.x % numTiles, x = wx < 0 ? wx + numTiles : wx, y = coord.y, index = (zoom + x + y) % subdomains.length;
                    return provider.url.replace("{S}", subdomains[index]).replace("{Z}", zoom).replace("{X}", x).replace("{Y}", y);
                },
                tileSize: new google.maps.Size(256, 256),
                name: name,
                minZoom: provider.minZoom,
                maxZoom: provider.maxZoom
            });
        };
        // FIXME: is there a better way to extend classes in Google land?
        google.maps.StamenMapType.prototype = new google.maps.ImageMapType("_");
    }
})(typeof exports === "undefined" ? this : exports);

/*!
Copyright (c) 2014 Dominik Moritz

This file is part of the leaflet locate control. It is licensed under the MIT license.
You can find the project at: https://github.com/domoritz/leaflet-locatecontrol
*/
(function(factory, window) {
    // see https://github.com/Leaflet/Leaflet/blob/master/PLUGIN-GUIDE.md#module-loaders
    // for details on how to structure a leaflet plugin.
    // define an AMD module that relies on 'leaflet'
    if (typeof define === "function" && define.amd) {
        define([ "leaflet" ], factory);
    } else if (typeof exports === "object") {
        if (typeof window !== "undefined" && window.L) {
            module.exports = factory(L);
        } else {
            module.exports = factory(require("leaflet"));
        }
    }
    // attach your plugin to the global 'L' variable
    if (typeof window !== "undefined" && window.L) {
        window.L.Locate = factory(L);
    }
})(function(L) {
    L.Control.Locate = L.Control.extend({
        options: {
            position: "topleft",
            drawCircle: true,
            follow: false,
            // follow with zoom and pan the user's location
            stopFollowingOnDrag: false,
            // if follow is true, stop following when map is dragged (deprecated)
            // if true locate control remains active on click even if the user's location is in view.
            // clicking control will just pan to location
            remainActive: false,
            markerClass: L.circleMarker,
            // L.circleMarker or L.marker
            // range circle
            circleStyle: {
                color: "#136AEC",
                fillColor: "#136AEC",
                fillOpacity: .15,
                weight: 2,
                opacity: .5
            },
            // inner marker
            markerStyle: {
                color: "#136AEC",
                fillColor: "#2A93EE",
                fillOpacity: .7,
                weight: 2,
                opacity: .9,
                radius: 5
            },
            // changes to range circle and inner marker while following
            // it is only necessary to provide the things that should change
            followCircleStyle: {},
            followMarkerStyle: {},
            icon: "fa fa-map-marker",
            // fa-location-arrow or fa-map-marker
            iconLoading: "fa fa-spinner fa-spin",
            circlePadding: [ 0, 0 ],
            metric: true,
            onLocationError: function(err) {
                // this event is called in case of any location error
                // that is not a time out error.
                alert(err.message);
            },
            onLocationOutsideMapBounds: function(control) {
                // this event is repeatedly called when the location changes
                control.stop();
                alert(control.options.strings.outsideMapBoundsMsg);
            },
            setView: true,
            // automatically sets the map view to the user's location
            // keep the current map zoom level when displaying the user's location. (if 'false', use maxZoom)
            keepCurrentZoomLevel: false,
            showPopup: true,
            // display a popup when the user click on the inner marker
            strings: {
                title: "Show me where I am",
                popup: "You are within {distance} {unit} from this point",
                outsideMapBoundsMsg: "You seem located outside the boundaries of the map"
            },
            locateOptions: {
                maxZoom: Infinity,
                watch: true
            }
        },
        initialize: function(options) {
            L.Map.addInitHook(function() {
                if (this.options.locateControl) {
                    this.locateControl = L.control.locate();
                    this.addControl(this.locateControl);
                }
            });
            for (var i in options) {
                if (typeof this.options[i] === "object") {
                    L.extend(this.options[i], options[i]);
                } else {
                    this.options[i] = options[i];
                }
            }
            L.extend(this.options.locateOptions, {
                setView: false
            });
        },
        /**
         * This method launches the location engine.
         * It is called before the marker is updated,
         * event if it does not mean that the event will be ready.
         *
         * Override it if you want to add more functionalities.
         * It should set the this._active to true and do nothing if
         * this._active is not true.
         */
        _activate: function() {
            if (this.options.setView) {
                this._locateOnNextLocationFound = true;
            }
            if (!this._active) {
                this._map.locate(this.options.locateOptions);
            }
            this._active = true;
            if (this.options.follow) {
                this._startFollowing(this._map);
            }
        },
        /**
         * Called to stop the location engine.
         *
         * Override it to shutdown any functionalities you added on start.
         */
        _deactivate: function() {
            this._map.stopLocate();
            this._map.off("dragstart", this._stopFollowing);
            if (this.options.follow && this._following) {
                this._stopFollowing(this._map);
            }
        },
        /**
         * Draw the resulting marker on the map.
         *
         * Uses the event retrieved from onLocationFound from the map.
         */
        drawMarker: function(map) {
            if (this._event.accuracy === undefined) {
                this._event.accuracy = 0;
            }
            var radius = this._event.accuracy;
            if (this._locateOnNextLocationFound) {
                if (this._isOutsideMapBounds()) {
                    this.options.onLocationOutsideMapBounds(this);
                } else {
                    // If accuracy info isn't desired, keep the current zoom level
                    if (this.options.keepCurrentZoomLevel && !this.options.drawCircle) {
                        map.panTo([ this._event.latitude, this._event.longitude ]);
                    } else {
                        map.fitBounds(this._event.bounds, {
                            padding: this.options.circlePadding,
                            maxZoom: this.options.keepCurrentZoomLevel ? map.getZoom() : this.options.locateOptions.maxZoom
                        });
                    }
                }
                this._locateOnNextLocationFound = false;
            }
            // circle with the radius of the location's accuracy
            var style, o;
            if (this.options.drawCircle) {
                if (this._following) {
                    style = this.options.followCircleStyle;
                } else {
                    style = this.options.circleStyle;
                }
                if (!this._circle) {
                    this._circle = L.circle(this._event.latlng, radius, style).addTo(this._layer);
                } else {
                    this._circle.setLatLng(this._event.latlng).setRadius(radius);
                    for (o in style) {
                        this._circle.options[o] = style[o];
                    }
                }
            }
            var distance, unit;
            if (this.options.metric) {
                distance = radius.toFixed(0);
                unit = "meters";
            } else {
                distance = (radius * 3.2808399).toFixed(0);
                unit = "feet";
            }
            // small inner marker
            var mStyle;
            if (this._following) {
                mStyle = this.options.followMarkerStyle;
            } else {
                mStyle = this.options.markerStyle;
            }
            if (!this._marker) {
                this._marker = this.createMarker(this._event.latlng, mStyle).addTo(this._layer);
            } else {
                this.updateMarker(this._event.latlng, mStyle);
            }
            var t = this.options.strings.popup;
            if (this.options.showPopup && t) {
                this._marker.bindPopup(L.Util.template(t, {
                    distance: distance,
                    unit: unit
                }))._popup.setLatLng(this._event.latlng);
            }
            this._toggleContainerStyle();
        },
        /**
         * Creates the marker.
         *
         * Should return the base marker so it is possible to bind a pop-up if the
         * option is activated.
         *
         * Used by drawMarker, you can ignore it if you have overridden it.
         */
        createMarker: function(latlng, mStyle) {
            return this.options.markerClass(latlng, mStyle);
        },
        /**
         * Updates the marker with current coordinates.
         *
         * Used by drawMarker, you can ignore it if you have overridden it.
         */
        updateMarker: function(latlng, mStyle) {
            this._marker.setLatLng(latlng);
            for (var o in mStyle) {
                this._marker.options[o] = mStyle[o];
            }
        },
        /**
         * Remove the marker from map.
         */
        removeMarker: function() {
            this._layer.clearLayers();
            this._marker = undefined;
            this._circle = undefined;
        },
        onAdd: function(map) {
            var container = L.DomUtil.create("div", "leaflet-control-locate leaflet-bar leaflet-control");
            this._layer = new L.LayerGroup();
            this._layer.addTo(map);
            this._event = undefined;
            // extend the follow marker style and circle from the normal style
            var tmp = {};
            L.extend(tmp, this.options.markerStyle, this.options.followMarkerStyle);
            this.options.followMarkerStyle = tmp;
            tmp = {};
            L.extend(tmp, this.options.circleStyle, this.options.followCircleStyle);
            this.options.followCircleStyle = tmp;
            this._link = L.DomUtil.create("a", "leaflet-bar-part leaflet-bar-part-single", container);
            this._link.href = "#";
            this._link.title = this.options.strings.title;
            this._icon = L.DomUtil.create("span", this.options.icon, this._link);
            L.DomEvent.on(this._link, "click", L.DomEvent.stopPropagation).on(this._link, "click", L.DomEvent.preventDefault).on(this._link, "click", function() {
                var shouldStop = this._event === undefined || this._map.getBounds().contains(this._event.latlng) || !this.options.setView || this._isOutsideMapBounds();
                if (!this.options.remainActive && (this._active && shouldStop)) {
                    this.stop();
                } else {
                    this.start();
                }
            }, this).on(this._link, "dblclick", L.DomEvent.stopPropagation);
            this._resetVariables();
            this.bindEvents(map);
            return container;
        },
        /**
         * Binds the actions to the map events.
         */
        bindEvents: function(map) {
            map.on("locationfound", this._onLocationFound, this);
            map.on("locationerror", this._onLocationError, this);
            map.on("unload", this.stop, this);
        },
        /**
         * Starts the plugin:
         * - activates the engine
         * - draws the marker (if coordinates available)
         */
        start: function() {
            this._activate();
            if (!this._event) {
                this._setClasses("requesting");
            } else {
                this.drawMarker(this._map);
            }
        },
        /**
         * Stops the plugin:
         * - deactivates the engine
         * - reinitializes the button
         * - removes the marker
         */
        stop: function() {
            this._deactivate();
            this._cleanClasses();
            this._resetVariables();
            this.removeMarker();
        },
        /**
         * Calls deactivate and dispatches an error.
         */
        _onLocationError: function(err) {
            // ignore time out error if the location is watched
            if (err.code == 3 && this.options.locateOptions.watch) {
                return;
            }
            this.stop();
            this.options.onLocationError(err);
        },
        /**
         * Stores the received event and updates the marker.
         */
        _onLocationFound: function(e) {
            // no need to do anything if the location has not changed
            if (this._event && (this._event.latlng.lat === e.latlng.lat && this._event.latlng.lng === e.latlng.lng && this._event.accuracy === e.accuracy)) {
                return;
            }
            if (!this._active) {
                return;
            }
            this._event = e;
            if (this.options.follow && this._following) {
                this._locateOnNextLocationFound = true;
            }
            this.drawMarker(this._map);
        },
        /**
         * Dispatches the 'startfollowing' event on map.
         */
        _startFollowing: function() {
            this._map.fire("startfollowing", this);
            this._following = true;
            if (this.options.stopFollowingOnDrag) {
                this._map.on("dragstart", this._stopFollowing, this);
            }
        },
        /**
         * Dispatches the 'stopfollowing' event on map.
         */
        _stopFollowing: function() {
            this._map.fire("stopfollowing", this);
            this._following = false;
            if (this.options.stopFollowingOnDrag) {
                this._map.off("dragstart", this._stopFollowing);
            }
            this._toggleContainerStyle();
        },
        /**
         * Check if location is in map bounds
         */
        _isOutsideMapBounds: function() {
            if (this._event === undefined) return false;
            return this._map.options.maxBounds && !this._map.options.maxBounds.contains(this._event.latlng);
        },
        /**
         * Toggles button class between following and active.
         */
        _toggleContainerStyle: function() {
            if (!this._container) {
                return;
            }
            if (this._following) {
                this._setClasses("following");
            } else {
                this._setClasses("active");
            }
        },
        /**
         * Sets the CSS classes for the state.
         */
        _setClasses: function(state) {
            if (state == "requesting") {
                L.DomUtil.removeClasses(this._container, "active following");
                L.DomUtil.addClasses(this._container, "requesting");
                L.DomUtil.removeClasses(this._icon, this.options.icon);
                L.DomUtil.addClasses(this._icon, this.options.iconLoading);
            } else if (state == "active") {
                L.DomUtil.removeClasses(this._container, "requesting following");
                L.DomUtil.addClasses(this._container, "active");
                L.DomUtil.removeClasses(this._icon, this.options.iconLoading);
                L.DomUtil.addClasses(this._icon, this.options.icon);
            } else if (state == "following") {
                L.DomUtil.removeClasses(this._container, "requesting");
                L.DomUtil.addClasses(this._container, "active following");
                L.DomUtil.removeClasses(this._icon, this.options.iconLoading);
                L.DomUtil.addClasses(this._icon, this.options.icon);
            }
        },
        /**
         * Removes all classes from button.
         */
        _cleanClasses: function() {
            L.DomUtil.removeClass(this._container, "requesting");
            L.DomUtil.removeClass(this._container, "active");
            L.DomUtil.removeClass(this._container, "following");
            L.DomUtil.removeClasses(this._icon, this.options.iconLoading);
            L.DomUtil.addClasses(this._icon, this.options.icon);
        },
        /**
         * Reinitializes attributes.
         */
        _resetVariables: function() {
            this._active = false;
            this._locateOnNextLocationFound = this.options.setView;
            this._following = false;
        }
    });
    L.Map.addInitHook(function() {
        if (this.options.locateControl) {
            this.locateControl = L.control.locate();
            this.addControl(this.locateControl);
        }
    });
    L.control.locate = function(options) {
        return new L.Control.Locate(options);
    };
    (function() {
        // leaflet.js raises bug when trying to addClass / removeClass multiple classes at once
        // Let's create a wrapper on it which fixes it.
        var LDomUtilApplyClassesMethod = function(method, element, classNames) {
            classNames = classNames.split(" ");
            classNames.forEach(function(className) {
                L.DomUtil[method].call(this, element, className);
            });
        };
        L.DomUtil.addClasses = function(el, names) {
            LDomUtilApplyClassesMethod("addClass", el, names);
        };
        L.DomUtil.removeClasses = function(el, names) {
            LDomUtilApplyClassesMethod("removeClass", el, names);
        };
    })();
    return L.Control.Locate;
}, window);

/*
 Leaflet.markercluster, Provides Beautiful Animated Marker Clustering functionality for Leaflet, a JS library for interactive maps.
 https://github.com/Leaflet/Leaflet.markercluster
 (c) 2012-2013, Dave Leaver, smartrak
*/
!function(t, e) {
    L.MarkerClusterGroup = L.FeatureGroup.extend({
        options: {
            maxClusterRadius: 80,
            iconCreateFunction: null,
            spiderfyOnMaxZoom: !0,
            showCoverageOnHover: !0,
            zoomToBoundsOnClick: !0,
            singleMarkerMode: !1,
            disableClusteringAtZoom: null,
            removeOutsideVisibleBounds: !0,
            animateAddingMarkers: !1,
            spiderfyDistanceMultiplier: 1,
            polygonOptions: {}
        },
        initialize: function(t) {
            L.Util.setOptions(this, t), this.options.iconCreateFunction || (this.options.iconCreateFunction = this._defaultIconCreateFunction), 
            this._featureGroup = L.featureGroup(), this._featureGroup.on(L.FeatureGroup.EVENTS, this._propagateEvent, this), 
            this._nonPointGroup = L.featureGroup(), this._nonPointGroup.on(L.FeatureGroup.EVENTS, this._propagateEvent, this), 
            this._inZoomAnimation = 0, this._needsClustering = [], this._needsRemoving = [], 
            this._currentShownBounds = null, this._queue = [];
        },
        addLayer: function(t) {
            if (t instanceof L.LayerGroup) {
                var e = [];
                for (var i in t._layers) e.push(t._layers[i]);
                return this.addLayers(e);
            }
            if (!t.getLatLng) return this._nonPointGroup.addLayer(t), this;
            if (!this._map) return this._needsClustering.push(t), this;
            if (this.hasLayer(t)) return this;
            this._unspiderfy && this._unspiderfy(), this._addLayer(t, this._maxZoom);
            var n = t, s = this._map.getZoom();
            if (t.__parent) for (;n.__parent._zoom >= s; ) n = n.__parent;
            return this._currentShownBounds.contains(n.getLatLng()) && (this.options.animateAddingMarkers ? this._animationAddLayer(t, n) : this._animationAddLayerNonAnimated(t, n)), 
            this;
        },
        removeLayer: function(t) {
            if (t instanceof L.LayerGroup) {
                var e = [];
                for (var i in t._layers) e.push(t._layers[i]);
                return this.removeLayers(e);
            }
            return t.getLatLng ? this._map ? t.__parent ? (this._unspiderfy && (this._unspiderfy(), 
            this._unspiderfyLayer(t)), this._removeLayer(t, !0), this._featureGroup.hasLayer(t) && (this._featureGroup.removeLayer(t), 
            t.setOpacity && t.setOpacity(1)), this) : this : (!this._arraySplice(this._needsClustering, t) && this.hasLayer(t) && this._needsRemoving.push(t), 
            this) : (this._nonPointGroup.removeLayer(t), this);
        },
        addLayers: function(t) {
            var e, i, n, s = this._map, r = this._featureGroup, o = this._nonPointGroup;
            for (e = 0, i = t.length; i > e; e++) if (n = t[e], n.getLatLng) {
                if (!this.hasLayer(n)) if (s) {
                    if (this._addLayer(n, this._maxZoom), n.__parent && 2 === n.__parent.getChildCount()) {
                        var a = n.__parent.getAllChildMarkers(), h = a[0] === n ? a[1] : a[0];
                        r.removeLayer(h);
                    }
                } else this._needsClustering.push(n);
            } else o.addLayer(n);
            return s && (r.eachLayer(function(t) {
                t instanceof L.MarkerCluster && t._iconNeedsUpdate && t._updateIcon();
            }), this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds)), 
            this;
        },
        removeLayers: function(t) {
            var e, i, n, s = this._featureGroup, r = this._nonPointGroup;
            if (!this._map) {
                for (e = 0, i = t.length; i > e; e++) n = t[e], this._arraySplice(this._needsClustering, n), 
                r.removeLayer(n);
                return this;
            }
            for (e = 0, i = t.length; i > e; e++) n = t[e], n.__parent ? (this._removeLayer(n, !0, !0), 
            s.hasLayer(n) && (s.removeLayer(n), n.setOpacity && n.setOpacity(1))) : r.removeLayer(n);
            return this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds), 
            s.eachLayer(function(t) {
                t instanceof L.MarkerCluster && t._updateIcon();
            }), this;
        },
        clearLayers: function() {
            return this._map || (this._needsClustering = [], delete this._gridClusters, delete this._gridUnclustered), 
            this._noanimationUnspiderfy && this._noanimationUnspiderfy(), this._featureGroup.clearLayers(), 
            this._nonPointGroup.clearLayers(), this.eachLayer(function(t) {
                delete t.__parent;
            }), this._map && this._generateInitialClusters(), this;
        },
        getBounds: function() {
            var t = new L.LatLngBounds();
            if (this._topClusterLevel) t.extend(this._topClusterLevel._bounds); else for (var e = this._needsClustering.length - 1; e >= 0; e--) t.extend(this._needsClustering[e].getLatLng());
            return t.extend(this._nonPointGroup.getBounds()), t;
        },
        eachLayer: function(t, e) {
            var i, n = this._needsClustering.slice();
            for (this._topClusterLevel && this._topClusterLevel.getAllChildMarkers(n), i = n.length - 1; i >= 0; i--) t.call(e, n[i]);
            this._nonPointGroup.eachLayer(t, e);
        },
        getLayers: function() {
            var t = [];
            return this.eachLayer(function(e) {
                t.push(e);
            }), t;
        },
        getLayer: function(t) {
            var e = null;
            return this.eachLayer(function(i) {
                L.stamp(i) === t && (e = i);
            }), e;
        },
        hasLayer: function(t) {
            if (!t) return !1;
            var e, i = this._needsClustering;
            for (e = i.length - 1; e >= 0; e--) if (i[e] === t) return !0;
            for (i = this._needsRemoving, e = i.length - 1; e >= 0; e--) if (i[e] === t) return !1;
            return !(!t.__parent || t.__parent._group !== this) || this._nonPointGroup.hasLayer(t);
        },
        zoomToShowLayer: function(t, e) {
            var i = function() {
                if ((t._icon || t.__parent._icon) && !this._inZoomAnimation) if (this._map.off("moveend", i, this), 
                this.off("animationend", i, this), t._icon) e(); else if (t.__parent._icon) {
                    var n = function() {
                        this.off("spiderfied", n, this), e();
                    };
                    this.on("spiderfied", n, this), t.__parent.spiderfy();
                }
            };
            t._icon && this._map.getBounds().contains(t.getLatLng()) ? e() : t.__parent._zoom < this._map.getZoom() ? (this._map.on("moveend", i, this), 
            this._map.panTo(t.getLatLng())) : (this._map.on("moveend", i, this), this.on("animationend", i, this), 
            this._map.setView(t.getLatLng(), t.__parent._zoom + 1), t.__parent.zoomToBounds());
        },
        onAdd: function(t) {
            this._map = t;
            var e, i, n;
            if (!isFinite(this._map.getMaxZoom())) throw "Map has no maxZoom specified";
            for (this._featureGroup.onAdd(t), this._nonPointGroup.onAdd(t), this._gridClusters || this._generateInitialClusters(), 
            e = 0, i = this._needsRemoving.length; i > e; e++) n = this._needsRemoving[e], this._removeLayer(n, !0);
            for (this._needsRemoving = [], e = 0, i = this._needsClustering.length; i > e; e++) n = this._needsClustering[e], 
            n.getLatLng ? n.__parent || this._addLayer(n, this._maxZoom) : this._featureGroup.addLayer(n);
            this._needsClustering = [], this._map.on("zoomend", this._zoomEnd, this), this._map.on("moveend", this._moveEnd, this), 
            this._spiderfierOnAdd && this._spiderfierOnAdd(), this._bindEvents(), this._zoom = this._map.getZoom(), 
            this._currentShownBounds = this._getExpandedVisibleBounds(), this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);
        },
        onRemove: function(t) {
            t.off("zoomend", this._zoomEnd, this), t.off("moveend", this._moveEnd, this), this._unbindEvents(), 
            this._map._mapPane.className = this._map._mapPane.className.replace(" leaflet-cluster-anim", ""), 
            this._spiderfierOnRemove && this._spiderfierOnRemove(), this._hideCoverage(), this._featureGroup.onRemove(t), 
            this._nonPointGroup.onRemove(t), this._featureGroup.clearLayers(), this._map = null;
        },
        getVisibleParent: function(t) {
            for (var e = t; e && !e._icon; ) e = e.__parent;
            return e || null;
        },
        _arraySplice: function(t, e) {
            for (var i = t.length - 1; i >= 0; i--) if (t[i] === e) return t.splice(i, 1), !0;
        },
        _removeLayer: function(t, e, i) {
            var n = this._gridClusters, s = this._gridUnclustered, r = this._featureGroup, o = this._map;
            if (e) for (var a = this._maxZoom; a >= 0 && s[a].removeObject(t, o.project(t.getLatLng(), a)); a--) ;
            var h, _ = t.__parent, u = _._markers;
            for (this._arraySplice(u, t); _ && (_._childCount--, !(_._zoom < 0)); ) e && _._childCount <= 1 ? (h = _._markers[0] === t ? _._markers[1] : _._markers[0], 
            n[_._zoom].removeObject(_, o.project(_._cLatLng, _._zoom)), s[_._zoom].addObject(h, o.project(h.getLatLng(), _._zoom)), 
            this._arraySplice(_.__parent._childClusters, _), _.__parent._markers.push(h), h.__parent = _.__parent, 
            _._icon && (r.removeLayer(_), i || r.addLayer(h))) : (_._recalculateBounds(), i && _._icon || _._updateIcon()), 
            _ = _.__parent;
            delete t.__parent;
        },
        _isOrIsParent: function(t, e) {
            for (;e; ) {
                if (t === e) return !0;
                e = e.parentNode;
            }
            return !1;
        },
        _propagateEvent: function(t) {
            if (t.layer instanceof L.MarkerCluster) {
                if (t.originalEvent && this._isOrIsParent(t.layer._icon, t.originalEvent.relatedTarget)) return;
                t.type = "cluster" + t.type;
            }
            this.fire(t.type, t);
        },
        _defaultIconCreateFunction: function(t) {
            var e = t.getChildCount(), i = " marker-cluster-";
            return i += 10 > e ? "small" : 100 > e ? "medium" : "large", new L.DivIcon({
                html: "<div><span>" + e + "</span></div>",
                className: "marker-cluster" + i,
                iconSize: new L.Point(40, 40)
            });
        },
        _bindEvents: function() {
            var t = this._map, e = this.options.spiderfyOnMaxZoom, i = this.options.showCoverageOnHover, n = this.options.zoomToBoundsOnClick;
            (e || n) && this.on("clusterclick", this._zoomOrSpiderfy, this), i && (this.on("clustermouseover", this._showCoverage, this), 
            this.on("clustermouseout", this._hideCoverage, this), t.on("zoomend", this._hideCoverage, this));
        },
        _zoomOrSpiderfy: function(t) {
            var e = this._map;
            e.getMaxZoom() === e.getZoom() ? this.options.spiderfyOnMaxZoom && t.layer.spiderfy() : this.options.zoomToBoundsOnClick && t.layer.zoomToBounds(), 
            t.originalEvent && 13 === t.originalEvent.keyCode && e._container.focus();
        },
        _showCoverage: function(t) {
            var e = this._map;
            this._inZoomAnimation || (this._shownPolygon && e.removeLayer(this._shownPolygon), 
            t.layer.getChildCount() > 2 && t.layer !== this._spiderfied && (this._shownPolygon = new L.Polygon(t.layer.getConvexHull(), this.options.polygonOptions), 
            e.addLayer(this._shownPolygon)));
        },
        _hideCoverage: function() {
            this._shownPolygon && (this._map.removeLayer(this._shownPolygon), this._shownPolygon = null);
        },
        _unbindEvents: function() {
            var t = this.options.spiderfyOnMaxZoom, e = this.options.showCoverageOnHover, i = this.options.zoomToBoundsOnClick, n = this._map;
            (t || i) && this.off("clusterclick", this._zoomOrSpiderfy, this), e && (this.off("clustermouseover", this._showCoverage, this), 
            this.off("clustermouseout", this._hideCoverage, this), n.off("zoomend", this._hideCoverage, this));
        },
        _zoomEnd: function() {
            this._map && (this._mergeSplitClusters(), this._zoom = this._map._zoom, this._currentShownBounds = this._getExpandedVisibleBounds());
        },
        _moveEnd: function() {
            if (!this._inZoomAnimation) {
                var t = this._getExpandedVisibleBounds();
                this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, this._zoom, t), 
                this._topClusterLevel._recursivelyAddChildrenToMap(null, this._map._zoom, t), this._currentShownBounds = t;
            }
        },
        _generateInitialClusters: function() {
            var t = this._map.getMaxZoom(), e = this.options.maxClusterRadius;
            this.options.disableClusteringAtZoom && (t = this.options.disableClusteringAtZoom - 1), 
            this._maxZoom = t, this._gridClusters = {}, this._gridUnclustered = {};
            for (var i = t; i >= 0; i--) this._gridClusters[i] = new L.DistanceGrid(e), this._gridUnclustered[i] = new L.DistanceGrid(e);
            this._topClusterLevel = new L.MarkerCluster(this, -1);
        },
        _addLayer: function(t, e) {
            var i, n, s = this._gridClusters, r = this._gridUnclustered;
            for (this.options.singleMarkerMode && (t.options.icon = this.options.iconCreateFunction({
                getChildCount: function() {
                    return 1;
                },
                getAllChildMarkers: function() {
                    return [ t ];
                }
            })); e >= 0; e--) {
                i = this._map.project(t.getLatLng(), e);
                var o = s[e].getNearObject(i);
                if (o) return o._addChild(t), t.__parent = o, void 0;
                if (o = r[e].getNearObject(i)) {
                    var a = o.__parent;
                    a && this._removeLayer(o, !1);
                    var h = new L.MarkerCluster(this, e, o, t);
                    s[e].addObject(h, this._map.project(h._cLatLng, e)), o.__parent = h, t.__parent = h;
                    var _ = h;
                    for (n = e - 1; n > a._zoom; n--) _ = new L.MarkerCluster(this, n, _), s[n].addObject(_, this._map.project(o.getLatLng(), n));
                    for (a._addChild(_), n = e; n >= 0 && r[n].removeObject(o, this._map.project(o.getLatLng(), n)); n--) ;
                    return;
                }
                r[e].addObject(t, i);
            }
            this._topClusterLevel._addChild(t), t.__parent = this._topClusterLevel;
        },
        _enqueue: function(t) {
            this._queue.push(t), this._queueTimeout || (this._queueTimeout = setTimeout(L.bind(this._processQueue, this), 300));
        },
        _processQueue: function() {
            for (var t = 0; t < this._queue.length; t++) this._queue[t].call(this);
            this._queue.length = 0, clearTimeout(this._queueTimeout), this._queueTimeout = null;
        },
        _mergeSplitClusters: function() {
            this._processQueue(), this._zoom < this._map._zoom && this._currentShownBounds.contains(this._getExpandedVisibleBounds()) ? (this._animationStart(), 
            this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, this._zoom, this._getExpandedVisibleBounds()), 
            this._animationZoomIn(this._zoom, this._map._zoom)) : this._zoom > this._map._zoom ? (this._animationStart(), 
            this._animationZoomOut(this._zoom, this._map._zoom)) : this._moveEnd();
        },
        _getExpandedVisibleBounds: function() {
            if (!this.options.removeOutsideVisibleBounds) return this.getBounds();
            var t = this._map, e = t.getBounds(), i = e._southWest, n = e._northEast, s = L.Browser.mobile ? 0 : Math.abs(i.lat - n.lat), r = L.Browser.mobile ? 0 : Math.abs(i.lng - n.lng);
            return new L.LatLngBounds(new L.LatLng(i.lat - s, i.lng - r, !0), new L.LatLng(n.lat + s, n.lng + r, !0));
        },
        _animationAddLayerNonAnimated: function(t, e) {
            if (e === t) this._featureGroup.addLayer(t); else if (2 === e._childCount) {
                e._addToMap();
                var i = e.getAllChildMarkers();
                this._featureGroup.removeLayer(i[0]), this._featureGroup.removeLayer(i[1]);
            } else e._updateIcon();
        }
    }), L.MarkerClusterGroup.include(L.DomUtil.TRANSITION ? {
        _animationStart: function() {
            this._map._mapPane.className += " leaflet-cluster-anim", this._inZoomAnimation++;
        },
        _animationEnd: function() {
            this._map && (this._map._mapPane.className = this._map._mapPane.className.replace(" leaflet-cluster-anim", "")), 
            this._inZoomAnimation--, this.fire("animationend");
        },
        _animationZoomIn: function(t, e) {
            var i, n = this._getExpandedVisibleBounds(), s = this._featureGroup;
            this._topClusterLevel._recursively(n, t, 0, function(r) {
                var o, a = r._latlng, h = r._markers;
                for (n.contains(a) || (a = null), r._isSingleParent() && t + 1 === e ? (s.removeLayer(r), 
                r._recursivelyAddChildrenToMap(null, e, n)) : (r.setOpacity(0), r._recursivelyAddChildrenToMap(a, e, n)), 
                i = h.length - 1; i >= 0; i--) o = h[i], n.contains(o._latlng) || s.removeLayer(o);
            }), this._forceLayout(), this._topClusterLevel._recursivelyBecomeVisible(n, e), 
            s.eachLayer(function(t) {
                t instanceof L.MarkerCluster || !t._icon || t.setOpacity(1);
            }), this._topClusterLevel._recursively(n, t, e, function(t) {
                t._recursivelyRestoreChildPositions(e);
            }), this._enqueue(function() {
                this._topClusterLevel._recursively(n, t, 0, function(t) {
                    s.removeLayer(t), t.setOpacity(1);
                }), this._animationEnd();
            });
        },
        _animationZoomOut: function(t, e) {
            this._animationZoomOutSingle(this._topClusterLevel, t - 1, e), this._topClusterLevel._recursivelyAddChildrenToMap(null, e, this._getExpandedVisibleBounds()), 
            this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, t, this._getExpandedVisibleBounds());
        },
        _animationZoomOutSingle: function(t, e, i) {
            var n = this._getExpandedVisibleBounds();
            t._recursivelyAnimateChildrenInAndAddSelfToMap(n, e + 1, i);
            var s = this;
            this._forceLayout(), t._recursivelyBecomeVisible(n, i), this._enqueue(function() {
                if (1 === t._childCount) {
                    var r = t._markers[0];
                    r.setLatLng(r.getLatLng()), r.setOpacity(1);
                } else t._recursively(n, i, 0, function(t) {
                    t._recursivelyRemoveChildrenFromMap(n, e + 1);
                });
                s._animationEnd();
            });
        },
        _animationAddLayer: function(t, e) {
            var i = this, n = this._featureGroup;
            n.addLayer(t), e !== t && (e._childCount > 2 ? (e._updateIcon(), this._forceLayout(), 
            this._animationStart(), t._setPos(this._map.latLngToLayerPoint(e.getLatLng())), 
            t.setOpacity(0), this._enqueue(function() {
                n.removeLayer(t), t.setOpacity(1), i._animationEnd();
            })) : (this._forceLayout(), i._animationStart(), i._animationZoomOutSingle(e, this._map.getMaxZoom(), this._map.getZoom())));
        },
        _forceLayout: function() {
            L.Util.falseFn(e.body.offsetWidth);
        }
    } : {
        _animationStart: function() {},
        _animationZoomIn: function(t, e) {
            this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, t), 
            this._topClusterLevel._recursivelyAddChildrenToMap(null, e, this._getExpandedVisibleBounds());
        },
        _animationZoomOut: function(t, e) {
            this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, t), 
            this._topClusterLevel._recursivelyAddChildrenToMap(null, e, this._getExpandedVisibleBounds());
        },
        _animationAddLayer: function(t, e) {
            this._animationAddLayerNonAnimated(t, e);
        }
    }), L.markerClusterGroup = function(t) {
        return new L.MarkerClusterGroup(t);
    }, L.MarkerCluster = L.Marker.extend({
        initialize: function(t, e, i, n) {
            L.Marker.prototype.initialize.call(this, i ? i._cLatLng || i.getLatLng() : new L.LatLng(0, 0), {
                icon: this
            }), this._group = t, this._zoom = e, this._markers = [], this._childClusters = [], 
            this._childCount = 0, this._iconNeedsUpdate = !0, this._bounds = new L.LatLngBounds(), 
            i && this._addChild(i), n && this._addChild(n);
        },
        getAllChildMarkers: function(t) {
            t = t || [];
            for (var e = this._childClusters.length - 1; e >= 0; e--) this._childClusters[e].getAllChildMarkers(t);
            for (var i = this._markers.length - 1; i >= 0; i--) t.push(this._markers[i]);
            return t;
        },
        getChildCount: function() {
            return this._childCount;
        },
        zoomToBounds: function() {
            for (var t, e = this._childClusters.slice(), i = this._group._map, n = i.getBoundsZoom(this._bounds), s = this._zoom + 1, r = i.getZoom(); e.length > 0 && n > s; ) {
                s++;
                var o = [];
                for (t = 0; t < e.length; t++) o = o.concat(e[t]._childClusters);
                e = o;
            }
            n > s ? this._group._map.setView(this._latlng, s) : r >= n ? this._group._map.setView(this._latlng, r + 1) : this._group._map.fitBounds(this._bounds);
        },
        getBounds: function() {
            var t = new L.LatLngBounds();
            return t.extend(this._bounds), t;
        },
        _updateIcon: function() {
            this._iconNeedsUpdate = !0, this._icon && this.setIcon(this);
        },
        createIcon: function() {
            return this._iconNeedsUpdate && (this._iconObj = this._group.options.iconCreateFunction(this), 
            this._iconNeedsUpdate = !1), this._iconObj.createIcon();
        },
        createShadow: function() {
            return this._iconObj.createShadow();
        },
        _addChild: function(t, e) {
            this._iconNeedsUpdate = !0, this._expandBounds(t), t instanceof L.MarkerCluster ? (e || (this._childClusters.push(t), 
            t.__parent = this), this._childCount += t._childCount) : (e || this._markers.push(t), 
            this._childCount++), this.__parent && this.__parent._addChild(t, !0);
        },
        _expandBounds: function(t) {
            var e, i = t._wLatLng || t._latlng;
            t instanceof L.MarkerCluster ? (this._bounds.extend(t._bounds), e = t._childCount) : (this._bounds.extend(i), 
            e = 1), this._cLatLng || (this._cLatLng = t._cLatLng || i);
            var n = this._childCount + e;
            this._wLatLng ? (this._wLatLng.lat = (i.lat * e + this._wLatLng.lat * this._childCount) / n, 
            this._wLatLng.lng = (i.lng * e + this._wLatLng.lng * this._childCount) / n) : this._latlng = this._wLatLng = new L.LatLng(i.lat, i.lng);
        },
        _addToMap: function(t) {
            t && (this._backupLatlng = this._latlng, this.setLatLng(t)), this._group._featureGroup.addLayer(this);
        },
        _recursivelyAnimateChildrenIn: function(t, e, i) {
            this._recursively(t, 0, i - 1, function(t) {
                var i, n, s = t._markers;
                for (i = s.length - 1; i >= 0; i--) n = s[i], n._icon && (n._setPos(e), n.setOpacity(0));
            }, function(t) {
                var i, n, s = t._childClusters;
                for (i = s.length - 1; i >= 0; i--) n = s[i], n._icon && (n._setPos(e), n.setOpacity(0));
            });
        },
        _recursivelyAnimateChildrenInAndAddSelfToMap: function(t, e, i) {
            this._recursively(t, i, 0, function(n) {
                n._recursivelyAnimateChildrenIn(t, n._group._map.latLngToLayerPoint(n.getLatLng()).round(), e), 
                n._isSingleParent() && e - 1 === i ? (n.setOpacity(1), n._recursivelyRemoveChildrenFromMap(t, e)) : n.setOpacity(0), 
                n._addToMap();
            });
        },
        _recursivelyBecomeVisible: function(t, e) {
            this._recursively(t, 0, e, null, function(t) {
                t.setOpacity(1);
            });
        },
        _recursivelyAddChildrenToMap: function(t, e, i) {
            this._recursively(i, -1, e, function(n) {
                if (e !== n._zoom) for (var s = n._markers.length - 1; s >= 0; s--) {
                    var r = n._markers[s];
                    i.contains(r._latlng) && (t && (r._backupLatlng = r.getLatLng(), r.setLatLng(t), 
                    r.setOpacity && r.setOpacity(0)), n._group._featureGroup.addLayer(r));
                }
            }, function(e) {
                e._addToMap(t);
            });
        },
        _recursivelyRestoreChildPositions: function(t) {
            for (var e = this._markers.length - 1; e >= 0; e--) {
                var i = this._markers[e];
                i._backupLatlng && (i.setLatLng(i._backupLatlng), delete i._backupLatlng);
            }
            if (t - 1 === this._zoom) for (var n = this._childClusters.length - 1; n >= 0; n--) this._childClusters[n]._restorePosition(); else for (var s = this._childClusters.length - 1; s >= 0; s--) this._childClusters[s]._recursivelyRestoreChildPositions(t);
        },
        _restorePosition: function() {
            this._backupLatlng && (this.setLatLng(this._backupLatlng), delete this._backupLatlng);
        },
        _recursivelyRemoveChildrenFromMap: function(t, e, i) {
            var n, s;
            this._recursively(t, -1, e - 1, function(t) {
                for (s = t._markers.length - 1; s >= 0; s--) n = t._markers[s], i && i.contains(n._latlng) || (t._group._featureGroup.removeLayer(n), 
                n.setOpacity && n.setOpacity(1));
            }, function(t) {
                for (s = t._childClusters.length - 1; s >= 0; s--) n = t._childClusters[s], i && i.contains(n._latlng) || (t._group._featureGroup.removeLayer(n), 
                n.setOpacity && n.setOpacity(1));
            });
        },
        _recursively: function(t, e, i, n, s) {
            var r, o, a = this._childClusters, h = this._zoom;
            if (e > h) for (r = a.length - 1; r >= 0; r--) o = a[r], t.intersects(o._bounds) && o._recursively(t, e, i, n, s); else if (n && n(this), 
            s && this._zoom === i && s(this), i > h) for (r = a.length - 1; r >= 0; r--) o = a[r], 
            t.intersects(o._bounds) && o._recursively(t, e, i, n, s);
        },
        _recalculateBounds: function() {
            var t, e = this._markers, i = this._childClusters;
            for (this._bounds = new L.LatLngBounds(), delete this._wLatLng, t = e.length - 1; t >= 0; t--) this._expandBounds(e[t]);
            for (t = i.length - 1; t >= 0; t--) this._expandBounds(i[t]);
        },
        _isSingleParent: function() {
            return this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount;
        }
    }), L.DistanceGrid = function(t) {
        this._cellSize = t, this._sqCellSize = t * t, this._grid = {}, this._objectPoint = {};
    }, L.DistanceGrid.prototype = {
        addObject: function(t, e) {
            var i = this._getCoord(e.x), n = this._getCoord(e.y), s = this._grid, r = s[n] = s[n] || {}, o = r[i] = r[i] || [], a = L.Util.stamp(t);
            this._objectPoint[a] = e, o.push(t);
        },
        updateObject: function(t, e) {
            this.removeObject(t), this.addObject(t, e);
        },
        removeObject: function(t, e) {
            var i, n, s = this._getCoord(e.x), r = this._getCoord(e.y), o = this._grid, a = o[r] = o[r] || {}, h = a[s] = a[s] || [];
            for (delete this._objectPoint[L.Util.stamp(t)], i = 0, n = h.length; n > i; i++) if (h[i] === t) return h.splice(i, 1), 
            1 === n && delete a[s], !0;
        },
        eachObject: function(t, e) {
            var i, n, s, r, o, a, h, _ = this._grid;
            for (i in _) {
                o = _[i];
                for (n in o) for (a = o[n], s = 0, r = a.length; r > s; s++) h = t.call(e, a[s]), 
                h && (s--, r--);
            }
        },
        getNearObject: function(t) {
            var e, i, n, s, r, o, a, h, _ = this._getCoord(t.x), u = this._getCoord(t.y), l = this._objectPoint, d = this._sqCellSize, p = null;
            for (e = u - 1; u + 1 >= e; e++) if (s = this._grid[e]) for (i = _ - 1; _ + 1 >= i; i++) if (r = s[i]) for (n = 0, 
            o = r.length; o > n; n++) a = r[n], h = this._sqDist(l[L.Util.stamp(a)], t), d > h && (d = h, 
            p = a);
            return p;
        },
        _getCoord: function(t) {
            return Math.floor(t / this._cellSize);
        },
        _sqDist: function(t, e) {
            var i = e.x - t.x, n = e.y - t.y;
            return i * i + n * n;
        }
    }, function() {
        L.QuickHull = {
            getDistant: function(t, e) {
                var i = e[1].lat - e[0].lat, n = e[0].lng - e[1].lng;
                return n * (t.lat - e[0].lat) + i * (t.lng - e[0].lng);
            },
            findMostDistantPointFromBaseLine: function(t, e) {
                var i, n, s, r = 0, o = null, a = [];
                for (i = e.length - 1; i >= 0; i--) n = e[i], s = this.getDistant(n, t), s > 0 && (a.push(n), 
                s > r && (r = s, o = n));
                return {
                    maxPoint: o,
                    newPoints: a
                };
            },
            buildConvexHull: function(t, e) {
                var i = [], n = this.findMostDistantPointFromBaseLine(t, e);
                return n.maxPoint ? (i = i.concat(this.buildConvexHull([ t[0], n.maxPoint ], n.newPoints)), 
                i = i.concat(this.buildConvexHull([ n.maxPoint, t[1] ], n.newPoints))) : [ t[0] ];
            },
            getConvexHull: function(t) {
                var e, i = !1, n = !1, s = null, r = null;
                for (e = t.length - 1; e >= 0; e--) {
                    var o = t[e];
                    (i === !1 || o.lat > i) && (s = o, i = o.lat), (n === !1 || o.lat < n) && (r = o, 
                    n = o.lat);
                }
                var a = [].concat(this.buildConvexHull([ r, s ], t), this.buildConvexHull([ s, r ], t));
                return a;
            }
        };
    }(), L.MarkerCluster.include({
        getConvexHull: function() {
            var t, e, i = this.getAllChildMarkers(), n = [];
            for (e = i.length - 1; e >= 0; e--) t = i[e].getLatLng(), n.push(t);
            return L.QuickHull.getConvexHull(n);
        }
    }), L.MarkerCluster.include({
        _2PI: 2 * Math.PI,
        _circleFootSeparation: 25,
        _circleStartAngle: Math.PI / 6,
        _spiralFootSeparation: 28,
        _spiralLengthStart: 11,
        _spiralLengthFactor: 5,
        _circleSpiralSwitchover: 9,
        spiderfy: function() {
            if (this._group._spiderfied !== this && !this._group._inZoomAnimation) {
                var t, e = this.getAllChildMarkers(), i = this._group, n = i._map, s = n.latLngToLayerPoint(this._latlng);
                this._group._unspiderfy(), this._group._spiderfied = this, e.length >= this._circleSpiralSwitchover ? t = this._generatePointsSpiral(e.length, s) : (s.y += 10, 
                t = this._generatePointsCircle(e.length, s)), this._animationSpiderfy(e, t);
            }
        },
        unspiderfy: function(t) {
            this._group._inZoomAnimation || (this._animationUnspiderfy(t), this._group._spiderfied = null);
        },
        _generatePointsCircle: function(t, e) {
            var i, n, s = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + t), r = s / this._2PI, o = this._2PI / t, a = [];
            for (a.length = t, i = t - 1; i >= 0; i--) n = this._circleStartAngle + i * o, a[i] = new L.Point(e.x + r * Math.cos(n), e.y + r * Math.sin(n))._round();
            return a;
        },
        _generatePointsSpiral: function(t, e) {
            var i, n = this._group.options.spiderfyDistanceMultiplier * this._spiralLengthStart, s = this._group.options.spiderfyDistanceMultiplier * this._spiralFootSeparation, r = this._group.options.spiderfyDistanceMultiplier * this._spiralLengthFactor, o = 0, a = [];
            for (a.length = t, i = t - 1; i >= 0; i--) o += s / n + 5e-4 * i, a[i] = new L.Point(e.x + n * Math.cos(o), e.y + n * Math.sin(o))._round(), 
            n += this._2PI * r / o;
            return a;
        },
        _noanimationUnspiderfy: function() {
            var t, e, i = this._group, n = i._map, s = i._featureGroup, r = this.getAllChildMarkers();
            for (this.setOpacity(1), e = r.length - 1; e >= 0; e--) t = r[e], s.removeLayer(t), 
            t._preSpiderfyLatlng && (t.setLatLng(t._preSpiderfyLatlng), delete t._preSpiderfyLatlng), 
            t.setZIndexOffset && t.setZIndexOffset(0), t._spiderLeg && (n.removeLayer(t._spiderLeg), 
            delete t._spiderLeg);
            i._spiderfied = null;
        }
    }), L.MarkerCluster.include(L.DomUtil.TRANSITION ? {
        SVG_ANIMATION: function() {
            return e.createElementNS("http://www.w3.org/2000/svg", "animate").toString().indexOf("SVGAnimate") > -1;
        }(),
        _animationSpiderfy: function(t, i) {
            var n, s, r, o, a = this, h = this._group, _ = h._map, u = h._featureGroup, l = _.latLngToLayerPoint(this._latlng);
            for (n = t.length - 1; n >= 0; n--) s = t[n], s.setOpacity ? (s.setZIndexOffset(1e6), 
            s.setOpacity(0), u.addLayer(s), s._setPos(l)) : u.addLayer(s);
            h._forceLayout(), h._animationStart();
            var d = L.Path.SVG ? 0 : .3, p = L.Path.SVG_NS;
            for (n = t.length - 1; n >= 0; n--) if (o = _.layerPointToLatLng(i[n]), s = t[n], 
            s._preSpiderfyLatlng = s._latlng, s.setLatLng(o), s.setOpacity && s.setOpacity(1), 
            r = new L.Polyline([ a._latlng, o ], {
                weight: 1.5,
                color: "#222",
                opacity: d
            }), _.addLayer(r), s._spiderLeg = r, L.Path.SVG && this.SVG_ANIMATION) {
                var c = r._path.getTotalLength();
                r._path.setAttribute("stroke-dasharray", c + "," + c);
                var m = e.createElementNS(p, "animate");
                m.setAttribute("attributeName", "stroke-dashoffset"), m.setAttribute("begin", "indefinite"), 
                m.setAttribute("from", c), m.setAttribute("to", 0), m.setAttribute("dur", .25), 
                r._path.appendChild(m), m.beginElement(), m = e.createElementNS(p, "animate"), m.setAttribute("attributeName", "stroke-opacity"), 
                m.setAttribute("attributeName", "stroke-opacity"), m.setAttribute("begin", "indefinite"), 
                m.setAttribute("from", 0), m.setAttribute("to", .5), m.setAttribute("dur", .25), 
                r._path.appendChild(m), m.beginElement();
            }
            if (a.setOpacity(.3), L.Path.SVG) for (this._group._forceLayout(), n = t.length - 1; n >= 0; n--) s = t[n]._spiderLeg, 
            s.options.opacity = .5, s._path.setAttribute("stroke-opacity", .5);
            setTimeout(function() {
                h._animationEnd(), h.fire("spiderfied");
            }, 200);
        },
        _animationUnspiderfy: function(t) {
            var e, i, n, s = this._group, r = s._map, o = s._featureGroup, a = t ? r._latLngToNewLayerPoint(this._latlng, t.zoom, t.center) : r.latLngToLayerPoint(this._latlng), h = this.getAllChildMarkers(), _ = L.Path.SVG && this.SVG_ANIMATION;
            for (s._animationStart(), this.setOpacity(1), i = h.length - 1; i >= 0; i--) e = h[i], 
            e._preSpiderfyLatlng && (e.setLatLng(e._preSpiderfyLatlng), delete e._preSpiderfyLatlng, 
            e.setOpacity ? (e._setPos(a), e.setOpacity(0)) : o.removeLayer(e), _ && (n = e._spiderLeg._path.childNodes[0], 
            n.setAttribute("to", n.getAttribute("from")), n.setAttribute("from", 0), n.beginElement(), 
            n = e._spiderLeg._path.childNodes[1], n.setAttribute("from", .5), n.setAttribute("to", 0), 
            n.setAttribute("stroke-opacity", 0), n.beginElement(), e._spiderLeg._path.setAttribute("stroke-opacity", 0)));
            setTimeout(function() {
                var t = 0;
                for (i = h.length - 1; i >= 0; i--) e = h[i], e._spiderLeg && t++;
                for (i = h.length - 1; i >= 0; i--) e = h[i], e._spiderLeg && (e.setOpacity && (e.setOpacity(1), 
                e.setZIndexOffset(0)), t > 1 && o.removeLayer(e), r.removeLayer(e._spiderLeg), delete e._spiderLeg);
                s._animationEnd();
            }, 200);
        }
    } : {
        _animationSpiderfy: function(t, e) {
            var i, n, s, r, o = this._group, a = o._map, h = o._featureGroup;
            for (i = t.length - 1; i >= 0; i--) r = a.layerPointToLatLng(e[i]), n = t[i], n._preSpiderfyLatlng = n._latlng, 
            n.setLatLng(r), n.setZIndexOffset && n.setZIndexOffset(1e6), h.addLayer(n), s = new L.Polyline([ this._latlng, r ], {
                weight: 1.5,
                color: "#222"
            }), a.addLayer(s), n._spiderLeg = s;
            this.setOpacity(.3), o.fire("spiderfied");
        },
        _animationUnspiderfy: function() {
            this._noanimationUnspiderfy();
        }
    }), L.MarkerClusterGroup.include({
        _spiderfied: null,
        _spiderfierOnAdd: function() {
            this._map.on("click", this._unspiderfyWrapper, this), this._map.options.zoomAnimation && this._map.on("zoomstart", this._unspiderfyZoomStart, this), 
            this._map.on("zoomend", this._noanimationUnspiderfy, this), L.Path.SVG && !L.Browser.touch && this._map._initPathRoot();
        },
        _spiderfierOnRemove: function() {
            this._map.off("click", this._unspiderfyWrapper, this), this._map.off("zoomstart", this._unspiderfyZoomStart, this), 
            this._map.off("zoomanim", this._unspiderfyZoomAnim, this), this._unspiderfy();
        },
        _unspiderfyZoomStart: function() {
            this._map && this._map.on("zoomanim", this._unspiderfyZoomAnim, this);
        },
        _unspiderfyZoomAnim: function(t) {
            L.DomUtil.hasClass(this._map._mapPane, "leaflet-touching") || (this._map.off("zoomanim", this._unspiderfyZoomAnim, this), 
            this._unspiderfy(t));
        },
        _unspiderfyWrapper: function() {
            this._unspiderfy();
        },
        _unspiderfy: function(t) {
            this._spiderfied && this._spiderfied.unspiderfy(t);
        },
        _noanimationUnspiderfy: function() {
            this._spiderfied && this._spiderfied._noanimationUnspiderfy();
        },
        _unspiderfyLayer: function(t) {
            t._spiderLeg && (this._featureGroup.removeLayer(t), t.setOpacity(1), t.setZIndexOffset(0), 
            this._map.removeLayer(t._spiderLeg), delete t._spiderLeg);
        }
    });
}(window, document);

/* global L */
// A layer control which provides for layer groupings.
// Author: Ishmael Smyrnow
L.Control.GroupedLayers = L.Control.extend({
    options: {
        collapsed: true,
        position: "topright",
        autoZIndex: true,
        exclusiveGroups: []
    },
    initialize: function(baseLayers, groupedOverlays, options) {
        var i, j;
        L.Util.setOptions(this, options);
        this._layers = {};
        this._lastZIndex = 0;
        this._handlingClick = false;
        this._groupList = [];
        this._domGroups = [];
        for (i in baseLayers) {
            this._addLayer(baseLayers[i], i);
        }
        for (i in groupedOverlays) {
            for (var j in groupedOverlays[i]) {
                this._addLayer(groupedOverlays[i][j], j, i, true);
            }
        }
    },
    onAdd: function(map) {
        this._initLayout();
        this._update();
        map.on("layeradd", this._onLayerChange, this).on("layerremove", this._onLayerChange, this);
        return this._container;
    },
    onRemove: function(map) {
        map.off("layeradd", this._onLayerChange).off("layerremove", this._onLayerChange);
    },
    addBaseLayer: function(layer, name) {
        this._addLayer(layer, name);
        this._update();
        return this;
    },
    addOverlay: function(layer, name, group) {
        this._addLayer(layer, name, group, true);
        this._update();
        return this;
    },
    removeLayer: function(layer) {
        var id = L.Util.stamp(layer);
        delete this._layers[id];
        this._update();
        return this;
    },
    _initLayout: function() {
        var className = "leaflet-control-layers", container = this._container = L.DomUtil.create("div", className);
        //Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released
        container.setAttribute("aria-haspopup", true);
        if (!L.Browser.touch) {
            L.DomEvent.disableClickPropagation(container);
            L.DomEvent.on(container, "wheel", L.DomEvent.stopPropagation);
        } else {
            L.DomEvent.on(container, "click", L.DomEvent.stopPropagation);
        }
        var form = this._form = L.DomUtil.create("form", className + "-list");
        if (this.options.collapsed) {
            if (!L.Browser.android) {
                L.DomEvent.on(container, "mouseover", this._expand, this).on(container, "mouseout", this._collapse, this);
            }
            var link = this._layersLink = L.DomUtil.create("a", className + "-toggle", container);
            link.href = "#";
            link.title = "Layers";
            if (L.Browser.touch) {
                L.DomEvent.on(link, "click", L.DomEvent.stop).on(link, "click", this._expand, this);
            } else {
                L.DomEvent.on(link, "focus", this._expand, this);
            }
            this._map.on("click", this._collapse, this);
        } else {
            this._expand();
        }
        this._baseLayersList = L.DomUtil.create("div", className + "-base", form);
        this._separator = L.DomUtil.create("div", className + "-separator", form);
        this._overlaysList = L.DomUtil.create("div", className + "-overlays", form);
        container.appendChild(form);
    },
    _addLayer: function(layer, name, group, overlay) {
        var id = L.Util.stamp(layer);
        this._layers[id] = {
            layer: layer,
            name: name,
            overlay: overlay
        };
        group = group || "";
        var groupId = this._groupList.indexOf(group);
        if (groupId === -1) {
            groupId = this._groupList.push(group) - 1;
        }
        var exclusive = this.options.exclusiveGroups.indexOf(group) != -1;
        this._layers[id].group = {
            name: group,
            id: groupId,
            exclusive: exclusive
        };
        if (this.options.autoZIndex && layer.setZIndex) {
            this._lastZIndex++;
            layer.setZIndex(this._lastZIndex);
        }
    },
    _update: function() {
        if (!this._container) {
            return;
        }
        this._baseLayersList.innerHTML = "";
        this._overlaysList.innerHTML = "";
        this._domGroups.length = 0;
        var baseLayersPresent = false, overlaysPresent = false, i, obj;
        for (i in this._layers) {
            obj = this._layers[i];
            this._addItem(obj);
            overlaysPresent = overlaysPresent || obj.overlay;
            baseLayersPresent = baseLayersPresent || !obj.overlay;
        }
        this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none";
    },
    _onLayerChange: function(e) {
        var obj = this._layers[L.Util.stamp(e.layer)];
        if (!obj) {
            return;
        }
        if (!this._handlingClick) {
            this._update();
        }
        var type = obj.overlay ? e.type === "layeradd" ? "overlayadd" : "overlayremove" : e.type === "layeradd" ? "baselayerchange" : null;
        if (type) {
            this._map.fire(type, obj);
        }
    },
    // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
    _createRadioElement: function(name, checked) {
        var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"';
        if (checked) {
            radioHtml += ' checked="checked"';
        }
        radioHtml += "/>";
        var radioFragment = document.createElement("div");
        radioFragment.innerHTML = radioHtml;
        return radioFragment.firstChild;
    },
    _addItem: function(obj) {
        var label = document.createElement("label"), input, checked = this._map.hasLayer(obj.layer), container;
        if (obj.overlay) {
            if (obj.group.exclusive) {
                groupRadioName = "leaflet-exclusive-group-layer-" + obj.group.id;
                input = this._createRadioElement(groupRadioName, checked);
            } else {
                input = document.createElement("input");
                input.type = "checkbox";
                input.className = "leaflet-control-layers-selector";
                input.defaultChecked = checked;
            }
        } else {
            input = this._createRadioElement("leaflet-base-layers", checked);
        }
        input.layerId = L.Util.stamp(obj.layer);
        L.DomEvent.on(input, "click", this._onInputClick, this);
        var name = document.createElement("span");
        name.innerHTML = " " + obj.name;
        label.appendChild(input);
        label.appendChild(name);
        if (obj.overlay) {
            container = this._overlaysList;
            var groupContainer = this._domGroups[obj.group.id];
            // Create the group container if it doesn't exist
            if (!groupContainer) {
                groupContainer = document.createElement("div");
                groupContainer.className = "leaflet-control-layers-group";
                groupContainer.id = "leaflet-control-layers-group-" + obj.group.id;
                var groupLabel = document.createElement("span");
                groupLabel.className = "leaflet-control-layers-group-name";
                groupLabel.innerHTML = obj.group.name;
                groupContainer.appendChild(groupLabel);
                container.appendChild(groupContainer);
                this._domGroups[obj.group.id] = groupContainer;
            }
            container = groupContainer;
        } else {
            container = this._baseLayersList;
        }
        container.appendChild(label);
        return label;
    },
    _onInputClick: function() {
        var i, input, obj, inputs = this._form.getElementsByTagName("input"), inputsLen = inputs.length;
        this._handlingClick = true;
        for (i = 0; i < inputsLen; i++) {
            input = inputs[i];
            obj = this._layers[input.layerId];
            if (input.checked && !this._map.hasLayer(obj.layer)) {
                this._map.addLayer(obj.layer);
            } else if (!input.checked && this._map.hasLayer(obj.layer)) {
                this._map.removeLayer(obj.layer);
            }
        }
        this._handlingClick = false;
    },
    _expand: function() {
        L.DomUtil.addClass(this._container, "leaflet-control-layers-expanded");
    },
    _collapse: function() {
        this._container.className = this._container.className.replace(" leaflet-control-layers-expanded", "");
    }
});

L.control.groupedLayers = function(baseLayers, groupedOverlays, options) {
    return new L.Control.GroupedLayers(baseLayers, groupedOverlays, options);
};

L.Control.MousePosition = L.Control.extend({
    options: {
        position: "bottomleft",
        separator: " : ",
        emptyString: "Unavailable",
        lngFirst: false,
        numDigits: 5,
        lngFormatter: undefined,
        latFormatter: undefined,
        prefix: ""
    },
    onAdd: function(map) {
        this._container = L.DomUtil.create("div", "leaflet-control-mouseposition");
        L.DomEvent.disableClickPropagation(this._container);
        map.on("mousemove", this._onMouseMove, this);
        this._container.innerHTML = this.options.emptyString;
        return this._container;
    },
    onRemove: function(map) {
        map.off("mousemove", this._onMouseMove);
    },
    _onMouseMove: function(e) {
        var lng = this.options.lngFormatter ? this.options.lngFormatter(e.latlng.lng) : L.Util.formatNum(e.latlng.lng, this.options.numDigits);
        var lat = this.options.latFormatter ? this.options.latFormatter(e.latlng.lat) : L.Util.formatNum(e.latlng.lat, this.options.numDigits);
        var value = this.options.lngFirst ? lng + this.options.separator + lat : lat + this.options.separator + lng;
        var prefixAndValue = this.options.prefix + " " + value;
        this._container.innerHTML = prefixAndValue;
    }
});

L.Map.mergeOptions({
    positionControl: false
});

L.Map.addInitHook(function() {
    if (this.options.positionControl) {
        this.positionControl = new L.Control.MousePosition();
        this.addControl(this.positionControl);
    }
});

L.control.mousePosition = function(options) {
    return new L.Control.MousePosition(options);
};

/*!
 * typeahead.js 0.10.5
 * https://github.com/twitter/typeahead.js
 * Copyright 2013-2014 Twitter, Inc. and other contributors; Licensed MIT
 */
(function($) {
    var _ = function() {
        "use strict";
        return {
            isMsie: function() {
                return /(msie|trident)/i.test(navigator.userAgent) ? navigator.userAgent.match(/(msie |rv:)(\d+(.\d+)?)/i)[2] : false;
            },
            isBlankString: function(str) {
                return !str || /^\s*$/.test(str);
            },
            escapeRegExChars: function(str) {
                return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
            },
            isString: function(obj) {
                return typeof obj === "string";
            },
            isNumber: function(obj) {
                return typeof obj === "number";
            },
            isArray: $.isArray,
            isFunction: $.isFunction,
            isObject: $.isPlainObject,
            isUndefined: function(obj) {
                return typeof obj === "undefined";
            },
            toStr: function toStr(s) {
                return _.isUndefined(s) || s === null ? "" : s + "";
            },
            bind: $.proxy,
            each: function(collection, cb) {
                $.each(collection, reverseArgs);
                function reverseArgs(index, value) {
                    return cb(value, index);
                }
            },
            map: $.map,
            filter: $.grep,
            every: function(obj, test) {
                var result = true;
                if (!obj) {
                    return result;
                }
                $.each(obj, function(key, val) {
                    if (!(result = test.call(null, val, key, obj))) {
                        return false;
                    }
                });
                return !!result;
            },
            some: function(obj, test) {
                var result = false;
                if (!obj) {
                    return result;
                }
                $.each(obj, function(key, val) {
                    if (result = test.call(null, val, key, obj)) {
                        return false;
                    }
                });
                return !!result;
            },
            mixin: $.extend,
            getUniqueId: function() {
                var counter = 0;
                return function() {
                    return counter++;
                };
            }(),
            templatify: function templatify(obj) {
                return $.isFunction(obj) ? obj : template;
                function template() {
                    return String(obj);
                }
            },
            defer: function(fn) {
                setTimeout(fn, 0);
            },
            debounce: function(func, wait, immediate) {
                var timeout, result;
                return function() {
                    var context = this, args = arguments, later, callNow;
                    later = function() {
                        timeout = null;
                        if (!immediate) {
                            result = func.apply(context, args);
                        }
                    };
                    callNow = immediate && !timeout;
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                    if (callNow) {
                        result = func.apply(context, args);
                    }
                    return result;
                };
            },
            throttle: function(func, wait) {
                var context, args, timeout, result, previous, later;
                previous = 0;
                later = function() {
                    previous = new Date();
                    timeout = null;
                    result = func.apply(context, args);
                };
                return function() {
                    var now = new Date(), remaining = wait - (now - previous);
                    context = this;
                    args = arguments;
                    if (remaining <= 0) {
                        clearTimeout(timeout);
                        timeout = null;
                        previous = now;
                        result = func.apply(context, args);
                    } else if (!timeout) {
                        timeout = setTimeout(later, remaining);
                    }
                    return result;
                };
            },
            noop: function() {}
        };
    }();
    var VERSION = "0.10.5";
    var tokenizers = function() {
        "use strict";
        return {
            nonword: nonword,
            whitespace: whitespace,
            obj: {
                nonword: getObjTokenizer(nonword),
                whitespace: getObjTokenizer(whitespace)
            }
        };
        function whitespace(str) {
            str = _.toStr(str);
            return str ? str.split(/\s+/) : [];
        }
        function nonword(str) {
            str = _.toStr(str);
            return str ? str.split(/\W+/) : [];
        }
        function getObjTokenizer(tokenizer) {
            return function setKey() {
                var args = [].slice.call(arguments, 0);
                return function tokenize(o) {
                    var tokens = [];
                    _.each(args, function(k) {
                        tokens = tokens.concat(tokenizer(_.toStr(o[k])));
                    });
                    return tokens;
                };
            };
        }
    }();
    var LruCache = function() {
        "use strict";
        function LruCache(maxSize) {
            this.maxSize = _.isNumber(maxSize) ? maxSize : 100;
            this.reset();
            if (this.maxSize <= 0) {
                this.set = this.get = $.noop;
            }
        }
        _.mixin(LruCache.prototype, {
            set: function set(key, val) {
                var tailItem = this.list.tail, node;
                if (this.size >= this.maxSize) {
                    this.list.remove(tailItem);
                    delete this.hash[tailItem.key];
                }
                if (node = this.hash[key]) {
                    node.val = val;
                    this.list.moveToFront(node);
                } else {
                    node = new Node(key, val);
                    this.list.add(node);
                    this.hash[key] = node;
                    this.size++;
                }
            },
            get: function get(key) {
                var node = this.hash[key];
                if (node) {
                    this.list.moveToFront(node);
                    return node.val;
                }
            },
            reset: function reset() {
                this.size = 0;
                this.hash = {};
                this.list = new List();
            }
        });
        function List() {
            this.head = this.tail = null;
        }
        _.mixin(List.prototype, {
            add: function add(node) {
                if (this.head) {
                    node.next = this.head;
                    this.head.prev = node;
                }
                this.head = node;
                this.tail = this.tail || node;
            },
            remove: function remove(node) {
                node.prev ? node.prev.next = node.next : this.head = node.next;
                node.next ? node.next.prev = node.prev : this.tail = node.prev;
            },
            moveToFront: function(node) {
                this.remove(node);
                this.add(node);
            }
        });
        function Node(key, val) {
            this.key = key;
            this.val = val;
            this.prev = this.next = null;
        }
        return LruCache;
    }();
    var PersistentStorage = function() {
        "use strict";
        var ls, methods;
        try {
            ls = window.localStorage;
            ls.setItem("~~~", "!");
            ls.removeItem("~~~");
        } catch (err) {
            ls = null;
        }
        function PersistentStorage(namespace) {
            this.prefix = [ "__", namespace, "__" ].join("");
            this.ttlKey = "__ttl__";
            this.keyMatcher = new RegExp("^" + _.escapeRegExChars(this.prefix));
        }
        if (ls && window.JSON) {
            methods = {
                _prefix: function(key) {
                    return this.prefix + key;
                },
                _ttlKey: function(key) {
                    return this._prefix(key) + this.ttlKey;
                },
                get: function(key) {
                    if (this.isExpired(key)) {
                        this.remove(key);
                    }
                    return decode(ls.getItem(this._prefix(key)));
                },
                set: function(key, val, ttl) {
                    if (_.isNumber(ttl)) {
                        ls.setItem(this._ttlKey(key), encode(now() + ttl));
                    } else {
                        ls.removeItem(this._ttlKey(key));
                    }
                    return ls.setItem(this._prefix(key), encode(val));
                },
                remove: function(key) {
                    ls.removeItem(this._ttlKey(key));
                    ls.removeItem(this._prefix(key));
                    return this;
                },
                clear: function() {
                    var i, key, keys = [], len = ls.length;
                    for (i = 0; i < len; i++) {
                        if ((key = ls.key(i)).match(this.keyMatcher)) {
                            keys.push(key.replace(this.keyMatcher, ""));
                        }
                    }
                    for (i = keys.length; i--; ) {
                        this.remove(keys[i]);
                    }
                    return this;
                },
                isExpired: function(key) {
                    var ttl = decode(ls.getItem(this._ttlKey(key)));
                    return _.isNumber(ttl) && now() > ttl ? true : false;
                }
            };
        } else {
            methods = {
                get: _.noop,
                set: _.noop,
                remove: _.noop,
                clear: _.noop,
                isExpired: _.noop
            };
        }
        _.mixin(PersistentStorage.prototype, methods);
        return PersistentStorage;
        function now() {
            return new Date().getTime();
        }
        function encode(val) {
            return JSON.stringify(_.isUndefined(val) ? null : val);
        }
        function decode(val) {
            return JSON.parse(val);
        }
    }();
    var Transport = function() {
        "use strict";
        var pendingRequestsCount = 0, pendingRequests = {}, maxPendingRequests = 6, sharedCache = new LruCache(10);
        function Transport(o) {
            o = o || {};
            this.cancelled = false;
            this.lastUrl = null;
            this._send = o.transport ? callbackToDeferred(o.transport) : $.ajax;
            this._get = o.rateLimiter ? o.rateLimiter(this._get) : this._get;
            this._cache = o.cache === false ? new LruCache(0) : sharedCache;
        }
        Transport.setMaxPendingRequests = function setMaxPendingRequests(num) {
            maxPendingRequests = num;
        };
        Transport.resetCache = function resetCache() {
            sharedCache.reset();
        };
        _.mixin(Transport.prototype, {
            _get: function(url, o, cb) {
                var that = this, jqXhr;
                if (this.cancelled || url !== this.lastUrl) {
                    return;
                }
                if (jqXhr = pendingRequests[url]) {
                    jqXhr.done(done).fail(fail);
                } else if (pendingRequestsCount < maxPendingRequests) {
                    pendingRequestsCount++;
                    pendingRequests[url] = this._send(url, o).done(done).fail(fail).always(always);
                } else {
                    this.onDeckRequestArgs = [].slice.call(arguments, 0);
                }
                function done(resp) {
                    cb && cb(null, resp);
                    that._cache.set(url, resp);
                }
                function fail() {
                    cb && cb(true);
                }
                function always() {
                    pendingRequestsCount--;
                    delete pendingRequests[url];
                    if (that.onDeckRequestArgs) {
                        that._get.apply(that, that.onDeckRequestArgs);
                        that.onDeckRequestArgs = null;
                    }
                }
            },
            get: function(url, o, cb) {
                var resp;
                if (_.isFunction(o)) {
                    cb = o;
                    o = {};
                }
                this.cancelled = false;
                this.lastUrl = url;
                if (resp = this._cache.get(url)) {
                    _.defer(function() {
                        cb && cb(null, resp);
                    });
                } else {
                    this._get(url, o, cb);
                }
                return !!resp;
            },
            cancel: function() {
                this.cancelled = true;
            }
        });
        return Transport;
        function callbackToDeferred(fn) {
            return function customSendWrapper(url, o) {
                var deferred = $.Deferred();
                fn(url, o, onSuccess, onError);
                return deferred;
                function onSuccess(resp) {
                    _.defer(function() {
                        deferred.resolve(resp);
                    });
                }
                function onError(err) {
                    _.defer(function() {
                        deferred.reject(err);
                    });
                }
            };
        }
    }();
    var SearchIndex = function() {
        "use strict";
        function SearchIndex(o) {
            o = o || {};
            if (!o.datumTokenizer || !o.queryTokenizer) {
                $.error("datumTokenizer and queryTokenizer are both required");
            }
            this.datumTokenizer = o.datumTokenizer;
            this.queryTokenizer = o.queryTokenizer;
            this.reset();
        }
        _.mixin(SearchIndex.prototype, {
            bootstrap: function bootstrap(o) {
                this.datums = o.datums;
                this.trie = o.trie;
            },
            add: function(data) {
                var that = this;
                data = _.isArray(data) ? data : [ data ];
                _.each(data, function(datum) {
                    var id, tokens;
                    id = that.datums.push(datum) - 1;
                    tokens = normalizeTokens(that.datumTokenizer(datum));
                    _.each(tokens, function(token) {
                        var node, chars, ch;
                        node = that.trie;
                        chars = token.split("");
                        while (ch = chars.shift()) {
                            node = node.children[ch] || (node.children[ch] = newNode());
                            node.ids.push(id);
                        }
                    });
                });
            },
            get: function get(query) {
                var that = this, tokens, matches;
                tokens = normalizeTokens(this.queryTokenizer(query));
                _.each(tokens, function(token) {
                    var node, chars, ch, ids;
                    if (matches && matches.length === 0) {
                        return false;
                    }
                    node = that.trie;
                    chars = token.split("");
                    while (node && (ch = chars.shift())) {
                        node = node.children[ch];
                    }
                    if (node && chars.length === 0) {
                        ids = node.ids.slice(0);
                        matches = matches ? getIntersection(matches, ids) : ids;
                    } else {
                        matches = [];
                        return false;
                    }
                });
                return matches ? _.map(unique(matches), function(id) {
                    return that.datums[id];
                }) : [];
            },
            reset: function reset() {
                this.datums = [];
                this.trie = newNode();
            },
            serialize: function serialize() {
                return {
                    datums: this.datums,
                    trie: this.trie
                };
            }
        });
        return SearchIndex;
        function normalizeTokens(tokens) {
            tokens = _.filter(tokens, function(token) {
                return !!token;
            });
            tokens = _.map(tokens, function(token) {
                return token.toLowerCase();
            });
            return tokens;
        }
        function newNode() {
            return {
                ids: [],
                children: {}
            };
        }
        function unique(array) {
            var seen = {}, uniques = [];
            for (var i = 0, len = array.length; i < len; i++) {
                if (!seen[array[i]]) {
                    seen[array[i]] = true;
                    uniques.push(array[i]);
                }
            }
            return uniques;
        }
        function getIntersection(arrayA, arrayB) {
            var ai = 0, bi = 0, intersection = [];
            arrayA = arrayA.sort(compare);
            arrayB = arrayB.sort(compare);
            var lenArrayA = arrayA.length, lenArrayB = arrayB.length;
            while (ai < lenArrayA && bi < lenArrayB) {
                if (arrayA[ai] < arrayB[bi]) {
                    ai++;
                } else if (arrayA[ai] > arrayB[bi]) {
                    bi++;
                } else {
                    intersection.push(arrayA[ai]);
                    ai++;
                    bi++;
                }
            }
            return intersection;
            function compare(a, b) {
                return a - b;
            }
        }
    }();
    var oParser = function() {
        "use strict";
        return {
            local: getLocal,
            prefetch: getPrefetch,
            remote: getRemote
        };
        function getLocal(o) {
            return o.local || null;
        }
        function getPrefetch(o) {
            var prefetch, defaults;
            defaults = {
                url: null,
                thumbprint: "",
                ttl: 24 * 60 * 60 * 1e3,
                filter: null,
                ajax: {}
            };
            if (prefetch = o.prefetch || null) {
                prefetch = _.isString(prefetch) ? {
                    url: prefetch
                } : prefetch;
                prefetch = _.mixin(defaults, prefetch);
                prefetch.thumbprint = VERSION + prefetch.thumbprint;
                prefetch.ajax.type = prefetch.ajax.type || "GET";
                prefetch.ajax.dataType = prefetch.ajax.dataType || "json";
                !prefetch.url && $.error("prefetch requires url to be set");
            }
            return prefetch;
        }
        function getRemote(o) {
            var remote, defaults;
            defaults = {
                url: null,
                cache: true,
                wildcard: "%QUERY",
                replace: null,
                rateLimitBy: "debounce",
                rateLimitWait: 300,
                send: null,
                filter: null,
                ajax: {}
            };
            if (remote = o.remote || null) {
                remote = _.isString(remote) ? {
                    url: remote
                } : remote;
                remote = _.mixin(defaults, remote);
                remote.rateLimiter = /^throttle$/i.test(remote.rateLimitBy) ? byThrottle(remote.rateLimitWait) : byDebounce(remote.rateLimitWait);
                remote.ajax.type = remote.ajax.type || "GET";
                remote.ajax.dataType = remote.ajax.dataType || "json";
                delete remote.rateLimitBy;
                delete remote.rateLimitWait;
                !remote.url && $.error("remote requires url to be set");
            }
            return remote;
            function byDebounce(wait) {
                return function(fn) {
                    return _.debounce(fn, wait);
                };
            }
            function byThrottle(wait) {
                return function(fn) {
                    return _.throttle(fn, wait);
                };
            }
        }
    }();
    (function(root) {
        "use strict";
        var old, keys;
        old = root.Bloodhound;
        keys = {
            data: "data",
            protocol: "protocol",
            thumbprint: "thumbprint"
        };
        root.Bloodhound = Bloodhound;
        function Bloodhound(o) {
            if (!o || !o.local && !o.prefetch && !o.remote) {
                $.error("one of local, prefetch, or remote is required");
            }
            this.limit = o.limit || 5;
            this.sorter = getSorter(o.sorter);
            this.dupDetector = o.dupDetector || ignoreDuplicates;
            this.local = oParser.local(o);
            this.prefetch = oParser.prefetch(o);
            this.remote = oParser.remote(o);
            this.cacheKey = this.prefetch ? this.prefetch.cacheKey || this.prefetch.url : null;
            this.index = new SearchIndex({
                datumTokenizer: o.datumTokenizer,
                queryTokenizer: o.queryTokenizer
            });
            this.storage = this.cacheKey ? new PersistentStorage(this.cacheKey) : null;
        }
        Bloodhound.noConflict = function noConflict() {
            root.Bloodhound = old;
            return Bloodhound;
        };
        Bloodhound.tokenizers = tokenizers;
        _.mixin(Bloodhound.prototype, {
            _loadPrefetch: function loadPrefetch(o) {
                var that = this, serialized, deferred;
                if (serialized = this._readFromStorage(o.thumbprint)) {
                    this.index.bootstrap(serialized);
                    deferred = $.Deferred().resolve();
                } else {
                    deferred = $.ajax(o.url, o.ajax).done(handlePrefetchResponse);
                }
                return deferred;
                function handlePrefetchResponse(resp) {
                    that.clear();
                    that.add(o.filter ? o.filter(resp) : resp);
                    that._saveToStorage(that.index.serialize(), o.thumbprint, o.ttl);
                }
            },
            _getFromRemote: function getFromRemote(query, cb) {
                var that = this, url, uriEncodedQuery;
                if (!this.transport) {
                    return;
                }
                query = query || "";
                uriEncodedQuery = encodeURIComponent(query);
                url = this.remote.replace ? this.remote.replace(this.remote.url, query) : this.remote.url.replace(this.remote.wildcard, uriEncodedQuery);
                return this.transport.get(url, this.remote.ajax, handleRemoteResponse);
                function handleRemoteResponse(err, resp) {
                    err ? cb([]) : cb(that.remote.filter ? that.remote.filter(resp) : resp);
                }
            },
            _cancelLastRemoteRequest: function cancelLastRemoteRequest() {
                this.transport && this.transport.cancel();
            },
            _saveToStorage: function saveToStorage(data, thumbprint, ttl) {
                if (this.storage) {
                    this.storage.set(keys.data, data, ttl);
                    this.storage.set(keys.protocol, location.protocol, ttl);
                    this.storage.set(keys.thumbprint, thumbprint, ttl);
                }
            },
            _readFromStorage: function readFromStorage(thumbprint) {
                var stored = {}, isExpired;
                if (this.storage) {
                    stored.data = this.storage.get(keys.data);
                    stored.protocol = this.storage.get(keys.protocol);
                    stored.thumbprint = this.storage.get(keys.thumbprint);
                }
                isExpired = stored.thumbprint !== thumbprint || stored.protocol !== location.protocol;
                return stored.data && !isExpired ? stored.data : null;
            },
            _initialize: function initialize() {
                var that = this, local = this.local, deferred;
                deferred = this.prefetch ? this._loadPrefetch(this.prefetch) : $.Deferred().resolve();
                local && deferred.done(addLocalToIndex);
                this.transport = this.remote ? new Transport(this.remote) : null;
                return this.initPromise = deferred.promise();
                function addLocalToIndex() {
                    that.add(_.isFunction(local) ? local() : local);
                }
            },
            initialize: function initialize(force) {
                return !this.initPromise || force ? this._initialize() : this.initPromise;
            },
            add: function add(data) {
                this.index.add(data);
            },
            get: function get(query, cb) {
                var that = this, matches = [], cacheHit = false;
                matches = this.index.get(query);
                matches = this.sorter(matches).slice(0, this.limit);
                matches.length < this.limit ? cacheHit = this._getFromRemote(query, returnRemoteMatches) : this._cancelLastRemoteRequest();
                if (!cacheHit) {
                    (matches.length > 0 || !this.transport) && cb && cb(matches);
                }
                function returnRemoteMatches(remoteMatches) {
                    var matchesWithBackfill = matches.slice(0);
                    _.each(remoteMatches, function(remoteMatch) {
                        var isDuplicate;
                        isDuplicate = _.some(matchesWithBackfill, function(match) {
                            return that.dupDetector(remoteMatch, match);
                        });
                        !isDuplicate && matchesWithBackfill.push(remoteMatch);
                        return matchesWithBackfill.length < that.limit;
                    });
                    cb && cb(that.sorter(matchesWithBackfill));
                }
            },
            clear: function clear() {
                this.index.reset();
            },
            clearPrefetchCache: function clearPrefetchCache() {
                this.storage && this.storage.clear();
            },
            clearRemoteCache: function clearRemoteCache() {
                this.transport && Transport.resetCache();
            },
            ttAdapter: function ttAdapter() {
                return _.bind(this.get, this);
            }
        });
        return Bloodhound;
        function getSorter(sortFn) {
            return _.isFunction(sortFn) ? sort : noSort;
            function sort(array) {
                return array.sort(sortFn);
            }
            function noSort(array) {
                return array;
            }
        }
        function ignoreDuplicates() {
            return false;
        }
    })(this);
    var html = function() {
        return {
            wrapper: '<span class="twitter-typeahead"></span>',
            dropdown: '<span class="tt-dropdown-menu"></span>',
            dataset: '<div class="tt-dataset-%CLASS%"></div>',
            suggestions: '<span class="tt-suggestions"></span>',
            suggestion: '<div class="tt-suggestion"></div>'
        };
    }();
    var css = function() {
        "use strict";
        var css = {
            wrapper: {
                position: "relative",
                display: "inline-block"
            },
            hint: {
                position: "absolute",
                top: "0",
                left: "0",
                borderColor: "transparent",
                boxShadow: "none",
                opacity: "1"
            },
            input: {
                position: "relative",
                verticalAlign: "top",
                backgroundColor: "transparent"
            },
            inputWithNoHint: {
                position: "relative",
                verticalAlign: "top"
            },
            dropdown: {
                position: "absolute",
                top: "100%",
                left: "0",
                zIndex: "100",
                display: "none"
            },
            suggestions: {
                display: "block"
            },
            suggestion: {
                whiteSpace: "nowrap",
                cursor: "pointer"
            },
            suggestionChild: {
                whiteSpace: "normal"
            },
            ltr: {
                left: "0",
                right: "auto"
            },
            rtl: {
                left: "auto",
                right: " 0"
            }
        };
        if (_.isMsie()) {
            _.mixin(css.input, {
                backgroundImage: "url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)"
            });
        }
        if (_.isMsie() && _.isMsie() <= 7) {
            _.mixin(css.input, {
                marginTop: "-1px"
            });
        }
        return css;
    }();
    var EventBus = function() {
        "use strict";
        var namespace = "typeahead:";
        function EventBus(o) {
            if (!o || !o.el) {
                $.error("EventBus initialized without el");
            }
            this.$el = $(o.el);
        }
        _.mixin(EventBus.prototype, {
            trigger: function(type) {
                var args = [].slice.call(arguments, 1);
                this.$el.trigger(namespace + type, args);
            }
        });
        return EventBus;
    }();
    var EventEmitter = function() {
        "use strict";
        var splitter = /\s+/, nextTick = getNextTick();
        return {
            onSync: onSync,
            onAsync: onAsync,
            off: off,
            trigger: trigger
        };
        function on(method, types, cb, context) {
            var type;
            if (!cb) {
                return this;
            }
            types = types.split(splitter);
            cb = context ? bindContext(cb, context) : cb;
            this._callbacks = this._callbacks || {};
            while (type = types.shift()) {
                this._callbacks[type] = this._callbacks[type] || {
                    sync: [],
                    async: []
                };
                this._callbacks[type][method].push(cb);
            }
            return this;
        }
        function onAsync(types, cb, context) {
            return on.call(this, "async", types, cb, context);
        }
        function onSync(types, cb, context) {
            return on.call(this, "sync", types, cb, context);
        }
        function off(types) {
            var type;
            if (!this._callbacks) {
                return this;
            }
            types = types.split(splitter);
            while (type = types.shift()) {
                delete this._callbacks[type];
            }
            return this;
        }
        function trigger(types) {
            var type, callbacks, args, syncFlush, asyncFlush;
            if (!this._callbacks) {
                return this;
            }
            types = types.split(splitter);
            args = [].slice.call(arguments, 1);
            while ((type = types.shift()) && (callbacks = this._callbacks[type])) {
                syncFlush = getFlush(callbacks.sync, this, [ type ].concat(args));
                asyncFlush = getFlush(callbacks.async, this, [ type ].concat(args));
                syncFlush() && nextTick(asyncFlush);
            }
            return this;
        }
        function getFlush(callbacks, context, args) {
            return flush;
            function flush() {
                var cancelled;
                for (var i = 0, len = callbacks.length; !cancelled && i < len; i += 1) {
                    cancelled = callbacks[i].apply(context, args) === false;
                }
                return !cancelled;
            }
        }
        function getNextTick() {
            var nextTickFn;
            if (window.setImmediate) {
                nextTickFn = function nextTickSetImmediate(fn) {
                    setImmediate(function() {
                        fn();
                    });
                };
            } else {
                nextTickFn = function nextTickSetTimeout(fn) {
                    setTimeout(function() {
                        fn();
                    }, 0);
                };
            }
            return nextTickFn;
        }
        function bindContext(fn, context) {
            return fn.bind ? fn.bind(context) : function() {
                fn.apply(context, [].slice.call(arguments, 0));
            };
        }
    }();
    var highlight = function(doc) {
        "use strict";
        var defaults = {
            node: null,
            pattern: null,
            tagName: "strong",
            className: null,
            wordsOnly: false,
            caseSensitive: false
        };
        return function hightlight(o) {
            var regex;
            o = _.mixin({}, defaults, o);
            if (!o.node || !o.pattern) {
                return;
            }
            o.pattern = _.isArray(o.pattern) ? o.pattern : [ o.pattern ];
            regex = getRegex(o.pattern, o.caseSensitive, o.wordsOnly);
            traverse(o.node, hightlightTextNode);
            function hightlightTextNode(textNode) {
                var match, patternNode, wrapperNode;
                if (match = regex.exec(textNode.data)) {
                    wrapperNode = doc.createElement(o.tagName);
                    o.className && (wrapperNode.className = o.className);
                    patternNode = textNode.splitText(match.index);
                    patternNode.splitText(match[0].length);
                    wrapperNode.appendChild(patternNode.cloneNode(true));
                    textNode.parentNode.replaceChild(wrapperNode, patternNode);
                }
                return !!match;
            }
            function traverse(el, hightlightTextNode) {
                var childNode, TEXT_NODE_TYPE = 3;
                for (var i = 0; i < el.childNodes.length; i++) {
                    childNode = el.childNodes[i];
                    if (childNode.nodeType === TEXT_NODE_TYPE) {
                        i += hightlightTextNode(childNode) ? 1 : 0;
                    } else {
                        traverse(childNode, hightlightTextNode);
                    }
                }
            }
        };
        function getRegex(patterns, caseSensitive, wordsOnly) {
            var escapedPatterns = [], regexStr;
            for (var i = 0, len = patterns.length; i < len; i++) {
                escapedPatterns.push(_.escapeRegExChars(patterns[i]));
            }
            regexStr = wordsOnly ? "\\b(" + escapedPatterns.join("|") + ")\\b" : "(" + escapedPatterns.join("|") + ")";
            return caseSensitive ? new RegExp(regexStr) : new RegExp(regexStr, "i");
        }
    }(window.document);
    var Input = function() {
        "use strict";
        var specialKeyCodeMap;
        specialKeyCodeMap = {
            9: "tab",
            27: "esc",
            37: "left",
            39: "right",
            13: "enter",
            38: "up",
            40: "down"
        };
        function Input(o) {
            var that = this, onBlur, onFocus, onKeydown, onInput;
            o = o || {};
            if (!o.input) {
                $.error("input is missing");
            }
            onBlur = _.bind(this._onBlur, this);
            onFocus = _.bind(this._onFocus, this);
            onKeydown = _.bind(this._onKeydown, this);
            onInput = _.bind(this._onInput, this);
            this.$hint = $(o.hint);
            this.$input = $(o.input).on("blur.tt", onBlur).on("focus.tt", onFocus).on("keydown.tt", onKeydown);
            if (this.$hint.length === 0) {
                this.setHint = this.getHint = this.clearHint = this.clearHintIfInvalid = _.noop;
            }
            if (!_.isMsie()) {
                this.$input.on("input.tt", onInput);
            } else {
                this.$input.on("keydown.tt keypress.tt cut.tt paste.tt", function($e) {
                    if (specialKeyCodeMap[$e.which || $e.keyCode]) {
                        return;
                    }
                    _.defer(_.bind(that._onInput, that, $e));
                });
            }
            this.query = this.$input.val();
            this.$overflowHelper = buildOverflowHelper(this.$input);
        }
        Input.normalizeQuery = function(str) {
            return (str || "").replace(/^\s*/g, "").replace(/\s{2,}/g, " ");
        };
        _.mixin(Input.prototype, EventEmitter, {
            _onBlur: function onBlur() {
                this.resetInputValue();
                this.trigger("blurred");
            },
            _onFocus: function onFocus() {
                this.trigger("focused");
            },
            _onKeydown: function onKeydown($e) {
                var keyName = specialKeyCodeMap[$e.which || $e.keyCode];
                this._managePreventDefault(keyName, $e);
                if (keyName && this._shouldTrigger(keyName, $e)) {
                    this.trigger(keyName + "Keyed", $e);
                }
            },
            _onInput: function onInput() {
                this._checkInputValue();
            },
            _managePreventDefault: function managePreventDefault(keyName, $e) {
                var preventDefault, hintValue, inputValue;
                switch (keyName) {
                  case "tab":
                    hintValue = this.getHint();
                    inputValue = this.getInputValue();
                    preventDefault = hintValue && hintValue !== inputValue && !withModifier($e);
                    break;

                  case "up":
                  case "down":
                    preventDefault = !withModifier($e);
                    break;

                  default:
                    preventDefault = false;
                }
                preventDefault && $e.preventDefault();
            },
            _shouldTrigger: function shouldTrigger(keyName, $e) {
                var trigger;
                switch (keyName) {
                  case "tab":
                    trigger = !withModifier($e);
                    break;

                  default:
                    trigger = true;
                }
                return trigger;
            },
            _checkInputValue: function checkInputValue() {
                var inputValue, areEquivalent, hasDifferentWhitespace;
                inputValue = this.getInputValue();
                areEquivalent = areQueriesEquivalent(inputValue, this.query);
                hasDifferentWhitespace = areEquivalent ? this.query.length !== inputValue.length : false;
                this.query = inputValue;
                if (!areEquivalent) {
                    this.trigger("queryChanged", this.query);
                } else if (hasDifferentWhitespace) {
                    this.trigger("whitespaceChanged", this.query);
                }
            },
            focus: function focus() {
                this.$input.focus();
            },
            blur: function blur() {
                this.$input.blur();
            },
            getQuery: function getQuery() {
                return this.query;
            },
            setQuery: function setQuery(query) {
                this.query = query;
            },
            getInputValue: function getInputValue() {
                return this.$input.val();
            },
            setInputValue: function setInputValue(value, silent) {
                this.$input.val(value);
                silent ? this.clearHint() : this._checkInputValue();
            },
            resetInputValue: function resetInputValue() {
                this.setInputValue(this.query, true);
            },
            getHint: function getHint() {
                return this.$hint.val();
            },
            setHint: function setHint(value) {
                this.$hint.val(value);
            },
            clearHint: function clearHint() {
                this.setHint("");
            },
            clearHintIfInvalid: function clearHintIfInvalid() {
                var val, hint, valIsPrefixOfHint, isValid;
                val = this.getInputValue();
                hint = this.getHint();
                valIsPrefixOfHint = val !== hint && hint.indexOf(val) === 0;
                isValid = val !== "" && valIsPrefixOfHint && !this.hasOverflow();
                !isValid && this.clearHint();
            },
            getLanguageDirection: function getLanguageDirection() {
                return (this.$input.css("direction") || "ltr").toLowerCase();
            },
            hasOverflow: function hasOverflow() {
                var constraint = this.$input.width() - 2;
                this.$overflowHelper.text(this.getInputValue());
                return this.$overflowHelper.width() >= constraint;
            },
            isCursorAtEnd: function() {
                var valueLength, selectionStart, range;
                valueLength = this.$input.val().length;
                selectionStart = this.$input[0].selectionStart;
                if (_.isNumber(selectionStart)) {
                    return selectionStart === valueLength;
                } else if (document.selection) {
                    range = document.selection.createRange();
                    range.moveStart("character", -valueLength);
                    return valueLength === range.text.length;
                }
                return true;
            },
            destroy: function destroy() {
                this.$hint.off(".tt");
                this.$input.off(".tt");
                this.$hint = this.$input = this.$overflowHelper = null;
            }
        });
        return Input;
        function buildOverflowHelper($input) {
            return $('<pre aria-hidden="true"></pre>').css({
                position: "absolute",
                visibility: "hidden",
                whiteSpace: "pre",
                fontFamily: $input.css("font-family"),
                fontSize: $input.css("font-size"),
                fontStyle: $input.css("font-style"),
                fontVariant: $input.css("font-variant"),
                fontWeight: $input.css("font-weight"),
                wordSpacing: $input.css("word-spacing"),
                letterSpacing: $input.css("letter-spacing"),
                textIndent: $input.css("text-indent"),
                textRendering: $input.css("text-rendering"),
                textTransform: $input.css("text-transform")
            }).insertAfter($input);
        }
        function areQueriesEquivalent(a, b) {
            return Input.normalizeQuery(a) === Input.normalizeQuery(b);
        }
        function withModifier($e) {
            return $e.altKey || $e.ctrlKey || $e.metaKey || $e.shiftKey;
        }
    }();
    var Dataset = function() {
        "use strict";
        var datasetKey = "ttDataset", valueKey = "ttValue", datumKey = "ttDatum";
        function Dataset(o) {
            o = o || {};
            o.templates = o.templates || {};
            if (!o.source) {
                $.error("missing source");
            }
            if (o.name && !isValidName(o.name)) {
                $.error("invalid dataset name: " + o.name);
            }
            this.query = null;
            this.highlight = !!o.highlight;
            this.name = o.name || _.getUniqueId();
            this.source = o.source;
            this.displayFn = getDisplayFn(o.display || o.displayKey);
            this.templates = getTemplates(o.templates, this.displayFn);
            this.$el = $(html.dataset.replace("%CLASS%", this.name));
        }
        Dataset.extractDatasetName = function extractDatasetName(el) {
            return $(el).data(datasetKey);
        };
        Dataset.extractValue = function extractDatum(el) {
            return $(el).data(valueKey);
        };
        Dataset.extractDatum = function extractDatum(el) {
            return $(el).data(datumKey);
        };
        _.mixin(Dataset.prototype, EventEmitter, {
            _render: function render(query, suggestions) {
                if (!this.$el) {
                    return;
                }
                var that = this, hasSuggestions;
                this.$el.empty();
                hasSuggestions = suggestions && suggestions.length;
                if (!hasSuggestions && this.templates.empty) {
                    this.$el.html(getEmptyHtml()).prepend(that.templates.header ? getHeaderHtml() : null).append(that.templates.footer ? getFooterHtml() : null);
                } else if (hasSuggestions) {
                    this.$el.html(getSuggestionsHtml()).prepend(that.templates.header ? getHeaderHtml() : null).append(that.templates.footer ? getFooterHtml() : null);
                }
                this.trigger("rendered");
                function getEmptyHtml() {
                    return that.templates.empty({
                        query: query,
                        isEmpty: true
                    });
                }
                function getSuggestionsHtml() {
                    var $suggestions, nodes;
                    $suggestions = $(html.suggestions).css(css.suggestions);
                    nodes = _.map(suggestions, getSuggestionNode);
                    $suggestions.append.apply($suggestions, nodes);
                    that.highlight && highlight({
                        className: "tt-highlight",
                        node: $suggestions[0],
                        pattern: query
                    });
                    return $suggestions;
                    function getSuggestionNode(suggestion) {
                        var $el;
                        $el = $(html.suggestion).append(that.templates.suggestion(suggestion)).data(datasetKey, that.name).data(valueKey, that.displayFn(suggestion)).data(datumKey, suggestion);
                        $el.children().each(function() {
                            $(this).css(css.suggestionChild);
                        });
                        return $el;
                    }
                }
                function getHeaderHtml() {
                    return that.templates.header({
                        query: query,
                        isEmpty: !hasSuggestions
                    });
                }
                function getFooterHtml() {
                    return that.templates.footer({
                        query: query,
                        isEmpty: !hasSuggestions
                    });
                }
            },
            getRoot: function getRoot() {
                return this.$el;
            },
            update: function update(query) {
                var that = this;
                this.query = query;
                this.canceled = false;
                this.source(query, render);
                function render(suggestions) {
                    if (!that.canceled && query === that.query) {
                        that._render(query, suggestions);
                    }
                }
            },
            cancel: function cancel() {
                this.canceled = true;
            },
            clear: function clear() {
                this.cancel();
                this.$el.empty();
                this.trigger("rendered");
            },
            isEmpty: function isEmpty() {
                return this.$el.is(":empty");
            },
            destroy: function destroy() {
                this.$el = null;
            }
        });
        return Dataset;
        function getDisplayFn(display) {
            display = display || "value";
            return _.isFunction(display) ? display : displayFn;
            function displayFn(obj) {
                return obj[display];
            }
        }
        function getTemplates(templates, displayFn) {
            return {
                empty: templates.empty && _.templatify(templates.empty),
                header: templates.header && _.templatify(templates.header),
                footer: templates.footer && _.templatify(templates.footer),
                suggestion: templates.suggestion || suggestionTemplate
            };
            function suggestionTemplate(context) {
                return "<p>" + displayFn(context) + "</p>";
            }
        }
        function isValidName(str) {
            return /^[_a-zA-Z0-9-]+$/.test(str);
        }
    }();
    var Dropdown = function() {
        "use strict";
        function Dropdown(o) {
            var that = this, onSuggestionClick, onSuggestionMouseEnter, onSuggestionMouseLeave;
            o = o || {};
            if (!o.menu) {
                $.error("menu is required");
            }
            this.isOpen = false;
            this.isEmpty = true;
            this.datasets = _.map(o.datasets, initializeDataset);
            onSuggestionClick = _.bind(this._onSuggestionClick, this);
            onSuggestionMouseEnter = _.bind(this._onSuggestionMouseEnter, this);
            onSuggestionMouseLeave = _.bind(this._onSuggestionMouseLeave, this);
            this.$menu = $(o.menu).on("click.tt", ".tt-suggestion", onSuggestionClick).on("mouseenter.tt", ".tt-suggestion", onSuggestionMouseEnter).on("mouseleave.tt", ".tt-suggestion", onSuggestionMouseLeave);
            _.each(this.datasets, function(dataset) {
                that.$menu.append(dataset.getRoot());
                dataset.onSync("rendered", that._onRendered, that);
            });
        }
        _.mixin(Dropdown.prototype, EventEmitter, {
            _onSuggestionClick: function onSuggestionClick($e) {
                this.trigger("suggestionClicked", $($e.currentTarget));
            },
            _onSuggestionMouseEnter: function onSuggestionMouseEnter($e) {
                this._removeCursor();
                this._setCursor($($e.currentTarget), true);
            },
            _onSuggestionMouseLeave: function onSuggestionMouseLeave() {
                this._removeCursor();
            },
            _onRendered: function onRendered() {
                this.isEmpty = _.every(this.datasets, isDatasetEmpty);
                this.isEmpty ? this._hide() : this.isOpen && this._show();
                this.trigger("datasetRendered");
                function isDatasetEmpty(dataset) {
                    return dataset.isEmpty();
                }
            },
            _hide: function() {
                this.$menu.hide();
            },
            _show: function() {
                this.$menu.css("display", "block");
            },
            _getSuggestions: function getSuggestions() {
                return this.$menu.find(".tt-suggestion");
            },
            _getCursor: function getCursor() {
                return this.$menu.find(".tt-cursor").first();
            },
            _setCursor: function setCursor($el, silent) {
                $el.first().addClass("tt-cursor");
                !silent && this.trigger("cursorMoved");
            },
            _removeCursor: function removeCursor() {
                this._getCursor().removeClass("tt-cursor");
            },
            _moveCursor: function moveCursor(increment) {
                var $suggestions, $oldCursor, newCursorIndex, $newCursor;
                if (!this.isOpen) {
                    return;
                }
                $oldCursor = this._getCursor();
                $suggestions = this._getSuggestions();
                this._removeCursor();
                newCursorIndex = $suggestions.index($oldCursor) + increment;
                newCursorIndex = (newCursorIndex + 1) % ($suggestions.length + 1) - 1;
                if (newCursorIndex === -1) {
                    this.trigger("cursorRemoved");
                    return;
                } else if (newCursorIndex < -1) {
                    newCursorIndex = $suggestions.length - 1;
                }
                this._setCursor($newCursor = $suggestions.eq(newCursorIndex));
                this._ensureVisible($newCursor);
            },
            _ensureVisible: function ensureVisible($el) {
                var elTop, elBottom, menuScrollTop, menuHeight;
                elTop = $el.position().top;
                elBottom = elTop + $el.outerHeight(true);
                menuScrollTop = this.$menu.scrollTop();
                menuHeight = this.$menu.height() + parseInt(this.$menu.css("paddingTop"), 10) + parseInt(this.$menu.css("paddingBottom"), 10);
                if (elTop < 0) {
                    this.$menu.scrollTop(menuScrollTop + elTop);
                } else if (menuHeight < elBottom) {
                    this.$menu.scrollTop(menuScrollTop + (elBottom - menuHeight));
                }
            },
            close: function close() {
                if (this.isOpen) {
                    this.isOpen = false;
                    this._removeCursor();
                    this._hide();
                    this.trigger("closed");
                }
            },
            open: function open() {
                if (!this.isOpen) {
                    this.isOpen = true;
                    !this.isEmpty && this._show();
                    this.trigger("opened");
                }
            },
            setLanguageDirection: function setLanguageDirection(dir) {
                this.$menu.css(dir === "ltr" ? css.ltr : css.rtl);
            },
            moveCursorUp: function moveCursorUp() {
                this._moveCursor(-1);
            },
            moveCursorDown: function moveCursorDown() {
                this._moveCursor(+1);
            },
            getDatumForSuggestion: function getDatumForSuggestion($el) {
                var datum = null;
                if ($el.length) {
                    datum = {
                        raw: Dataset.extractDatum($el),
                        value: Dataset.extractValue($el),
                        datasetName: Dataset.extractDatasetName($el)
                    };
                }
                return datum;
            },
            getDatumForCursor: function getDatumForCursor() {
                return this.getDatumForSuggestion(this._getCursor().first());
            },
            getDatumForTopSuggestion: function getDatumForTopSuggestion() {
                return this.getDatumForSuggestion(this._getSuggestions().first());
            },
            update: function update(query) {
                _.each(this.datasets, updateDataset);
                function updateDataset(dataset) {
                    dataset.update(query);
                }
            },
            empty: function empty() {
                _.each(this.datasets, clearDataset);
                this.isEmpty = true;
                function clearDataset(dataset) {
                    dataset.clear();
                }
            },
            isVisible: function isVisible() {
                return this.isOpen && !this.isEmpty;
            },
            destroy: function destroy() {
                this.$menu.off(".tt");
                this.$menu = null;
                _.each(this.datasets, destroyDataset);
                function destroyDataset(dataset) {
                    dataset.destroy();
                }
            }
        });
        return Dropdown;
        function initializeDataset(oDataset) {
            return new Dataset(oDataset);
        }
    }();
    var Typeahead = function() {
        "use strict";
        var attrsKey = "ttAttrs";
        function Typeahead(o) {
            var $menu, $input, $hint;
            o = o || {};
            if (!o.input) {
                $.error("missing input");
            }
            this.isActivated = false;
            this.autoselect = !!o.autoselect;
            this.minLength = _.isNumber(o.minLength) ? o.minLength : 1;
            this.$node = buildDom(o.input, o.withHint);
            $menu = this.$node.find(".tt-dropdown-menu");
            $input = this.$node.find(".tt-input");
            $hint = this.$node.find(".tt-hint");
            $input.on("blur.tt", function($e) {
                var active, isActive, hasActive;
                active = document.activeElement;
                isActive = $menu.is(active);
                hasActive = $menu.has(active).length > 0;
                if (_.isMsie() && (isActive || hasActive)) {
                    $e.preventDefault();
                    $e.stopImmediatePropagation();
                    _.defer(function() {
                        $input.focus();
                    });
                }
            });
            $menu.on("mousedown.tt", function($e) {
                $e.preventDefault();
            });
            this.eventBus = o.eventBus || new EventBus({
                el: $input
            });
            this.dropdown = new Dropdown({
                menu: $menu,
                datasets: o.datasets
            }).onSync("suggestionClicked", this._onSuggestionClicked, this).onSync("cursorMoved", this._onCursorMoved, this).onSync("cursorRemoved", this._onCursorRemoved, this).onSync("opened", this._onOpened, this).onSync("closed", this._onClosed, this).onAsync("datasetRendered", this._onDatasetRendered, this);
            this.input = new Input({
                input: $input,
                hint: $hint
            }).onSync("focused", this._onFocused, this).onSync("blurred", this._onBlurred, this).onSync("enterKeyed", this._onEnterKeyed, this).onSync("tabKeyed", this._onTabKeyed, this).onSync("escKeyed", this._onEscKeyed, this).onSync("upKeyed", this._onUpKeyed, this).onSync("downKeyed", this._onDownKeyed, this).onSync("leftKeyed", this._onLeftKeyed, this).onSync("rightKeyed", this._onRightKeyed, this).onSync("queryChanged", this._onQueryChanged, this).onSync("whitespaceChanged", this._onWhitespaceChanged, this);
            this._setLanguageDirection();
        }
        _.mixin(Typeahead.prototype, {
            _onSuggestionClicked: function onSuggestionClicked(type, $el) {
                var datum;
                if (datum = this.dropdown.getDatumForSuggestion($el)) {
                    this._select(datum);
                }
            },
            _onCursorMoved: function onCursorMoved() {
                var datum = this.dropdown.getDatumForCursor();
                this.input.setInputValue(datum.value, true);
                this.eventBus.trigger("cursorchanged", datum.raw, datum.datasetName);
            },
            _onCursorRemoved: function onCursorRemoved() {
                this.input.resetInputValue();
                this._updateHint();
            },
            _onDatasetRendered: function onDatasetRendered() {
                this._updateHint();
            },
            _onOpened: function onOpened() {
                this._updateHint();
                this.eventBus.trigger("opened");
            },
            _onClosed: function onClosed() {
                this.input.clearHint();
                this.eventBus.trigger("closed");
            },
            _onFocused: function onFocused() {
                this.isActivated = true;
                this.dropdown.open();
            },
            _onBlurred: function onBlurred() {
                this.isActivated = false;
                this.dropdown.empty();
                this.dropdown.close();
            },
            _onEnterKeyed: function onEnterKeyed(type, $e) {
                var cursorDatum, topSuggestionDatum;
                cursorDatum = this.dropdown.getDatumForCursor();
                topSuggestionDatum = this.dropdown.getDatumForTopSuggestion();
                if (cursorDatum) {
                    this._select(cursorDatum);
                    $e.preventDefault();
                } else if (this.autoselect && topSuggestionDatum) {
                    this._select(topSuggestionDatum);
                    $e.preventDefault();
                }
            },
            _onTabKeyed: function onTabKeyed(type, $e) {
                var datum;
                if (datum = this.dropdown.getDatumForCursor()) {
                    this._select(datum);
                    $e.preventDefault();
                } else {
                    this._autocomplete(true);
                }
            },
            _onEscKeyed: function onEscKeyed() {
                this.dropdown.close();
                this.input.resetInputValue();
            },
            _onUpKeyed: function onUpKeyed() {
                var query = this.input.getQuery();
                this.dropdown.isEmpty && query.length >= this.minLength ? this.dropdown.update(query) : this.dropdown.moveCursorUp();
                this.dropdown.open();
            },
            _onDownKeyed: function onDownKeyed() {
                var query = this.input.getQuery();
                this.dropdown.isEmpty && query.length >= this.minLength ? this.dropdown.update(query) : this.dropdown.moveCursorDown();
                this.dropdown.open();
            },
            _onLeftKeyed: function onLeftKeyed() {
                this.dir === "rtl" && this._autocomplete();
            },
            _onRightKeyed: function onRightKeyed() {
                this.dir === "ltr" && this._autocomplete();
            },
            _onQueryChanged: function onQueryChanged(e, query) {
                this.input.clearHintIfInvalid();
                query.length >= this.minLength ? this.dropdown.update(query) : this.dropdown.empty();
                this.dropdown.open();
                this._setLanguageDirection();
            },
            _onWhitespaceChanged: function onWhitespaceChanged() {
                this._updateHint();
                this.dropdown.open();
            },
            _setLanguageDirection: function setLanguageDirection() {
                var dir;
                if (this.dir !== (dir = this.input.getLanguageDirection())) {
                    this.dir = dir;
                    this.$node.css("direction", dir);
                    this.dropdown.setLanguageDirection(dir);
                }
            },
            _updateHint: function updateHint() {
                var datum, val, query, escapedQuery, frontMatchRegEx, match;
                datum = this.dropdown.getDatumForTopSuggestion();
                if (datum && this.dropdown.isVisible() && !this.input.hasOverflow()) {
                    val = this.input.getInputValue();
                    query = Input.normalizeQuery(val);
                    escapedQuery = _.escapeRegExChars(query);
                    frontMatchRegEx = new RegExp("^(?:" + escapedQuery + ")(.+$)", "i");
                    match = frontMatchRegEx.exec(datum.value);
                    match ? this.input.setHint(val + match[1]) : this.input.clearHint();
                } else {
                    this.input.clearHint();
                }
            },
            _autocomplete: function autocomplete(laxCursor) {
                var hint, query, isCursorAtEnd, datum;
                hint = this.input.getHint();
                query = this.input.getQuery();
                isCursorAtEnd = laxCursor || this.input.isCursorAtEnd();
                if (hint && query !== hint && isCursorAtEnd) {
                    datum = this.dropdown.getDatumForTopSuggestion();
                    datum && this.input.setInputValue(datum.value);
                    this.eventBus.trigger("autocompleted", datum.raw, datum.datasetName);
                }
            },
            _select: function select(datum) {
                this.input.setQuery(datum.value);
                this.input.setInputValue(datum.value, true);
                this._setLanguageDirection();
                this.eventBus.trigger("selected", datum.raw, datum.datasetName);
                this.dropdown.close();
                _.defer(_.bind(this.dropdown.empty, this.dropdown));
            },
            open: function open() {
                this.dropdown.open();
            },
            close: function close() {
                this.dropdown.close();
            },
            setVal: function setVal(val) {
                val = _.toStr(val);
                if (this.isActivated) {
                    this.input.setInputValue(val);
                } else {
                    this.input.setQuery(val);
                    this.input.setInputValue(val, true);
                }
                this._setLanguageDirection();
            },
            getVal: function getVal() {
                return this.input.getQuery();
            },
            destroy: function destroy() {
                this.input.destroy();
                this.dropdown.destroy();
                destroyDomStructure(this.$node);
                this.$node = null;
            }
        });
        return Typeahead;
        function buildDom(input, withHint) {
            var $input, $wrapper, $dropdown, $hint;
            $input = $(input);
            $wrapper = $(html.wrapper).css(css.wrapper);
            $dropdown = $(html.dropdown).css(css.dropdown);
            $hint = $input.clone().css(css.hint).css(getBackgroundStyles($input));
            $hint.val("").removeData().addClass("tt-hint").removeAttr("id name placeholder required").prop("readonly", true).attr({
                autocomplete: "off",
                spellcheck: "false",
                tabindex: -1
            });
            $input.data(attrsKey, {
                dir: $input.attr("dir"),
                autocomplete: $input.attr("autocomplete"),
                spellcheck: $input.attr("spellcheck"),
                style: $input.attr("style")
            });
            $input.addClass("tt-input").attr({
                autocomplete: "off",
                spellcheck: false
            }).css(withHint ? css.input : css.inputWithNoHint);
            try {
                !$input.attr("dir") && $input.attr("dir", "auto");
            } catch (e) {}
            return $input.wrap($wrapper).parent().prepend(withHint ? $hint : null).append($dropdown);
        }
        function getBackgroundStyles($el) {
            return {
                backgroundAttachment: $el.css("background-attachment"),
                backgroundClip: $el.css("background-clip"),
                backgroundColor: $el.css("background-color"),
                backgroundImage: $el.css("background-image"),
                backgroundOrigin: $el.css("background-origin"),
                backgroundPosition: $el.css("background-position"),
                backgroundRepeat: $el.css("background-repeat"),
                backgroundSize: $el.css("background-size")
            };
        }
        function destroyDomStructure($node) {
            var $input = $node.find(".tt-input");
            _.each($input.data(attrsKey), function(val, key) {
                _.isUndefined(val) ? $input.removeAttr(key) : $input.attr(key, val);
            });
            $input.detach().removeData(attrsKey).removeClass("tt-input").insertAfter($node);
            $node.remove();
        }
    }();
    (function() {
        "use strict";
        var old, typeaheadKey, methods;
        old = $.fn.typeahead;
        typeaheadKey = "ttTypeahead";
        methods = {
            initialize: function initialize(o, datasets) {
                datasets = _.isArray(datasets) ? datasets : [].slice.call(arguments, 1);
                o = o || {};
                return this.each(attach);
                function attach() {
                    var $input = $(this), eventBus, typeahead;
                    _.each(datasets, function(d) {
                        d.highlight = !!o.highlight;
                    });
                    typeahead = new Typeahead({
                        input: $input,
                        eventBus: eventBus = new EventBus({
                            el: $input
                        }),
                        withHint: _.isUndefined(o.hint) ? true : !!o.hint,
                        minLength: o.minLength,
                        autoselect: o.autoselect,
                        datasets: datasets
                    });
                    $input.data(typeaheadKey, typeahead);
                }
            },
            open: function open() {
                return this.each(openTypeahead);
                function openTypeahead() {
                    var $input = $(this), typeahead;
                    if (typeahead = $input.data(typeaheadKey)) {
                        typeahead.open();
                    }
                }
            },
            close: function close() {
                return this.each(closeTypeahead);
                function closeTypeahead() {
                    var $input = $(this), typeahead;
                    if (typeahead = $input.data(typeaheadKey)) {
                        typeahead.close();
                    }
                }
            },
            val: function val(newVal) {
                return !arguments.length ? getVal(this.first()) : this.each(setVal);
                function setVal() {
                    var $input = $(this), typeahead;
                    if (typeahead = $input.data(typeaheadKey)) {
                        typeahead.setVal(newVal);
                    }
                }
                function getVal($input) {
                    var typeahead, query;
                    if (typeahead = $input.data(typeaheadKey)) {
                        query = typeahead.getVal();
                    }
                    return query;
                }
            },
            destroy: function destroy() {
                return this.each(unattach);
                function unattach() {
                    var $input = $(this), typeahead;
                    if (typeahead = $input.data(typeaheadKey)) {
                        typeahead.destroy();
                        $input.removeData(typeaheadKey);
                    }
                }
            }
        };
        $.fn.typeahead = function(method) {
            var tts;
            if (methods[method] && method !== "initialize") {
                tts = this.filter(function() {
                    return !!$(this).data(typeaheadKey);
                });
                return methods[method].apply(tts, [].slice.call(arguments, 1));
            } else {
                return methods.initialize.apply(this, arguments);
            }
        };
        $.fn.typeahead.noConflict = function noConflict() {
            $.fn.typeahead = old;
            return this;
        };
    })();
})(window.jQuery);

(function() {
    /**
 * Require the given path.
 *
 * @param {String} path
 * @return {Object} exports
 * @api public
 */
    function require(path, parent, orig) {
        var resolved = require.resolve(path);
        // lookup failed
        if (null == resolved) {
            orig = orig || path;
            parent = parent || "root";
            var err = new Error('Failed to require "' + orig + '" from "' + parent + '"');
            err.path = orig;
            err.parent = parent;
            err.require = true;
            throw err;
        }
        var module = require.modules[resolved];
        // perform real require()
        // by invoking the module's
        // registered function
        if (!module._resolving && !module.exports) {
            var mod = {};
            mod.exports = {};
            mod.client = mod.component = true;
            module._resolving = true;
            module.call(this, mod.exports, require.relative(resolved), mod);
            delete module._resolving;
            module.exports = mod.exports;
        }
        return module.exports;
    }
    /**
 * Registered modules.
 */
    require.modules = {};
    /**
 * Registered aliases.
 */
    require.aliases = {};
    /**
 * Resolve `path`.
 *
 * Lookup:
 *
 *   - PATH/index.js
 *   - PATH.js
 *   - PATH
 *
 * @param {String} path
 * @return {String} path or null
 * @api private
 */
    require.resolve = function(path) {
        if (path.charAt(0) === "/") path = path.slice(1);
        var paths = [ path, path + ".js", path + ".json", path + "/index.js", path + "/index.json" ];
        for (var i = 0; i < paths.length; i++) {
            var path = paths[i];
            if (require.modules.hasOwnProperty(path)) return path;
            if (require.aliases.hasOwnProperty(path)) return require.aliases[path];
        }
    };
    /**
 * Normalize `path` relative to the current path.
 *
 * @param {String} curr
 * @param {String} path
 * @return {String}
 * @api private
 */
    require.normalize = function(curr, path) {
        var segs = [];
        if ("." != path.charAt(0)) return path;
        curr = curr.split("/");
        path = path.split("/");
        for (var i = 0; i < path.length; ++i) {
            if (".." == path[i]) {
                curr.pop();
            } else if ("." != path[i] && "" != path[i]) {
                segs.push(path[i]);
            }
        }
        return curr.concat(segs).join("/");
    };
    /**
 * Register module at `path` with callback `definition`.
 *
 * @param {String} path
 * @param {Function} definition
 * @api private
 */
    require.register = function(path, definition) {
        require.modules[path] = definition;
    };
    /**
 * Alias a module definition.
 *
 * @param {String} from
 * @param {String} to
 * @api private
 */
    require.alias = function(from, to) {
        if (!require.modules.hasOwnProperty(from)) {
            throw new Error('Failed to alias "' + from + '", it does not exist');
        }
        require.aliases[to] = from;
    };
    /**
 * Return a require function relative to the `parent` path.
 *
 * @param {String} parent
 * @return {Function}
 * @api private
 */
    require.relative = function(parent) {
        var p = require.normalize(parent, "..");
        /**
   * lastIndexOf helper.
   */
        function lastIndexOf(arr, obj) {
            var i = arr.length;
            while (i--) {
                if (arr[i] === obj) return i;
            }
            return -1;
        }
        /**
   * The relative require() itself.
   */
        function localRequire(path) {
            var resolved = localRequire.resolve(path);
            return require(resolved, parent, path);
        }
        /**
   * Resolve relative to the parent.
   */
        localRequire.resolve = function(path) {
            var c = path.charAt(0);
            if ("/" == c) return path.slice(1);
            if ("." == c) return require.normalize(p, path);
            // resolve deps by returning
            // the dep in the nearest "deps"
            // directory
            var segs = parent.split("/");
            var i = lastIndexOf(segs, "deps") + 1;
            if (!i) i = 0;
            path = segs.slice(0, i + 1).join("/") + "/deps/" + path;
            return path;
        };
        /**
   * Check if module is defined at `path`.
   */
        localRequire.exists = function(path) {
            return require.modules.hasOwnProperty(localRequire.resolve(path));
        };
        return localRequire;
    };
    require.register("component-classes/index.js", function(exports, require, module) {
        /**
 * Module dependencies.
 */
        var index = require("indexof");
        /**
 * Whitespace regexp.
 */
        var re = /\s+/;
        /**
 * toString reference.
 */
        var toString = Object.prototype.toString;
        /**
 * Wrap `el` in a `ClassList`.
 *
 * @param {Element} el
 * @return {ClassList}
 * @api public
 */
        module.exports = function(el) {
            return new ClassList(el);
        };
        /**
 * Initialize a new ClassList for `el`.
 *
 * @param {Element} el
 * @api private
 */
        function ClassList(el) {
            if (!el) throw new Error("A DOM element reference is required");
            this.el = el;
            this.list = el.classList;
        }
        /**
 * Add class `name` if not already present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */
        ClassList.prototype.add = function(name) {
            // classList
            if (this.list) {
                this.list.add(name);
                return this;
            }
            // fallback
            var arr = this.array();
            var i = index(arr, name);
            if (!~i) arr.push(name);
            this.el.className = arr.join(" ");
            return this;
        };
        /**
 * Remove class `name` when present, or
 * pass a regular expression to remove
 * any which match.
 *
 * @param {String|RegExp} name
 * @return {ClassList}
 * @api public
 */
        ClassList.prototype.remove = function(name) {
            if ("[object RegExp]" == toString.call(name)) {
                return this.removeMatching(name);
            }
            // classList
            if (this.list) {
                this.list.remove(name);
                return this;
            }
            // fallback
            var arr = this.array();
            var i = index(arr, name);
            if (~i) arr.splice(i, 1);
            this.el.className = arr.join(" ");
            return this;
        };
        /**
 * Remove all classes matching `re`.
 *
 * @param {RegExp} re
 * @return {ClassList}
 * @api private
 */
        ClassList.prototype.removeMatching = function(re) {
            var arr = this.array();
            for (var i = 0; i < arr.length; i++) {
                if (re.test(arr[i])) {
                    this.remove(arr[i]);
                }
            }
            return this;
        };
        /**
 * Toggle class `name`, can force state via `force`.
 *
 * For browsers that support classList, but do not support `force` yet,
 * the mistake will be detected and corrected.
 *
 * @param {String} name
 * @param {Boolean} force
 * @return {ClassList}
 * @api public
 */
        ClassList.prototype.toggle = function(name, force) {
            // classList
            if (this.list) {
                if ("undefined" !== typeof force) {
                    if (force !== this.list.toggle(name, force)) {
                        this.list.toggle(name);
                    }
                } else {
                    this.list.toggle(name);
                }
                return this;
            }
            // fallback
            if ("undefined" !== typeof force) {
                if (!force) {
                    this.remove(name);
                } else {
                    this.add(name);
                }
            } else {
                if (this.has(name)) {
                    this.remove(name);
                } else {
                    this.add(name);
                }
            }
            return this;
        };
        /**
 * Return an array of classes.
 *
 * @return {Array}
 * @api public
 */
        ClassList.prototype.array = function() {
            var str = this.el.className.replace(/^\s+|\s+$/g, "");
            var arr = str.split(re);
            if ("" === arr[0]) arr.shift();
            return arr;
        };
        /**
 * Check if class `name` is present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */
        ClassList.prototype.has = ClassList.prototype.contains = function(name) {
            return this.list ? this.list.contains(name) : !!~index(this.array(), name);
        };
    });
    require.register("segmentio-extend/index.js", function(exports, require, module) {
        module.exports = function extend(object) {
            // Takes an unlimited number of extenders.
            var args = Array.prototype.slice.call(arguments, 1);
            // For each extender, copy their properties on our object.
            for (var i = 0, source; source = args[i]; i++) {
                if (!source) continue;
                for (var property in source) {
                    object[property] = source[property];
                }
            }
            return object;
        };
    });
    require.register("component-indexof/index.js", function(exports, require, module) {
        module.exports = function(arr, obj) {
            if (arr.indexOf) return arr.indexOf(obj);
            for (var i = 0; i < arr.length; ++i) {
                if (arr[i] === obj) return i;
            }
            return -1;
        };
    });
    require.register("component-event/index.js", function(exports, require, module) {
        var bind = window.addEventListener ? "addEventListener" : "attachEvent", unbind = window.removeEventListener ? "removeEventListener" : "detachEvent", prefix = bind !== "addEventListener" ? "on" : "";
        /**
 * Bind `el` event `type` to `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */
        exports.bind = function(el, type, fn, capture) {
            el[bind](prefix + type, fn, capture || false);
            return fn;
        };
        /**
 * Unbind `el` event `type`'s callback `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */
        exports.unbind = function(el, type, fn, capture) {
            el[unbind](prefix + type, fn, capture || false);
            return fn;
        };
    });
    require.register("timoxley-to-array/index.js", function(exports, require, module) {
        /**
 * Convert an array-like object into an `Array`.
 * If `collection` is already an `Array`, then will return a clone of `collection`.
 *
 * @param {Array | Mixed} collection An `Array` or array-like object to convert e.g. `arguments` or `NodeList`
 * @return {Array} Naive conversion of `collection` to a new `Array`.
 * @api public
 */
        module.exports = function toArray(collection) {
            if (typeof collection === "undefined") return [];
            if (collection === null) return [ null ];
            if (collection === window) return [ window ];
            if (typeof collection === "string") return [ collection ];
            if (isArray(collection)) return collection;
            if (typeof collection.length != "number") return [ collection ];
            if (typeof collection === "function" && collection instanceof Function) return [ collection ];
            var arr = [];
            for (var i = 0; i < collection.length; i++) {
                if (Object.prototype.hasOwnProperty.call(collection, i) || i in collection) {
                    arr.push(collection[i]);
                }
            }
            if (!arr.length) return [];
            return arr;
        };
        function isArray(arr) {
            return Object.prototype.toString.call(arr) === "[object Array]";
        }
    });
    require.register("javve-events/index.js", function(exports, require, module) {
        var events = require("event"), toArray = require("to-array");
        /**
 * Bind `el` event `type` to `fn`.
 *
 * @param {Element} el, NodeList, HTMLCollection or Array
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @api public
 */
        exports.bind = function(el, type, fn, capture) {
            el = toArray(el);
            for (var i = 0; i < el.length; i++) {
                events.bind(el[i], type, fn, capture);
            }
        };
        /**
 * Unbind `el` event `type`'s callback `fn`.
 *
 * @param {Element} el, NodeList, HTMLCollection or Array
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @api public
 */
        exports.unbind = function(el, type, fn, capture) {
            el = toArray(el);
            for (var i = 0; i < el.length; i++) {
                events.unbind(el[i], type, fn, capture);
            }
        };
    });
    require.register("javve-get-by-class/index.js", function(exports, require, module) {
        /**
 * Find all elements with class `className` inside `container`.
 * Use `single = true` to increase performance in older browsers
 * when only one element is needed.
 *
 * @param {String} className
 * @param {Element} container
 * @param {Boolean} single
 * @api public
 */
        module.exports = function() {
            if (document.getElementsByClassName) {
                return function(container, className, single) {
                    if (single) {
                        return container.getElementsByClassName(className)[0];
                    } else {
                        return container.getElementsByClassName(className);
                    }
                };
            } else if (document.querySelector) {
                return function(container, className, single) {
                    className = "." + className;
                    if (single) {
                        return container.querySelector(className);
                    } else {
                        return container.querySelectorAll(className);
                    }
                };
            } else {
                return function(container, className, single) {
                    var classElements = [], tag = "*";
                    if (container == null) {
                        container = document;
                    }
                    var els = container.getElementsByTagName(tag);
                    var elsLen = els.length;
                    var pattern = new RegExp("(^|\\s)" + className + "(\\s|$)");
                    for (var i = 0, j = 0; i < elsLen; i++) {
                        if (pattern.test(els[i].className)) {
                            if (single) {
                                return els[i];
                            } else {
                                classElements[j] = els[i];
                                j++;
                            }
                        }
                    }
                    return classElements;
                };
            }
        }();
    });
    require.register("javve-get-attribute/index.js", function(exports, require, module) {
        /**
 * Return the value for `attr` at `element`.
 *
 * @param {Element} el
 * @param {String} attr
 * @api public
 */
        module.exports = function(el, attr) {
            var result = el.getAttribute && el.getAttribute(attr) || null;
            if (!result) {
                var attrs = el.attributes;
                var length = attrs.length;
                for (var i = 0; i < length; i++) {
                    if (attr[i] !== undefined) {
                        if (attr[i].nodeName === attr) {
                            result = attr[i].nodeValue;
                        }
                    }
                }
            }
            return result;
        };
    });
    require.register("javve-natural-sort/index.js", function(exports, require, module) {
        /*
 * Natural Sort algorithm for Javascript - Version 0.7 - Released under MIT license
 * Author: Jim Palmer (based on chunking idea from Dave Koelle)
 */
        module.exports = function(a, b, options) {
            var re = /(^-?[0-9]+(\.?[0-9]*)[df]?e?[0-9]?$|^0x[0-9a-f]+$|[0-9]+)/gi, sre = /(^[ ]*|[ ]*$)/g, dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/, hre = /^0x[0-9a-f]+$/i, ore = /^0/, options = options || {}, i = function(s) {
                return options.insensitive && ("" + s).toLowerCase() || "" + s;
            }, // convert all to strings strip whitespace
            x = i(a).replace(sre, "") || "", y = i(b).replace(sre, "") || "", // chunk/tokenize
            xN = x.replace(re, "\x00$1\x00").replace(/\0$/, "").replace(/^\0/, "").split("\x00"), yN = y.replace(re, "\x00$1\x00").replace(/\0$/, "").replace(/^\0/, "").split("\x00"), // numeric, hex or date detection
            xD = parseInt(x.match(hre)) || xN.length != 1 && x.match(dre) && Date.parse(x), yD = parseInt(y.match(hre)) || xD && y.match(dre) && Date.parse(y) || null, oFxNcL, oFyNcL, mult = options.desc ? -1 : 1;
            // first try and sort Hex codes or Dates
            if (yD) if (xD < yD) return -1 * mult; else if (xD > yD) return 1 * mult;
            // natural sorting through split numeric strings and default strings
            for (var cLoc = 0, numS = Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {
                // find floats not starting with '0', string or 0 if not defined (Clint Priest)
                oFxNcL = !(xN[cLoc] || "").match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
                oFyNcL = !(yN[cLoc] || "").match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
                // handle numeric vs string comparison - number < string - (Kyle Adams)
                if (isNaN(oFxNcL) !== isNaN(oFyNcL)) {
                    return isNaN(oFxNcL) ? 1 : -1;
                } else if (typeof oFxNcL !== typeof oFyNcL) {
                    oFxNcL += "";
                    oFyNcL += "";
                }
                if (oFxNcL < oFyNcL) return -1 * mult;
                if (oFxNcL > oFyNcL) return 1 * mult;
            }
            return 0;
        };
    });
    require.register("javve-to-string/index.js", function(exports, require, module) {
        module.exports = function(s) {
            s = s === undefined ? "" : s;
            s = s === null ? "" : s;
            s = s.toString();
            return s;
        };
    });
    require.register("component-type/index.js", function(exports, require, module) {
        /**
 * toString ref.
 */
        var toString = Object.prototype.toString;
        /**
 * Return the type of `val`.
 *
 * @param {Mixed} val
 * @return {String}
 * @api public
 */
        module.exports = function(val) {
            switch (toString.call(val)) {
              case "[object Date]":
                return "date";

              case "[object RegExp]":
                return "regexp";

              case "[object Arguments]":
                return "arguments";

              case "[object Array]":
                return "array";

              case "[object Error]":
                return "error";
            }
            if (val === null) return "null";
            if (val === undefined) return "undefined";
            if (val !== val) return "nan";
            if (val && val.nodeType === 1) return "element";
            return typeof val.valueOf();
        };
    });
    require.register("list.js/index.js", function(exports, require, module) {
        /*
ListJS with beta 1.0.0
By Jonny Strömberg (www.jonnystromberg.com, www.listjs.com)
*/
        (function(window, undefined) {
            "use strict";
            var document = window.document, getByClass = require("get-by-class"), extend = require("extend"), indexOf = require("indexof");
            var List = function(id, options, values) {
                var self = this, init, Item = require("./src/item")(self), addAsync = require("./src/add-async")(self), parse = require("./src/parse")(self);
                init = {
                    start: function() {
                        self.listClass = "list";
                        self.searchClass = "search";
                        self.sortClass = "sort";
                        self.page = 200;
                        self.i = 1;
                        self.items = [];
                        self.visibleItems = [];
                        self.matchingItems = [];
                        self.searched = false;
                        self.filtered = false;
                        self.handlers = {
                            updated: []
                        };
                        self.plugins = {};
                        self.helpers = {
                            getByClass: getByClass,
                            extend: extend,
                            indexOf: indexOf
                        };
                        extend(self, options);
                        self.listContainer = typeof id === "string" ? document.getElementById(id) : id;
                        if (!self.listContainer) {
                            return;
                        }
                        self.list = getByClass(self.listContainer, self.listClass, true);
                        self.templater = require("./src/templater")(self);
                        self.search = require("./src/search")(self);
                        self.filter = require("./src/filter")(self);
                        self.sort = require("./src/sort")(self);
                        this.items();
                        self.update();
                        this.plugins();
                    },
                    items: function() {
                        parse(self.list);
                        if (values !== undefined) {
                            self.add(values);
                        }
                    },
                    plugins: function() {
                        for (var i = 0; i < self.plugins.length; i++) {
                            var plugin = self.plugins[i];
                            self[plugin.name] = plugin;
                            plugin.init(self);
                        }
                    }
                };
                /*
    * Add object to list
    */
                this.add = function(values, callback) {
                    if (callback) {
                        addAsync(values, callback);
                        return;
                    }
                    var added = [], notCreate = false;
                    if (values[0] === undefined) {
                        values = [ values ];
                    }
                    for (var i = 0, il = values.length; i < il; i++) {
                        var item = null;
                        if (values[i] instanceof Item) {
                            item = values[i];
                            item.reload();
                        } else {
                            notCreate = self.items.length > self.page ? true : false;
                            item = new Item(values[i], undefined, notCreate);
                        }
                        self.items.push(item);
                        added.push(item);
                    }
                    self.update();
                    return added;
                };
                this.show = function(i, page) {
                    this.i = i;
                    this.page = page;
                    self.update();
                    return self;
                };
                /* Removes object from list.
    * Loops through the list and removes objects where
    * property "valuename" === value
    */
                this.remove = function(valueName, value, options) {
                    var found = 0;
                    for (var i = 0, il = self.items.length; i < il; i++) {
                        if (self.items[i].values()[valueName] == value) {
                            self.templater.remove(self.items[i], options);
                            self.items.splice(i, 1);
                            il--;
                            i--;
                            found++;
                        }
                    }
                    self.update();
                    return found;
                };
                /* Gets the objects in the list which
    * property "valueName" === value
    */
                this.get = function(valueName, value) {
                    var matchedItems = [];
                    for (var i = 0, il = self.items.length; i < il; i++) {
                        var item = self.items[i];
                        if (item.values()[valueName] == value) {
                            matchedItems.push(item);
                        }
                    }
                    return matchedItems;
                };
                /*
    * Get size of the list
    */
                this.size = function() {
                    return self.items.length;
                };
                /*
    * Removes all items from the list
    */
                this.clear = function() {
                    self.templater.clear();
                    self.items = [];
                    return self;
                };
                this.on = function(event, callback) {
                    self.handlers[event].push(callback);
                    return self;
                };
                this.off = function(event, callback) {
                    var e = self.handlers[event];
                    var index = indexOf(e, callback);
                    if (index > -1) {
                        e.splice(index, 1);
                    }
                    return self;
                };
                this.trigger = function(event) {
                    var i = self.handlers[event].length;
                    while (i--) {
                        self.handlers[event][i](self);
                    }
                    return self;
                };
                this.reset = {
                    filter: function() {
                        var is = self.items, il = is.length;
                        while (il--) {
                            is[il].filtered = false;
                        }
                        return self;
                    },
                    search: function() {
                        var is = self.items, il = is.length;
                        while (il--) {
                            is[il].found = false;
                        }
                        return self;
                    }
                };
                this.update = function() {
                    var is = self.items, il = is.length;
                    self.visibleItems = [];
                    self.matchingItems = [];
                    self.templater.clear();
                    for (var i = 0; i < il; i++) {
                        if (is[i].matching() && (self.matchingItems.length + 1 >= self.i && self.visibleItems.length < self.page)) {
                            is[i].show();
                            self.visibleItems.push(is[i]);
                            self.matchingItems.push(is[i]);
                        } else if (is[i].matching()) {
                            self.matchingItems.push(is[i]);
                            is[i].hide();
                        } else {
                            is[i].hide();
                        }
                    }
                    self.trigger("updated");
                    return self;
                };
                init.start();
            };
            module.exports = List;
        })(window);
    });
    require.register("list.js/src/search.js", function(exports, require, module) {
        var events = require("events"), getByClass = require("get-by-class"), toString = require("to-string");
        module.exports = function(list) {
            var item, text, columns, searchString, customSearch;
            var prepare = {
                resetList: function() {
                    list.i = 1;
                    list.templater.clear();
                    customSearch = undefined;
                },
                setOptions: function(args) {
                    if (args.length == 2 && args[1] instanceof Array) {
                        columns = args[1];
                    } else if (args.length == 2 && typeof args[1] == "function") {
                        customSearch = args[1];
                    } else if (args.length == 3) {
                        columns = args[1];
                        customSearch = args[2];
                    }
                },
                setColumns: function() {
                    columns = columns === undefined ? prepare.toArray(list.items[0].values()) : columns;
                },
                setSearchString: function(s) {
                    s = toString(s).toLowerCase();
                    s = s.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
                    // Escape regular expression characters
                    searchString = s;
                },
                toArray: function(values) {
                    var tmpColumn = [];
                    for (var name in values) {
                        tmpColumn.push(name);
                    }
                    return tmpColumn;
                }
            };
            var search = {
                list: function() {
                    for (var k = 0, kl = list.items.length; k < kl; k++) {
                        search.item(list.items[k]);
                    }
                },
                item: function(item) {
                    item.found = false;
                    for (var j = 0, jl = columns.length; j < jl; j++) {
                        if (search.values(item.values(), columns[j])) {
                            item.found = true;
                            return;
                        }
                    }
                },
                values: function(values, column) {
                    if (values.hasOwnProperty(column)) {
                        text = toString(values[column]).toLowerCase();
                        if (searchString !== "" && text.search(searchString) > -1) {
                            return true;
                        }
                    }
                    return false;
                },
                reset: function() {
                    list.reset.search();
                    list.searched = false;
                }
            };
            var searchMethod = function(str) {
                list.trigger("searchStart");
                prepare.resetList();
                prepare.setSearchString(str);
                prepare.setOptions(arguments);
                // str, cols|searchFunction, searchFunction
                prepare.setColumns();
                if (searchString === "") {
                    search.reset();
                } else {
                    list.searched = true;
                    if (customSearch) {
                        customSearch(searchString, columns);
                    } else {
                        search.list();
                    }
                }
                list.update();
                list.trigger("searchComplete");
                return list.visibleItems;
            };
            list.handlers.searchStart = list.handlers.searchStart || [];
            list.handlers.searchComplete = list.handlers.searchComplete || [];
            events.bind(getByClass(list.listContainer, list.searchClass), "keyup", function(e) {
                var target = e.target || e.srcElement, // IE have srcElement
                alreadyCleared = target.value === "" && !list.searched;
                if (!alreadyCleared) {
                    // If oninput already have resetted the list, do nothing
                    searchMethod(target.value);
                }
            });
            // Used to detect click on HTML5 clear button
            events.bind(getByClass(list.listContainer, list.searchClass), "input", function(e) {
                var target = e.target || e.srcElement;
                if (target.value === "") {
                    searchMethod("");
                }
            });
            list.helpers.toString = toString;
            return searchMethod;
        };
    });
    require.register("list.js/src/sort.js", function(exports, require, module) {
        var naturalSort = require("natural-sort"), classes = require("classes"), events = require("events"), getByClass = require("get-by-class"), getAttribute = require("get-attribute");
        module.exports = function(list) {
            list.sortFunction = list.sortFunction || function(itemA, itemB, options) {
                options.desc = options.order == "desc" ? true : false;
                // Natural sort uses this format
                return naturalSort(itemA.values()[options.valueName], itemB.values()[options.valueName], options);
            };
            var buttons = {
                els: undefined,
                clear: function() {
                    for (var i = 0, il = buttons.els.length; i < il; i++) {
                        classes(buttons.els[i]).remove("asc");
                        classes(buttons.els[i]).remove("desc");
                    }
                },
                getOrder: function(btn) {
                    var predefinedOrder = getAttribute(btn, "data-order");
                    if (predefinedOrder == "asc" || predefinedOrder == "desc") {
                        return predefinedOrder;
                    } else if (classes(btn).has("desc")) {
                        return "asc";
                    } else if (classes(btn).has("asc")) {
                        return "desc";
                    } else {
                        return "asc";
                    }
                },
                getInSensitive: function(btn, options) {
                    var insensitive = getAttribute(btn, "data-insensitive");
                    if (insensitive === "true") {
                        options.insensitive = true;
                    } else {
                        options.insensitive = false;
                    }
                },
                setOrder: function(options) {
                    for (var i = 0, il = buttons.els.length; i < il; i++) {
                        var btn = buttons.els[i];
                        if (getAttribute(btn, "data-sort") !== options.valueName) {
                            continue;
                        }
                        var predefinedOrder = getAttribute(btn, "data-order");
                        if (predefinedOrder == "asc" || predefinedOrder == "desc") {
                            if (predefinedOrder == options.order) {
                                classes(btn).add(options.order);
                            }
                        } else {
                            classes(btn).add(options.order);
                        }
                    }
                }
            };
            var sort = function() {
                list.trigger("sortStart");
                options = {};
                var target = arguments[0].currentTarget || arguments[0].srcElement || undefined;
                if (target) {
                    options.valueName = getAttribute(target, "data-sort");
                    buttons.getInSensitive(target, options);
                    options.order = buttons.getOrder(target);
                } else {
                    options = arguments[1] || options;
                    options.valueName = arguments[0];
                    options.order = options.order || "asc";
                    options.insensitive = typeof options.insensitive == "undefined" ? true : options.insensitive;
                }
                buttons.clear();
                buttons.setOrder(options);
                options.sortFunction = options.sortFunction || list.sortFunction;
                list.items.sort(function(a, b) {
                    return options.sortFunction(a, b, options);
                });
                list.update();
                list.trigger("sortComplete");
            };
            // Add handlers
            list.handlers.sortStart = list.handlers.sortStart || [];
            list.handlers.sortComplete = list.handlers.sortComplete || [];
            buttons.els = getByClass(list.listContainer, list.sortClass);
            events.bind(buttons.els, "click", sort);
            list.on("searchStart", buttons.clear);
            list.on("filterStart", buttons.clear);
            // Helpers
            list.helpers.classes = classes;
            list.helpers.naturalSort = naturalSort;
            list.helpers.events = events;
            list.helpers.getAttribute = getAttribute;
            return sort;
        };
    });
    require.register("list.js/src/item.js", function(exports, require, module) {
        module.exports = function(list) {
            return function(initValues, element, notCreate) {
                var item = this;
                this._values = {};
                this.found = false;
                // Show if list.searched == true and this.found == true
                this.filtered = false;
                // Show if list.filtered == true and this.filtered == true
                var init = function(initValues, element, notCreate) {
                    if (element === undefined) {
                        if (notCreate) {
                            item.values(initValues, notCreate);
                        } else {
                            item.values(initValues);
                        }
                    } else {
                        item.elm = element;
                        var values = list.templater.get(item, initValues);
                        item.values(values);
                    }
                };
                this.values = function(newValues, notCreate) {
                    if (newValues !== undefined) {
                        for (var name in newValues) {
                            item._values[name] = newValues[name];
                        }
                        if (notCreate !== true) {
                            list.templater.set(item, item.values());
                        }
                    } else {
                        return item._values;
                    }
                };
                this.show = function() {
                    list.templater.show(item);
                };
                this.hide = function() {
                    list.templater.hide(item);
                };
                this.matching = function() {
                    return list.filtered && list.searched && item.found && item.filtered || list.filtered && !list.searched && item.filtered || !list.filtered && list.searched && item.found || !list.filtered && !list.searched;
                };
                this.visible = function() {
                    return item.elm.parentNode == list.list ? true : false;
                };
                init(initValues, element, notCreate);
            };
        };
    });
    require.register("list.js/src/templater.js", function(exports, require, module) {
        var getByClass = require("get-by-class");
        var Templater = function(list) {
            var itemSource = getItemSource(list.item), templater = this;
            function getItemSource(item) {
                if (item === undefined) {
                    var nodes = list.list.childNodes, items = [];
                    for (var i = 0, il = nodes.length; i < il; i++) {
                        // Only textnodes have a data attribute
                        if (nodes[i].data === undefined) {
                            return nodes[i];
                        }
                    }
                    return null;
                } else if (item.indexOf("<") !== -1) {
                    // Try create html element of list, do not work for tables!!
                    var div = document.createElement("div");
                    div.innerHTML = item;
                    return div.firstChild;
                } else {
                    return document.getElementById(list.item);
                }
            }
            /* Get values from element */
            this.get = function(item, valueNames) {
                templater.create(item);
                var values = {};
                for (var i = 0, il = valueNames.length; i < il; i++) {
                    var elm = getByClass(item.elm, valueNames[i], true);
                    values[valueNames[i]] = elm ? elm.innerHTML : "";
                }
                return values;
            };
            /* Sets values at element */
            this.set = function(item, values) {
                if (!templater.create(item)) {
                    for (var v in values) {
                        if (values.hasOwnProperty(v)) {
                            // TODO speed up if possible
                            var elm = getByClass(item.elm, v, true);
                            if (elm) {
                                /* src attribute for image tag & text for other tags */
                                if (elm.tagName === "IMG" && values[v] !== "") {
                                    elm.src = values[v];
                                } else {
                                    elm.innerHTML = values[v];
                                }
                            }
                        }
                    }
                }
            };
            this.create = function(item) {
                if (item.elm !== undefined) {
                    return false;
                }
                /* If item source does not exists, use the first item in list as
        source for new items */
                var newItem = itemSource.cloneNode(true);
                newItem.removeAttribute("id");
                item.elm = newItem;
                templater.set(item, item.values());
                return true;
            };
            this.remove = function(item) {
                list.list.removeChild(item.elm);
            };
            this.show = function(item) {
                templater.create(item);
                list.list.appendChild(item.elm);
            };
            this.hide = function(item) {
                if (item.elm !== undefined && item.elm.parentNode === list.list) {
                    list.list.removeChild(item.elm);
                }
            };
            this.clear = function() {
                /* .innerHTML = ''; fucks up IE */
                if (list.list.hasChildNodes()) {
                    while (list.list.childNodes.length >= 1) {
                        list.list.removeChild(list.list.firstChild);
                    }
                }
            };
        };
        module.exports = function(list) {
            return new Templater(list);
        };
    });
    require.register("list.js/src/filter.js", function(exports, require, module) {
        module.exports = function(list) {
            // Add handlers
            list.handlers.filterStart = list.handlers.filterStart || [];
            list.handlers.filterComplete = list.handlers.filterComplete || [];
            return function(filterFunction) {
                list.trigger("filterStart");
                list.i = 1;
                // Reset paging
                list.reset.filter();
                if (filterFunction === undefined) {
                    list.filtered = false;
                } else {
                    list.filtered = true;
                    var is = list.items;
                    for (var i = 0, il = is.length; i < il; i++) {
                        var item = is[i];
                        if (filterFunction(item)) {
                            item.filtered = true;
                        } else {
                            item.filtered = false;
                        }
                    }
                }
                list.update();
                list.trigger("filterComplete");
                return list.visibleItems;
            };
        };
    });
    require.register("list.js/src/add-async.js", function(exports, require, module) {
        module.exports = function(list) {
            return function(values, callback, items) {
                var valuesToAdd = values.splice(0, 100);
                items = items || [];
                items = items.concat(list.add(valuesToAdd));
                if (values.length > 0) {
                    setTimeout(function() {
                        addAsync(values, callback, items);
                    }, 10);
                } else {
                    list.update();
                    callback(items);
                }
            };
        };
    });
    require.register("list.js/src/parse.js", function(exports, require, module) {
        module.exports = function(list) {
            var Item = require("./item")(list);
            var getChildren = function(parent) {
                var nodes = parent.childNodes, items = [];
                for (var i = 0, il = nodes.length; i < il; i++) {
                    // Only textnodes have a data attribute
                    if (nodes[i].data === undefined) {
                        items.push(nodes[i]);
                    }
                }
                return items;
            };
            var parse = function(itemElements, valueNames) {
                for (var i = 0, il = itemElements.length; i < il; i++) {
                    list.items.push(new Item(valueNames, itemElements[i]));
                }
            };
            var parseAsync = function(itemElements, valueNames) {
                var itemsToIndex = itemElements.splice(0, 100);
                // TODO: If < 100 items, what happens in IE etc?
                parse(itemsToIndex, valueNames);
                if (itemElements.length > 0) {
                    setTimeout(function() {
                        init.items.indexAsync(itemElements, valueNames);
                    }, 10);
                } else {
                    list.update();
                }
            };
            return function() {
                var itemsToIndex = getChildren(list.list), valueNames = list.valueNames;
                if (list.indexAsync) {
                    parseAsync(itemsToIndex, valueNames);
                } else {
                    parse(itemsToIndex, valueNames);
                }
            };
        };
    });
    require.alias("component-classes/index.js", "list.js/deps/classes/index.js");
    require.alias("component-classes/index.js", "classes/index.js");
    require.alias("component-indexof/index.js", "component-classes/deps/indexof/index.js");
    require.alias("segmentio-extend/index.js", "list.js/deps/extend/index.js");
    require.alias("segmentio-extend/index.js", "extend/index.js");
    require.alias("component-indexof/index.js", "list.js/deps/indexof/index.js");
    require.alias("component-indexof/index.js", "indexof/index.js");
    require.alias("javve-events/index.js", "list.js/deps/events/index.js");
    require.alias("javve-events/index.js", "events/index.js");
    require.alias("component-event/index.js", "javve-events/deps/event/index.js");
    require.alias("timoxley-to-array/index.js", "javve-events/deps/to-array/index.js");
    require.alias("javve-get-by-class/index.js", "list.js/deps/get-by-class/index.js");
    require.alias("javve-get-by-class/index.js", "get-by-class/index.js");
    require.alias("javve-get-attribute/index.js", "list.js/deps/get-attribute/index.js");
    require.alias("javve-get-attribute/index.js", "get-attribute/index.js");
    require.alias("javve-natural-sort/index.js", "list.js/deps/natural-sort/index.js");
    require.alias("javve-natural-sort/index.js", "natural-sort/index.js");
    require.alias("javve-to-string/index.js", "list.js/deps/to-string/index.js");
    require.alias("javve-to-string/index.js", "list.js/deps/to-string/index.js");
    require.alias("javve-to-string/index.js", "to-string/index.js");
    require.alias("javve-to-string/index.js", "javve-to-string/index.js");
    require.alias("component-type/index.js", "list.js/deps/type/index.js");
    require.alias("component-type/index.js", "type/index.js");
    if (typeof exports == "object") {
        module.exports = require("list.js");
    } else if (typeof define == "function" && define.amd) {
        define(function() {
            return require("list.js");
        });
    } else {
        this["List"] = require("list.js");
    }
})();

var map;

var toner;

var tonerLite;

var mapQuestOSM;

var markers = [];

var coords = [];

var english;

var englishLayer;

var italian;

var italianLayer;

var icon;

var icons;

var iconURLs;

var englishSearch = [];

var italianSearch = [];

var englishLabels = {};

var italianLabels = {};

var featureList;

var markerClusters;

var permaLink = {
    id: undefined,
    lang: "en"
};

$(window).resize(function() {
    sizeLayerControl();
});

$(document).on("click", ".feature-row", function(e) {
    sidebarClick(parseInt($(this).attr("id"), 10));
});

icon = new L.Icon({
    iconUrl: "assets/img/signpost-icon.png",
    iconSize: [ 32, 37 ]
});

iconURLs = {
    en: "assets/img/United-Kingdom32.png",
    it: "assets/img/Italy32.png"
};

var PlaceIcon = L.Icon.extend({
    options: {
        iconSize: [ 32, 32 ],
        iconAnchor: [ 16, 32 ],
        popupAnchor: [ 0, -32 ]
    }
});

icons = {
    en: new PlaceIcon({
        iconUrl: iconURLs.en
    }),
    it: new PlaceIcon({
        iconUrl: iconURLs.it
    })
};

markerClusters = new L.MarkerClusterGroup({
    spiderfyOnMaxZoom: true,
    showCoverageOnHover: false,
    zoomToBoundsOnClick: true,
    disableClusteringAtZoom: 16
});

englishLayer = L.geoJson(null);

english = L.geoJson(null, {
    pointToLayer: function(feature, latlng) {
        var marker = new L.Marker(latlng, {
            icon: icons.en
        });
        coords.push(latlng);
        markers[feature.properties.id] = marker;
        return marker;
    },
    onEachFeature: function(feature, layer) {
        if (feature.properties && feature.properties.label) {
            var permalink = window.location.pathname + "?id=" + feature.properties.id + "&lang=en";
            var popup = '<div class="rude-place-popup">';
            popup += "<p>" + feature.properties.label + "</p>";
            popup += '<p><a href="' + permalink + '">Permalink to this place ...</a></p>';
            popup += "</div>";
            layer.bindPopup(popup);
            layer.on("click", function(e) {
                e.target.openPopup();
            });
            englishLabels[feature.properties.id] = {
                stamp: L.stamp(layer),
                feature: feature,
                layer: layer
            };
            englishSearch.push({
                source: "English",
                label: feature.properties.label,
                id: feature.properties.id,
                lat: feature.geometry.coordinates[1],
                lng: feature.geometry.coordinates[0],
                popup: popup,
                marker: layer
            });
        }
    }
});

$.getJSON("assets/data/rude-en.geojson", function(data) {
    english.addData(data);
    map.addLayer(englishLayer);
});

italianLayer = L.geoJson(null);

italian = L.geoJson(null, {
    pointToLayer: function(feature, latlng) {
        var marker = new L.Marker(latlng, {
            icon: icons.it
        });
        coords.push(latlng);
        markers[feature.properties.id] = marker;
        return marker;
    },
    onEachFeature: function(feature, layer) {
        if (feature.properties && feature.properties.label) {
            var permalink = window.location.pathname + "?id=" + feature.properties.id + "&lang=it";
            var popup = '<div class="rude-place-popup">';
            popup += "<p>" + feature.properties.label + "</p>";
            popup += '<p><a href="' + permalink + '">Permalink to this place ...</a></p>';
            popup += "</div>";
            layer.bindPopup(popup);
            layer.on("click", function(e) {
                e.target.openPopup();
            });
            italianLabels[feature.properties.id] = {
                stamp: L.stamp(layer),
                feature: feature,
                layer: layer
            };
            italianSearch.push({
                source: "Italian",
                label: feature.properties.label,
                id: feature.properties.id,
                lat: feature.geometry.coordinates[1],
                lng: feature.geometry.coordinates[0],
                popup: popup,
                marker: layer
            });
        }
    }
});

$.getJSON("assets/data/rude-it.geojson", function(data) {
    italian.addData(data);
});

$(document).one("ajaxStop", function() {
    $("#loading").hide();
    rebuildFeatureList(englishLabels);
    var englishBH = new Bloodhound({
        name: "English",
        datumTokenizer: function(d) {
            return Bloodhound.tokenizers.whitespace(d.label);
        },
        queryTokenizer: Bloodhound.tokenizers.whitespace,
        local: englishSearch,
        limit: 10
    });
    var italianBH = new Bloodhound({
        name: "Italian",
        datumTokenizer: function(d) {
            return Bloodhound.tokenizers.whitespace(d.label);
        },
        queryTokenizer: Bloodhound.tokenizers.whitespace,
        local: italianSearch,
        limit: 10
    });
    englishBH.initialize();
    italianBH.initialize();
    $("#searchbox").typeahead({
        minLength: 3,
        highlight: true,
        hint: false
    }, {
        name: "English",
        displayKey: "label",
        source: englishBH.ttAdapter(),
        templates: {
            header: '<h4 class="typeahead-header"><img src="' + iconURLs.en + '" width="24" height="28">&nbsp;English</h4>'
        }
    }, {
        name: "Italian",
        displayKey: "label",
        source: italianBH.ttAdapter(),
        templates: {
            header: '<h4 class="typeahead-header"><img src="' + iconURLs.it + '" width="24" height="28">&nbsp;Italian</h4>'
        }
    }).on("typeahead:selected", function(obj, datum) {
        if (datum.source === "English") {
            if (!map.hasLayer(englishLayer)) {
                map.addLayer(englishLayer);
            }
            if (map.hasLayer(italianLayer)) {
                map.removeLayer(italianLayer);
            }
            map.setView([ datum.lat, datum.lng ], 10);
            datum.marker.fire("click");
        }
        if (datum.source === "Italian") {
            if (!map.hasLayer(italianLayer)) {
                map.addLayer(italianLayer);
            }
            if (map.hasLayer(englishLayer)) {
                map.removeLayer(englishLayer);
            }
            map.setView([ datum.lat, datum.lng ], 10);
            datum.marker.fire("click");
        }
        if ($(".navbar-collapse").height() > 50) {
            $(".navbar-collapse").collapse("hide");
        }
    }).on("typeahead:opened", function() {
        $(".navbar-collapse.in").css("max-height", $(document).height() - $(".navbar-header").height());
        $(".navbar-collapse.in").css("height", $(document).height() - $(".navbar-header").height());
    }).on("typeahead:closed", function() {
        $(".navbar-collapse.in").css("max-height", "");
        $(".navbar-collapse.in").css("height", "");
    });
    $(".twitter-typeahead").css("position", "static");
    $(".twitter-typeahead").css("display", "block");
    rebuildFeatureList(englishLabels);
    if (permaLink.id && permaLink.lang) {
        var datum;
        if (permaLink.lang === "en" && englishLabels.hasOwnProperty(permaLink.id)) {
            if (!map.hasLayer(englishLayer)) {
                map.addLayer(englishLayer);
            }
            if (map.hasLayer(italianLayer)) {
                map.removeLayer(italianLayer);
            }
            datum = englishLabels[permaLink.id];
            map.setView(datum.layer.getLatLng(), 10);
            datum.layer.fire("click");
        }
        if (permaLink.lang === "it" && italianLabels.hasOwnProperty(permaLink.id)) {
            if (!map.hasLayer(italianLayer)) {
                map.addLayer(italianLayer);
            }
            if (map.hasLayer(englishLayer)) {
                map.removeLayer(englishLayer);
            }
            datum = italianLabels[permaLink.id];
            map.setView(datum.layer.getLatLng(), 10);
            datum.layer.fire("click");
        }
    }
});

$("#list-btn").click(function() {
    $("#sidebar").toggle();
    map.invalidateSize();
    return false;
});

$("#sidebar-hide-btn").click(function() {
    $("#sidebar").hide();
    map.invalidateSize();
});

/* Highlight search box text on click */
$("#searchbox").click(function() {
    $(this).select();
});

/* Prevent hitting enter from refreshing the page */
$("#searchbox").keypress(function(e) {
    if (e.which == 13) {
        e.preventDefault();
    }
});

$("#about-btn").click(function() {
    $("#aboutModal").modal("show");
    $(".navbar-collapse.in").collapse("hide");
    return false;
});

$("#full-extent-btn").click(function() {
    var layer;
    if (map.hasLayer(englishLayer)) {
        layer = english;
    } else if (map.hasLayer(italianLayer)) {
        layer = italian;
    }
    if (layer) {
        map.fitBounds(layer.getBounds());
        $(".navbar-collapse.in").collapse("hide");
    }
    return false;
});

function sidebarClick(id) {
    var layer = markerClusters.getLayer(id);
    map.setView([ layer.getLatLng().lat, layer.getLatLng().lng ], 10);
    layer.fire("click");
    /* Hide sidebar and go to the map on small screens */
    if (document.body.clientWidth <= 767) {
        $("#sidebar").hide();
        map.invalidateSize();
    }
}

function syncSidebar() {
    /* Empty sidebar features */
    $("#feature-list tbody").empty();
    if (map.hasLayer(englishLayer)) {
        $.each(englishLabels, function(index, obj) {
            var stamp = obj.stamp;
            var feature = obj.feature;
            $("#feature-list tbody").append('<tr class="feature-row" id="' + stamp + '" permalink="' + feature.properties.id + '" lang="en" lat="' + feature.geometry.coordinates[1] + '" lng="' + feature.geometry.coordinates[0] + '"><td style="vertical-align: middle;"><img width="16" height="18" src="' + iconURLs.en + '"></td><td class="feature-name">' + feature.properties.label + '</td><td style="vertical-align: middle;"><i class="fa fa-chevron-right pull-right"></i></td></tr>');
        });
        rebuildFeatureList(englishLabels);
    }
    if (map.hasLayer(italianLayer)) {
        $.each(italianLabels, function(index, obj) {
            var stamp = obj.stamp;
            var feature = obj.feature;
            $("#feature-list tbody").append('<tr class="feature-row" id="' + stamp + '" permalink="' + feature.properties.id + '" lang="it" lat="' + feature.geometry.coordinates[1] + '" lng="' + feature.geometry.coordinates[0] + '"><td style="vertical-align: middle;"><img width="16" height="18" src="' + iconURLs.it + '"></td><td class="feature-name">' + feature.properties.label + '</td><td style="vertical-align: middle;"><i class="fa fa-chevron-right pull-right"></i></td></tr>');
        });
        rebuildFeatureList(italianLabels);
    }
}

function sortLabels(labels) {
    labels = $.grep(labels, function(n) {
        return n;
    });
    labels.sort(function(a, b) {
        if (a.feature.properties.label < b.feature.properties.label) {
            return -1;
        }
        if (a.feature.properties.label > b.feature.properties.label) {
            return 1;
        }
        return 0;
    });
    return labels;
}

function rebuildFeatureList(list) {
    /* Update list.js featureList */
    featureList = new List("features", {
        valueNames: [ "feature-name" ],
        page: Object.keys(list).length
    });
    featureList.sort("feature-name", {
        order: "asc"
    });
}

function sizeLayerControl() {
    $(".leaflet-control-layers").css("max-height", $("#map").height() - 50);
}

// Map Base Layers
toner = L.stamenTileLayer("toner", {
    maptiks_id: "Vaguely Rude Places Map - Stamen Toner"
});

tonerLite = L.stamenTileLayer("toner-lite", {
    maptiks_id: "Vaguely Rude Places Map - Stamen Toner Lite"
});

mapQuestOSM = L.tileLayer("http://{s}.mqcdn.com/tiles/1.0.0/osm/{z}/{x}/{y}.png", {
    maxZoom: 19,
    subdomains: [ "otile1", "otile2", "otile3", "otile4" ],
    attribution: 'Tiles courtesy of <a href="http://www.mapquest.com/" target="_blank">MapQuest</a> <img src="http://developer.mapquest.com/content/osm/mq_logo.png">. Map data (c) <a href="http://www.openstreetmap.org/" target="_blank">OpenStreetMap</a> contributors, CC-BY-SA.',
    maptiks_id: "Vaguely Rude Places Map - MapQuest OSM"
});

map = L.map("map", {
    zoom: 3,
    center: [ 0, 0 ],
    layers: [ tonerLite, markerClusters ],
    zoomControl: false,
    attributionControl: false,
    maptiks_id: "Vaguely Rude Places Map"
});

/* Layer control listeners that allow for a single markerClusters layer */
map.on("overlayadd", function(e) {
    if (e.layer === englishLayer) {
        markerClusters.addLayer(english);
        syncSidebar();
    }
    if (e.layer === italianLayer) {
        markerClusters.addLayer(italian);
        syncSidebar();
    }
});

map.on("overlayremove", function(e) {
    if (e.layer === englishLayer) {
        markerClusters.removeLayer(english);
        syncSidebar();
    }
    if (e.layer === italianLayer) {
        markerClusters.removeLayer(italian);
        syncSidebar();
    }
});

/* Larger screens get expanded layer control and visible sidebar */
if (document.body.clientWidth <= 767) {
    var isCollapsed = true;
} else {
    var isCollapsed = false;
}

var baseLayers = {
    "Toner Lite": tonerLite,
    Toner: toner,
    "Street Map": mapQuestOSM
};

var groupedOverlays = {
    Languages: {
        '<img src="assets/img/Italy32.png" width="24" height="28">&nbsp;Italian': italianLayer,
        '<img src="assets/img/United-Kingdom32.png" width="24" height="28">&nbsp;English': englishLayer
    }
};

var layerControl = L.control.groupedLayers(baseLayers, groupedOverlays, {
    exclusiveGroups: [ "Languages" ],
    collapsed: isCollapsed
}).addTo(map);

function updateAttribution(e) {
    $.each(map._layers, function(index, layer) {
        if (layer.getAttribution) {
            $("#attribution").html(layer.getAttribution());
        }
    });
}

map.on("layeradd", updateAttribution);

map.on("layerremove", updateAttribution);

var attributionControl = L.control({
    position: "bottomright"
});

attributionControl.onAdd = function(map) {
    var div = L.DomUtil.create("div", "leaflet-control-attribution");
    div.innerHTML = '<span class="hidden-hs"><a href="http://maps.geotastic.org">More Maps?</a> | This is a thing by <a href="http://www.garygale.com">Gary Gale</a> | </span><a href="#" onclick="$(\'#attributionModal\').modal(\'show\'); return false;">Credits &amp; Attribution</a>';
    return div;
};

map.addControl(attributionControl);

L.control.mousePosition({
    position: "topleft",
    emptyString: "Position Unavailable"
}).addTo(map);

var zoomControl = L.control.zoom({
    position: "bottomright"
}).addTo(map);

var locateControl = L.control.locate({
    position: "bottomright",
    drawCircle: true,
    follow: true,
    setView: true,
    keepCurrentZoomLevel: false,
    markerStyle: {
        weight: 1,
        opacity: .8,
        fillOpacity: .8
    },
    circleStyle: {
        weight: 1,
        clickable: false
    },
    icon: "fa fa-location-arrow",
    metric: false,
    strings: {
        title: "My location",
        popup: "You are within {distance} {unit} from this point",
        outsideMapBoundsMsg: "You seem located outside the boundaries of the map"
    },
    locateOptions: {
        maxZoom: 9,
        watch: true,
        enableHighAccuracy: true,
        maximumAge: 1e4,
        timeout: 1e4
    }
}).addTo(map);

function parsePermaLink(parser) {
    var url = window.location.search.substr(1);
    if (!url) {
        url = window.location.hash.substr(1);
    }
    if (url !== "") {
        nvps = url.split("&");
        $.each(nvps, function(index, value) {
            var nvp = value.split("=");
            parser(nvp[0], nvp[1]);
        });
    }
}

function paramParser(key, value) {
    switch (key) {
      case "id":
        permaLink.id = parseInt(value);
        break;

      case "lang":
        permaLink.lang = value;
        break;

      default:
        break;
    }
}

$(document).ready(function() {
    parsePermaLink(paramParser);
});
